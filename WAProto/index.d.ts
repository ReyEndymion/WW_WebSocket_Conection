import * as $protobuf from "protobufjs";
/** Espacio de nombres proto. */
export namespace proto {

    /** Propiedades de un ADVDeviceIdentity. */
    interface IADVDeviceIdentity {

        /** ADVDeviceIdentity rawId */
        rawId?: (number|null);

        /** ADVDeviceIdentity timestamp */
        timestamp?: (number|Long|null);

        /** ADVDeviceIdentity keyIndex */
        keyIndex?: (number|null);
    }

    /** Representa un ADVDeviceIdentity. */
    class ADVDeviceIdentity implements IADVDeviceIdentity {

        /**
         * Construya un nuevo ADVDeviceIdentity.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IADVDeviceIdentity);

        /** ADVDeviceIdentity rawId. */
        public rawId: number;

        /** ADVDeviceIdentity timestamp. */
        public timestamp: (number|Long);

        /** ADVDeviceIdentity keyIndex. */
        public keyIndex: number;

        /**
         * Crea una nueva instancia ADVDeviceIdentity utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns instancia ADVDeviceIdentity
         */
        public static create(properties?: proto.IADVDeviceIdentity): proto.ADVDeviceIdentity;

        /**
         * Codifica el mensaje ADVDeviceIdentity especificado. No implicamente {@link proto.ADVDeviceIdentity.verify|verify}.
         * @param message ADVDeviceIdentity mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IADVDeviceIdentity, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
          *Codifica el mensaje especificado ADVDeviceIdentity, longitud delimitada. No implica mensajes {@link proto.ADVDeviceIdentity.verify|verify}.
         * @param message ADVDeviceIdentity mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IADVDeviceIdentity, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodifica un mensaje ADVDeviceIdentity del lector o búfer especificado.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ADVDeviceIdentity
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ADVDeviceIdentity;

        /**
         * Decodifica un mensaje ADVDeviceIdentity desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ADVDeviceIdentity
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ADVDeviceIdentity;

        /**
         * Verifica un mensaje ADVDeviceIdentity.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Crea un mensaje ADVDeviceIdentity desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ADVDeviceIdentity
         */
        public static fromObject(object: { [k: string]: any }): proto.ADVDeviceIdentity;

        /**
         * Crea un objeto simple desde un mensaje ADVDeviceIdentity. También convierte valores a otros tipos si se especifica.
         * @param message ADVDeviceIdentity
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ADVDeviceIdentity, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ADVDeviceIdentity a JSON.
         * @returns objea JSON
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un ADVKeyIndexList. */
    interface IADVKeyIndexList {

        /** ADVKeyIndexList rawId */
        rawId?: (number|null);

        /** ADVKeyIndexList timestamp */
        timestamp?: (number|Long|null);

        /** ADVKeyIndexList currentIndex */
        currentIndex?: (number|null);

        /** ADVKeyIndexList validIndexes */
        validIndexes?: (number[]|null);
    }

    /** Representa un ADVKeyIndexList. */
    class ADVKeyIndexList implements IADVKeyIndexList {

        /**
         * Construya un nuevo ADVKeyIndexList.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IADVKeyIndexList);

        /** ADVKeyIndexList rawId. */
        public rawId: number;

        /** ADVKeyIndexList timestamp. */
        public timestamp: (number|Long);

        /** ADVKeyIndexList currentIndex. */
        public currentIndex: number;

        /** ADVKeyIndexList validIndexes. */
        public validIndexes: number[];

        /**
         * Crea una nueva instancia ADVKeyIndexList utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ADVKeyIndexList instance
         */
        public static create(properties?: proto.IADVKeyIndexList): proto.ADVKeyIndexList;

        /**
         * Codifica el mensaje ADVKeyIndexList. No implícitamente mensajes {@link proto.ADVKeyIndexList.verify|verify}.
         * @param message ADVKeyIndexList mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IADVKeyIndexList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ADVKeyIndexList message, delimitado por longitud. No implícitamente mensajes {@link proto.ADVKeyIndexList.verify|verify}.
         * @param message ADVKeyIndexList mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IADVKeyIndexList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ADVKeyIndexList message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ADVKeyIndexList
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ADVKeyIndexList;

        /**
         * Decodes a ADVKeyIndexList message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ADVKeyIndexList
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ADVKeyIndexList;

        /**
         * Verifies a ADVKeyIndexList message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ADVKeyIndexList message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ADVKeyIndexList
         */
        public static fromObject(object: { [k: string]: any }): proto.ADVKeyIndexList;

        /**
         * Crea un objeto simple desde ADVKeyIndexList. También convierte valores a otros tipos si se especifica.
         * @param message ADVKeyIndexList
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ADVKeyIndexList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ADVKeyIndexList a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un ADVSignedDeviceIdentity. */
    interface IADVSignedDeviceIdentity {

        /** ADVSignedDeviceIdentity details */
        details?: (Uint8Array|null);

        /** ADVSignedDeviceIdentity accountSignatureKey */
        accountSignatureKey?: (Uint8Array|null);

        /** ADVSignedDeviceIdentity accountSignature */
        accountSignature?: (Uint8Array|null);

        /** ADVSignedDeviceIdentity deviceSignature */
        deviceSignature?: (Uint8Array|null);
    }

    /** Representa un ADVSignedDeviceIdentity. */
    class ADVSignedDeviceIdentity implements IADVSignedDeviceIdentity {

        /**
         * Construya un nuevo ADVSignedDeviceIdentity.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IADVSignedDeviceIdentity);

        /** ADVSignedDeviceIdentity details. */
        public details: Uint8Array;

        /** ADVSignedDeviceIdentity accountSignatureKey. */
        public accountSignatureKey: Uint8Array;

        /** ADVSignedDeviceIdentity accountSignature. */
        public accountSignature: Uint8Array;

        /** ADVSignedDeviceIdentity deviceSignature. */
        public deviceSignature: Uint8Array;

        /**
         * Crea una nueva instancia ADVSignedDeviceIdentity utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ADVSignedDeviceIdentity instance
         */
        public static create(properties?: proto.IADVSignedDeviceIdentity): proto.ADVSignedDeviceIdentity;

        /**
         * Codifica el mensaje ADVSignedDeviceIdentity. No implícitamente mensajes {@link proto.ADVSignedDeviceIdentity.verify|verify}.
         * @param message ADVSignedDeviceIdentity mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IADVSignedDeviceIdentity, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ADVSignedDeviceIdentity message, delimitado por longitud. No implícitamente mensajes {@link proto.ADVSignedDeviceIdentity.verify|verify}.
         * @param message ADVSignedDeviceIdentity mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IADVSignedDeviceIdentity, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ADVSignedDeviceIdentity message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ADVSignedDeviceIdentity
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ADVSignedDeviceIdentity;

        /**
         * Decodes a ADVSignedDeviceIdentity message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ADVSignedDeviceIdentity
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ADVSignedDeviceIdentity;

        /**
         * Verifies a ADVSignedDeviceIdentity message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ADVSignedDeviceIdentity message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ADVSignedDeviceIdentity
         */
        public static fromObject(object: { [k: string]: any }): proto.ADVSignedDeviceIdentity;

        /**
         * Crea un objeto simple desde ADVSignedDeviceIdentity. También convierte valores a otros tipos si se especifica.
         * @param message ADVSignedDeviceIdentity
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ADVSignedDeviceIdentity, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ADVSignedDeviceIdentity a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un ADVSignedDeviceIdentityHMAC. */
    interface IADVSignedDeviceIdentityHMAC {

        /** ADVSignedDeviceIdentityHMAC details */
        details?: (Uint8Array|null);

        /** ADVSignedDeviceIdentityHMAC hmac */
        hmac?: (Uint8Array|null);
    }

    /** Representa un ADVSignedDeviceIdentityHMAC. */
    class ADVSignedDeviceIdentityHMAC implements IADVSignedDeviceIdentityHMAC {

        /**
         * Construya un nuevo ADVSignedDeviceIdentityHMAC.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IADVSignedDeviceIdentityHMAC);

        /** ADVSignedDeviceIdentityHMAC details. */
        public details: Uint8Array;

        /** ADVSignedDeviceIdentityHMAC hmac. */
        public hmac: Uint8Array;

        /**
         * Crea una nueva instancia ADVSignedDeviceIdentityHMAC utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ADVSignedDeviceIdentityHMAC instance
         */
        public static create(properties?: proto.IADVSignedDeviceIdentityHMAC): proto.ADVSignedDeviceIdentityHMAC;

        /**
         * Codifica el mensaje ADVSignedDeviceIdentityHMAC. No implícitamente mensajes {@link proto.ADVSignedDeviceIdentityHMAC.verify|verify}.
         * @param message ADVSignedDeviceIdentityHMAC mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IADVSignedDeviceIdentityHMAC, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ADVSignedDeviceIdentityHMAC message, delimitado por longitud. No implícitamente mensajes {@link proto.ADVSignedDeviceIdentityHMAC.verify|verify}.
         * @param message ADVSignedDeviceIdentityHMAC mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IADVSignedDeviceIdentityHMAC, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ADVSignedDeviceIdentityHMAC message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ADVSignedDeviceIdentityHMAC
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ADVSignedDeviceIdentityHMAC;

        /**
         * Decodes a ADVSignedDeviceIdentityHMAC message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ADVSignedDeviceIdentityHMAC
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ADVSignedDeviceIdentityHMAC;

        /**
         * Verifies a ADVSignedDeviceIdentityHMAC message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ADVSignedDeviceIdentityHMAC message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ADVSignedDeviceIdentityHMAC
         */
        public static fromObject(object: { [k: string]: any }): proto.ADVSignedDeviceIdentityHMAC;

        /**
         * Crea un objeto simple desde ADVSignedDeviceIdentityHMAC. También convierte valores a otros tipos si se especifica.
         * @param message ADVSignedDeviceIdentityHMAC
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ADVSignedDeviceIdentityHMAC, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ADVSignedDeviceIdentityHMAC a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un ADVSignedKeyIndexList. */
    interface IADVSignedKeyIndexList {

        /** ADVSignedKeyIndexList details */
        details?: (Uint8Array|null);

        /** ADVSignedKeyIndexList accountSignature */
        accountSignature?: (Uint8Array|null);
    }

    /** Representa un ADVSignedKeyIndexList. */
    class ADVSignedKeyIndexList implements IADVSignedKeyIndexList {

        /**
         * Construya un nuevo ADVSignedKeyIndexList.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IADVSignedKeyIndexList);

        /** ADVSignedKeyIndexList details. */
        public details: Uint8Array;

        /** ADVSignedKeyIndexList accountSignature. */
        public accountSignature: Uint8Array;

        /**
         * Crea una nueva instancia ADVSignedKeyIndexList utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ADVSignedKeyIndexList instance
         */
        public static create(properties?: proto.IADVSignedKeyIndexList): proto.ADVSignedKeyIndexList;

        /**
         * Codifica el mensaje ADVSignedKeyIndexList. No implícitamente mensajes {@link proto.ADVSignedKeyIndexList.verify|verify}.
         * @param message ADVSignedKeyIndexList mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IADVSignedKeyIndexList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ADVSignedKeyIndexList message, delimitado por longitud. No implícitamente mensajes {@link proto.ADVSignedKeyIndexList.verify|verify}.
         * @param message ADVSignedKeyIndexList mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IADVSignedKeyIndexList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ADVSignedKeyIndexList message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ADVSignedKeyIndexList
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ADVSignedKeyIndexList;

        /**
         * Decodes a ADVSignedKeyIndexList message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ADVSignedKeyIndexList
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ADVSignedKeyIndexList;

        /**
         * Verifies a ADVSignedKeyIndexList message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ADVSignedKeyIndexList message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ADVSignedKeyIndexList
         */
        public static fromObject(object: { [k: string]: any }): proto.ADVSignedKeyIndexList;

        /**
         * Crea un objeto simple desde ADVSignedKeyIndexList. También convierte valores a otros tipos si se especifica.
         * @param message ADVSignedKeyIndexList
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ADVSignedKeyIndexList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ADVSignedKeyIndexList a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn ActionLink. */
    interface IActionLink {

        /** ActionLink url */
        url?: (string|null);

        /** ActionLink buttonTitle */
        buttonTitle?: (string|null);
    }

    /** Representa unn ActionLink. */
    class ActionLink implements IActionLink {

        /**
         * Construya un nuevo ActionLink.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IActionLink);

        /** ActionLink url. */
        public url: string;

        /** ActionLink buttonTitle. */
        public buttonTitle: string;

        /**
         * Crea una nueva instancia ActionLink utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ActionLink instance
         */
        public static create(properties?: proto.IActionLink): proto.ActionLink;

        /**
         * Codifica el mensaje ActionLink. No implícitamente mensajes {@link proto.ActionLink.verify|verify}.
         * @param message ActionLink mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IActionLink, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ActionLink message, delimitado por longitud. No implícitamente mensajes {@link proto.ActionLink.verify|verify}.
         * @param message ActionLink mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IActionLink, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an ActionLink message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ActionLink
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ActionLink;

        /**
         * Decodes an ActionLink message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ActionLink
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ActionLink;

        /**
         * Verifies an ActionLink message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an ActionLink message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ActionLink
         */
        public static fromObject(object: { [k: string]: any }): proto.ActionLink;

        /**
         * Crea un objeto simple desden ActionLink. También convierte valores a otros tipos si se especifica.
         * @param message ActionLink
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ActionLink, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ActionLink a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn AutoDownloadSettings. */
    interface IAutoDownloadSettings {

        /** AutoDownloadSettings downloadImages */
        downloadImages?: (boolean|null);

        /** AutoDownloadSettings downloadAudio */
        downloadAudio?: (boolean|null);

        /** AutoDownloadSettings downloadVideo */
        downloadVideo?: (boolean|null);

        /** AutoDownloadSettings downloadDocuments */
        downloadDocuments?: (boolean|null);
    }

    /** Representa unn AutoDownloadSettings. */
    class AutoDownloadSettings implements IAutoDownloadSettings {

        /**
         * Construya un nuevo AutoDownloadSettings.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IAutoDownloadSettings);

        /** AutoDownloadSettings downloadImages. */
        public downloadImages: boolean;

        /** AutoDownloadSettings downloadAudio. */
        public downloadAudio: boolean;

        /** AutoDownloadSettings downloadVideo. */
        public downloadVideo: boolean;

        /** AutoDownloadSettings downloadDocuments. */
        public downloadDocuments: boolean;

        /**
         * Crea una nueva instancia AutoDownloadSettings utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns AutoDownloadSettings instance
         */
        public static create(properties?: proto.IAutoDownloadSettings): proto.AutoDownloadSettings;

        /**
         * Codifica el mensaje AutoDownloadSettings. No implícitamente mensajes {@link proto.AutoDownloadSettings.verify|verify}.
         * @param message AutoDownloadSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IAutoDownloadSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje AutoDownloadSettings message, delimitado por longitud. No implícitamente mensajes {@link proto.AutoDownloadSettings.verify|verify}.
         * @param message AutoDownloadSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAutoDownloadSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AutoDownloadSettings message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns AutoDownloadSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AutoDownloadSettings;

        /**
         * Decodes an AutoDownloadSettings message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns AutoDownloadSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AutoDownloadSettings;

        /**
         * Verifies an AutoDownloadSettings message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AutoDownloadSettings message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns AutoDownloadSettings
         */
        public static fromObject(object: { [k: string]: any }): proto.AutoDownloadSettings;

        /**
         * Crea un objeto simple desden AutoDownloadSettings. También convierte valores a otros tipos si se especifica.
         * @param message AutoDownloadSettings
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.AutoDownloadSettings, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  AutoDownloadSettings a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn AvatarUserSettings. */
    interface IAvatarUserSettings {

        /** AvatarUserSettings fbid */
        fbid?: (string|null);

        /** AvatarUserSettings password */
        password?: (string|null);
    }

    /** Representa unn AvatarUserSettings. */
    class AvatarUserSettings implements IAvatarUserSettings {

        /**
         * Construya un nuevo AvatarUserSettings.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IAvatarUserSettings);

        /** AvatarUserSettings fbid. */
        public fbid: string;

        /** AvatarUserSettings password. */
        public password: string;

        /**
         * Crea una nueva instancia AvatarUserSettings utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns AvatarUserSettings instance
         */
        public static create(properties?: proto.IAvatarUserSettings): proto.AvatarUserSettings;

        /**
         * Codifica el mensaje AvatarUserSettings. No implícitamente mensajes {@link proto.AvatarUserSettings.verify|verify}.
         * @param message AvatarUserSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IAvatarUserSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje AvatarUserSettings message, delimitado por longitud. No implícitamente mensajes {@link proto.AvatarUserSettings.verify|verify}.
         * @param message AvatarUserSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAvatarUserSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AvatarUserSettings message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns AvatarUserSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AvatarUserSettings;

        /**
         * Decodes an AvatarUserSettings message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns AvatarUserSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AvatarUserSettings;

        /**
         * Verifies an AvatarUserSettings message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AvatarUserSettings message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns AvatarUserSettings
         */
        public static fromObject(object: { [k: string]: any }): proto.AvatarUserSettings;

        /**
         * Crea un objeto simple desden AvatarUserSettings. También convierte valores a otros tipos si se especifica.
         * @param message AvatarUserSettings
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.AvatarUserSettings, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  AvatarUserSettings a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un BizAccountLinkInfo. */
    interface IBizAccountLinkInfo {

        /** BizAccountLinkInfo whatsappBizAcctFbid */
        whatsappBizAcctFbid?: (number|Long|null);

        /** BizAccountLinkInfo whatsappAcctNumber */
        whatsappAcctNumber?: (string|null);

        /** BizAccountLinkInfo issueTime */
        issueTime?: (number|Long|null);

        /** BizAccountLinkInfo hostStorage */
        hostStorage?: (proto.BizAccountLinkInfo.HostStorageType|null);

        /** BizAccountLinkInfo accountType */
        accountType?: (proto.BizAccountLinkInfo.AccountType|null);
    }

    /** Representa un BizAccountLinkInfo. */
    class BizAccountLinkInfo implements IBizAccountLinkInfo {

        /**
         * Construya un nuevo BizAccountLinkInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IBizAccountLinkInfo);

        /** BizAccountLinkInfo whatsappBizAcctFbid. */
        public whatsappBizAcctFbid: (number|Long);

        /** BizAccountLinkInfo whatsappAcctNumber. */
        public whatsappAcctNumber: string;

        /** BizAccountLinkInfo issueTime. */
        public issueTime: (number|Long);

        /** BizAccountLinkInfo hostStorage. */
        public hostStorage: proto.BizAccountLinkInfo.HostStorageType;

        /** BizAccountLinkInfo accountType. */
        public accountType: proto.BizAccountLinkInfo.AccountType;

        /**
         * Crea una nueva instancia BizAccountLinkInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns BizAccountLinkInfo instance
         */
        public static create(properties?: proto.IBizAccountLinkInfo): proto.BizAccountLinkInfo;

        /**
         * Codifica el mensaje BizAccountLinkInfo. No implícitamente mensajes {@link proto.BizAccountLinkInfo.verify|verify}.
         * @param message BizAccountLinkInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IBizAccountLinkInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje BizAccountLinkInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.BizAccountLinkInfo.verify|verify}.
         * @param message BizAccountLinkInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IBizAccountLinkInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a BizAccountLinkInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns BizAccountLinkInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.BizAccountLinkInfo;

        /**
         * Decodes a BizAccountLinkInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns BizAccountLinkInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.BizAccountLinkInfo;

        /**
         * Verifies a BizAccountLinkInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a BizAccountLinkInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns BizAccountLinkInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.BizAccountLinkInfo;

        /**
         * Crea un objeto simple desde BizAccountLinkInfo. También convierte valores a otros tipos si se especifica.
         * @param message BizAccountLinkInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.BizAccountLinkInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  BizAccountLinkInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace BizAccountLinkInfo {

        /** AccountType enum. */
        enum AccountType {
            ENTERPRISE = 0
        }

        /** HostStorageType enum. */
        enum HostStorageType {
            ON_PREMISE = 0,
            FACEBOOK = 1
        }
    }

    /** Propiedades de un BizAccountPayload. */
    interface IBizAccountPayload {

        /** BizAccountPayload vnameCert */
        vnameCert?: (proto.IVerifiedNameCertificate|null);

        /** BizAccountPayload bizAcctLinkInfo */
        bizAcctLinkInfo?: (Uint8Array|null);
    }

    /** Representa un BizAccountPayload. */
    class BizAccountPayload implements IBizAccountPayload {

        /**
         * Construya un nuevo BizAccountPayload.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IBizAccountPayload);

        /** BizAccountPayload vnameCert. */
        public vnameCert?: (proto.IVerifiedNameCertificate|null);

        /** BizAccountPayload bizAcctLinkInfo. */
        public bizAcctLinkInfo: Uint8Array;

        /**
         * Crea una nueva instancia BizAccountPayload utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns BizAccountPayload instance
         */
        public static create(properties?: proto.IBizAccountPayload): proto.BizAccountPayload;

        /**
         * Codifica el mensaje BizAccountPayload. No implícitamente mensajes {@link proto.BizAccountPayload.verify|verify}.
         * @param message BizAccountPayload mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IBizAccountPayload, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje BizAccountPayload message, delimitado por longitud. No implícitamente mensajes {@link proto.BizAccountPayload.verify|verify}.
         * @param message BizAccountPayload mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IBizAccountPayload, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a BizAccountPayload message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns BizAccountPayload
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.BizAccountPayload;

        /**
         * Decodes a BizAccountPayload message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns BizAccountPayload
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.BizAccountPayload;

        /**
         * Verifies a BizAccountPayload message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a BizAccountPayload message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns BizAccountPayload
         */
        public static fromObject(object: { [k: string]: any }): proto.BizAccountPayload;

        /**
         * Crea un objeto simple desde BizAccountPayload. También convierte valores a otros tipos si se especifica.
         * @param message BizAccountPayload
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.BizAccountPayload, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  BizAccountPayload a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un BizIdentityInfo. */
    interface IBizIdentityInfo {

        /** BizIdentityInfo vlevel */
        vlevel?: (proto.BizIdentityInfo.VerifiedLevelValue|null);

        /** BizIdentityInfo vnameCert */
        vnameCert?: (proto.IVerifiedNameCertificate|null);

        /** BizIdentityInfo signed */
        signed?: (boolean|null);

        /** BizIdentityInfo revoked */
        revoked?: (boolean|null);

        /** BizIdentityInfo hostStorage */
        hostStorage?: (proto.BizIdentityInfo.HostStorageType|null);

        /** BizIdentityInfo actualActors */
        actualActors?: (proto.BizIdentityInfo.ActualActorsType|null);

        /** BizIdentityInfo privacyModeTs */
        privacyModeTs?: (number|Long|null);

        /** BizIdentityInfo featureControls */
        featureControls?: (number|Long|null);
    }

    /** Representa un BizIdentityInfo. */
    class BizIdentityInfo implements IBizIdentityInfo {

        /**
         * Construya un nuevo BizIdentityInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IBizIdentityInfo);

        /** BizIdentityInfo vlevel. */
        public vlevel: proto.BizIdentityInfo.VerifiedLevelValue;

        /** BizIdentityInfo vnameCert. */
        public vnameCert?: (proto.IVerifiedNameCertificate|null);

        /** BizIdentityInfo signed. */
        public signed: boolean;

        /** BizIdentityInfo revoked. */
        public revoked: boolean;

        /** BizIdentityInfo hostStorage. */
        public hostStorage: proto.BizIdentityInfo.HostStorageType;

        /** BizIdentityInfo actualActors. */
        public actualActors: proto.BizIdentityInfo.ActualActorsType;

        /** BizIdentityInfo privacyModeTs. */
        public privacyModeTs: (number|Long);

        /** BizIdentityInfo featureControls. */
        public featureControls: (number|Long);

        /**
         * Crea una nueva instancia BizIdentityInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns BizIdentityInfo instance
         */
        public static create(properties?: proto.IBizIdentityInfo): proto.BizIdentityInfo;

        /**
         * Codifica el mensaje BizIdentityInfo. No implícitamente mensajes {@link proto.BizIdentityInfo.verify|verify}.
         * @param message BizIdentityInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IBizIdentityInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje BizIdentityInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.BizIdentityInfo.verify|verify}.
         * @param message BizIdentityInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IBizIdentityInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a BizIdentityInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns BizIdentityInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.BizIdentityInfo;

        /**
         * Decodes a BizIdentityInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns BizIdentityInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.BizIdentityInfo;

        /**
         * Verifies a BizIdentityInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a BizIdentityInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns BizIdentityInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.BizIdentityInfo;

        /**
         * Crea un objeto simple desde BizIdentityInfo. También convierte valores a otros tipos si se especifica.
         * @param message BizIdentityInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.BizIdentityInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  BizIdentityInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace BizIdentityInfo {

        /** ActualActorsType enum. */
        enum ActualActorsType {
            SELF = 0,
            BSP = 1
        }

        /** HostStorageType enum. */
        enum HostStorageType {
            ON_PREMISE = 0,
            FACEBOOK = 1
        }

        /** VerifiedLevelValue enum. */
        enum VerifiedLevelValue {
            UNKNOWN = 0,
            LOW = 1,
            HIGH = 2
        }
    }

    /** Propiedades de un CertChain. */
    interface ICertChain {

        /** CertChain leaf */
        leaf?: (proto.CertChain.INoiseCertificate|null);

        /** CertChain intermediate */
        intermediate?: (proto.CertChain.INoiseCertificate|null);
    }

    /** Representa un CertChain. */
    class CertChain implements ICertChain {

        /**
         * Construya un nuevo CertChain.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ICertChain);

        /** CertChain leaf. */
        public leaf?: (proto.CertChain.INoiseCertificate|null);

        /** CertChain intermediate. */
        public intermediate?: (proto.CertChain.INoiseCertificate|null);

        /**
         * Crea una nueva instancia CertChain utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns CertChain instance
         */
        public static create(properties?: proto.ICertChain): proto.CertChain;

        /**
         * Codifica el mensaje CertChain. No implícitamente mensajes {@link proto.CertChain.verify|verify}.
         * @param message CertChain mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ICertChain, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje CertChain message, delimitado por longitud. No implícitamente mensajes {@link proto.CertChain.verify|verify}.
         * @param message CertChain mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ICertChain, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a CertChain message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns CertChain
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CertChain;

        /**
         * Decodes a CertChain message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns CertChain
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CertChain;

        /**
         * Verifies a CertChain message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a CertChain message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns CertChain
         */
        public static fromObject(object: { [k: string]: any }): proto.CertChain;

        /**
         * Crea un objeto simple desde CertChain. También convierte valores a otros tipos si se especifica.
         * @param message CertChain
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.CertChain, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  CertChain a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace CertChain {

        /** Propiedades de un NoiseCertificate. */
        interface INoiseCertificate {

            /** NoiseCertificate details */
            details?: (Uint8Array|null);

            /** NoiseCertificate signature */
            signature?: (Uint8Array|null);
        }

        /** Representa un NoiseCertificate. */
        class NoiseCertificate implements INoiseCertificate {

            /**
             * Construya un nuevo NoiseCertificate.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.CertChain.INoiseCertificate);

            /** NoiseCertificate details. */
            public details: Uint8Array;

            /** NoiseCertificate signature. */
            public signature: Uint8Array;

            /**
             * Crea una nueva instancia NoiseCertificate utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns NoiseCertificate instance
             */
            public static create(properties?: proto.CertChain.INoiseCertificate): proto.CertChain.NoiseCertificate;

            /**
             * Codifica el mensaje NoiseCertificate. No implícitamente mensajes {@link proto.CertChain.NoiseCertificate.verify|verify}.
             * @param message NoiseCertificate mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.CertChain.INoiseCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje NoiseCertificate message, delimitado por longitud. No implícitamente mensajes {@link proto.CertChain.NoiseCertificate.verify|verify}.
             * @param message NoiseCertificate mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.CertChain.INoiseCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NoiseCertificate message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns NoiseCertificate
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CertChain.NoiseCertificate;

            /**
             * Decodes a NoiseCertificate message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns NoiseCertificate
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CertChain.NoiseCertificate;

            /**
             * Verifies a NoiseCertificate message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a NoiseCertificate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns NoiseCertificate
             */
            public static fromObject(object: { [k: string]: any }): proto.CertChain.NoiseCertificate;

            /**
             * Crea un objeto simple desde NoiseCertificate. También convierte valores a otros tipos si se especifica.
             * @param message NoiseCertificate
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.CertChain.NoiseCertificate, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  NoiseCertificate a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace NoiseCertificate {

            /** Propiedades de un Details. */
            interface IDetails {

                /** Details serial */
                serial?: (number|null);

                /** Details issuerSerial */
                issuerSerial?: (number|null);

                /** Details key */
                key?: (Uint8Array|null);

                /** Details notBefore */
                notBefore?: (number|Long|null);

                /** Details notAfter */
                notAfter?: (number|Long|null);
            }

            /** Representa un Details. */
            class Details implements IDetails {

                /**
                 * Construya un nuevo Details.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.CertChain.NoiseCertificate.IDetails);

                /** Details serial. */
                public serial: number;

                /** Details issuerSerial. */
                public issuerSerial: number;

                /** Details key. */
                public key: Uint8Array;

                /** Details notBefore. */
                public notBefore: (number|Long);

                /** Details notAfter. */
                public notAfter: (number|Long);

                /**
                 * Crea una nueva instancia Details utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Details instance
                 */
                public static create(properties?: proto.CertChain.NoiseCertificate.IDetails): proto.CertChain.NoiseCertificate.Details;

                /**
                 * Codifica el mensaje Details. No implícitamente mensajes {@link proto.CertChain.NoiseCertificate.Details.verify|verify}.
                 * @param message Details mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.CertChain.NoiseCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Details message, delimitado por longitud. No implícitamente mensajes {@link proto.CertChain.NoiseCertificate.Details.verify|verify}.
                 * @param message Details mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.CertChain.NoiseCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Details message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Details
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CertChain.NoiseCertificate.Details;

                /**
                 * Decodes a Details message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Details
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CertChain.NoiseCertificate.Details;

                /**
                 * Verifies a Details message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Details message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Details
                 */
                public static fromObject(object: { [k: string]: any }): proto.CertChain.NoiseCertificate.Details;

                /**
                 * Crea un objeto simple desde Details. También convierte valores a otros tipos si se especifica.
                 * @param message Details
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.CertChain.NoiseCertificate.Details, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Details a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Propiedades de un ClientPayload. */
    interface IClientPayload {

        /** ClientPayload username */
        username?: (number|Long|null);

        /** ClientPayload passive */
        passive?: (boolean|null);

        /** ClientPayload userAgent */
        userAgent?: (proto.ClientPayload.IUserAgent|null);

        /** ClientPayload webInfo */
        webInfo?: (proto.ClientPayload.IWebInfo|null);

        /** ClientPayload pushName */
        pushName?: (string|null);

        /** ClientPayload sessionId */
        sessionId?: (number|null);

        /** ClientPayload shortConnect */
        shortConnect?: (boolean|null);

        /** ClientPayload connectType */
        connectType?: (proto.ClientPayload.ConnectType|null);

        /** ClientPayload connectReason */
        connectReason?: (proto.ClientPayload.ConnectReason|null);

        /** ClientPayload shards */
        shards?: (number[]|null);

        /** ClientPayload dnsSource */
        dnsSource?: (proto.ClientPayload.IDNSSource|null);

        /** ClientPayload connectAttemptCount */
        connectAttemptCount?: (number|null);

        /** ClientPayload device */
        device?: (number|null);

        /** ClientPayload devicePairingData */
        devicePairingData?: (proto.ClientPayload.IDevicePairingRegistrationData|null);

        /** ClientPayload product */
        product?: (proto.ClientPayload.Product|null);

        /** ClientPayload fbCat */
        fbCat?: (Uint8Array|null);

        /** ClientPayload fbUserAgent */
        fbUserAgent?: (Uint8Array|null);

        /** ClientPayload oc */
        oc?: (boolean|null);

        /** ClientPayload lc */
        lc?: (number|null);

        /** ClientPayload iosAppExtension */
        iosAppExtension?: (proto.ClientPayload.IOSAppExtension|null);

        /** ClientPayload fbAppId */
        fbAppId?: (number|Long|null);

        /** ClientPayload fbDeviceId */
        fbDeviceId?: (Uint8Array|null);

        /** ClientPayload pull */
        pull?: (boolean|null);

        /** ClientPayload paddingBytes */
        paddingBytes?: (Uint8Array|null);

        /** ClientPayload yearClass */
        yearClass?: (number|null);

        /** ClientPayload memClass */
        memClass?: (number|null);
    }

    /** Representa un ClientPayload. */
    class ClientPayload implements IClientPayload {

        /**
         * Construya un nuevo ClientPayload.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IClientPayload);

        /** ClientPayload username. */
        public username: (number|Long);

        /** ClientPayload passive. */
        public passive: boolean;

        /** ClientPayload userAgent. */
        public userAgent?: (proto.ClientPayload.IUserAgent|null);

        /** ClientPayload webInfo. */
        public webInfo?: (proto.ClientPayload.IWebInfo|null);

        /** ClientPayload pushName. */
        public pushName: string;

        /** ClientPayload sessionId. */
        public sessionId: number;

        /** ClientPayload shortConnect. */
        public shortConnect: boolean;

        /** ClientPayload connectType. */
        public connectType: proto.ClientPayload.ConnectType;

        /** ClientPayload connectReason. */
        public connectReason: proto.ClientPayload.ConnectReason;

        /** ClientPayload shards. */
        public shards: number[];

        /** ClientPayload dnsSource. */
        public dnsSource?: (proto.ClientPayload.IDNSSource|null);

        /** ClientPayload connectAttemptCount. */
        public connectAttemptCount: number;

        /** ClientPayload device. */
        public device: number;

        /** ClientPayload devicePairingData. */
        public devicePairingData?: (proto.ClientPayload.IDevicePairingRegistrationData|null);

        /** ClientPayload product. */
        public product: proto.ClientPayload.Product;

        /** ClientPayload fbCat. */
        public fbCat: Uint8Array;

        /** ClientPayload fbUserAgent. */
        public fbUserAgent: Uint8Array;

        /** ClientPayload oc. */
        public oc: boolean;

        /** ClientPayload lc. */
        public lc: number;

        /** ClientPayload iosAppExtension. */
        public iosAppExtension: proto.ClientPayload.IOSAppExtension;

        /** ClientPayload fbAppId. */
        public fbAppId: (number|Long);

        /** ClientPayload fbDeviceId. */
        public fbDeviceId: Uint8Array;

        /** ClientPayload pull. */
        public pull: boolean;

        /** ClientPayload paddingBytes. */
        public paddingBytes: Uint8Array;

        /** ClientPayload yearClass. */
        public yearClass: number;

        /** ClientPayload memClass. */
        public memClass: number;

        /**
         * Crea una nueva instancia ClientPayload utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ClientPayload instance
         */
        public static create(properties?: proto.IClientPayload): proto.ClientPayload;

        /**
         * Codifica el mensaje ClientPayload. No implícitamente mensajes {@link proto.ClientPayload.verify|verify}.
         * @param message ClientPayload mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IClientPayload, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ClientPayload message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.verify|verify}.
         * @param message ClientPayload mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IClientPayload, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ClientPayload message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ClientPayload
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload;

        /**
         * Decodes a ClientPayload message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ClientPayload
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload;

        /**
         * Verifies a ClientPayload message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ClientPayload message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ClientPayload
         */
        public static fromObject(object: { [k: string]: any }): proto.ClientPayload;

        /**
         * Crea un objeto simple desde ClientPayload. También convierte valores a otros tipos si se especifica.
         * @param message ClientPayload
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ClientPayload, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ClientPayload a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace ClientPayload {

        /** ConnectReason enum. */
        enum ConnectReason {
            PUSH = 0,
            USER_ACTIVATED = 1,
            SCHEDULED = 2,
            ERROR_RECONNECT = 3,
            NETWORK_SWITCH = 4,
            PING_RECONNECT = 5
        }

        /** ConnectType enum. */
        enum ConnectType {
            CELLULAR_UNKNOWN = 0,
            WIFI_UNKNOWN = 1,
            CELLULAR_EDGE = 100,
            CELLULAR_IDEN = 101,
            CELLULAR_UMTS = 102,
            CELLULAR_EVDO = 103,
            CELLULAR_GPRS = 104,
            CELLULAR_HSDPA = 105,
            CELLULAR_HSUPA = 106,
            CELLULAR_HSPA = 107,
            CELLULAR_CDMA = 108,
            CELLULAR_1XRTT = 109,
            CELLULAR_EHRPD = 110,
            CELLULAR_LTE = 111,
            CELLULAR_HSPAP = 112
        }

        /** Propiedades de un DNSSource. */
        interface IDNSSource {

            /** DNSSource dnsMethod */
            dnsMethod?: (proto.ClientPayload.DNSSource.DNSResolutionMethod|null);

            /** DNSSource appCached */
            appCached?: (boolean|null);
        }

        /** Representa un DNSSource. */
        class DNSSource implements IDNSSource {

            /**
             * Construya un nuevo DNSSource.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ClientPayload.IDNSSource);

            /** DNSSource dnsMethod. */
            public dnsMethod: proto.ClientPayload.DNSSource.DNSResolutionMethod;

            /** DNSSource appCached. */
            public appCached: boolean;

            /**
             * Crea una nueva instancia DNSSource utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DNSSource instance
             */
            public static create(properties?: proto.ClientPayload.IDNSSource): proto.ClientPayload.DNSSource;

            /**
             * Codifica el mensaje DNSSource. No implícitamente mensajes {@link proto.ClientPayload.DNSSource.verify|verify}.
             * @param message DNSSource mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ClientPayload.IDNSSource, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DNSSource message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.DNSSource.verify|verify}.
             * @param message DNSSource mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ClientPayload.IDNSSource, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DNSSource message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DNSSource
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.DNSSource;

            /**
             * Decodes a DNSSource message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DNSSource
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.DNSSource;

            /**
             * Verifies a DNSSource message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DNSSource message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DNSSource
             */
            public static fromObject(object: { [k: string]: any }): proto.ClientPayload.DNSSource;

            /**
             * Crea un objeto simple desde DNSSource. También convierte valores a otros tipos si se especifica.
             * @param message DNSSource
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ClientPayload.DNSSource, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DNSSource a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace DNSSource {

            /** DNSResolutionMethod enum. */
            enum DNSResolutionMethod {
                SYSTEM = 0,
                GOOGLE = 1,
                HARDCODED = 2,
                OVERRIDE = 3,
                FALLBACK = 4
            }
        }

        /** Propiedades de un DevicePairingRegistrationData. */
        interface IDevicePairingRegistrationData {

            /** DevicePairingRegistrationData eRegid */
            eRegid?: (Uint8Array|null);

            /** DevicePairingRegistrationData eKeytype */
            eKeytype?: (Uint8Array|null);

            /** DevicePairingRegistrationData eIdent */
            eIdent?: (Uint8Array|null);

            /** DevicePairingRegistrationData eSkeyId */
            eSkeyId?: (Uint8Array|null);

            /** DevicePairingRegistrationData eSkeyVal */
            eSkeyVal?: (Uint8Array|null);

            /** DevicePairingRegistrationData eSkeySig */
            eSkeySig?: (Uint8Array|null);

            /** DevicePairingRegistrationData buildHash */
            buildHash?: (Uint8Array|null);

            /** DevicePairingRegistrationData deviceProps */
            deviceProps?: (Uint8Array|null);
        }

        /** Representa un DevicePairingRegistrationData. */
        class DevicePairingRegistrationData implements IDevicePairingRegistrationData {

            /**
             * Construya un nuevo DevicePairingRegistrationData.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ClientPayload.IDevicePairingRegistrationData);

            /** DevicePairingRegistrationData eRegid. */
            public eRegid: Uint8Array;

            /** DevicePairingRegistrationData eKeytype. */
            public eKeytype: Uint8Array;

            /** DevicePairingRegistrationData eIdent. */
            public eIdent: Uint8Array;

            /** DevicePairingRegistrationData eSkeyId. */
            public eSkeyId: Uint8Array;

            /** DevicePairingRegistrationData eSkeyVal. */
            public eSkeyVal: Uint8Array;

            /** DevicePairingRegistrationData eSkeySig. */
            public eSkeySig: Uint8Array;

            /** DevicePairingRegistrationData buildHash. */
            public buildHash: Uint8Array;

            /** DevicePairingRegistrationData deviceProps. */
            public deviceProps: Uint8Array;

            /**
             * Crea una nueva instancia DevicePairingRegistrationData utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DevicePairingRegistrationData instance
             */
            public static create(properties?: proto.ClientPayload.IDevicePairingRegistrationData): proto.ClientPayload.DevicePairingRegistrationData;

            /**
             * Codifica el mensaje DevicePairingRegistrationData. No implícitamente mensajes {@link proto.ClientPayload.DevicePairingRegistrationData.verify|verify}.
             * @param message DevicePairingRegistrationData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ClientPayload.IDevicePairingRegistrationData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DevicePairingRegistrationData message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.DevicePairingRegistrationData.verify|verify}.
             * @param message DevicePairingRegistrationData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ClientPayload.IDevicePairingRegistrationData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DevicePairingRegistrationData message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DevicePairingRegistrationData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.DevicePairingRegistrationData;

            /**
             * Decodes a DevicePairingRegistrationData message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DevicePairingRegistrationData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.DevicePairingRegistrationData;

            /**
             * Verifies a DevicePairingRegistrationData message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DevicePairingRegistrationData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DevicePairingRegistrationData
             */
            public static fromObject(object: { [k: string]: any }): proto.ClientPayload.DevicePairingRegistrationData;

            /**
             * Crea un objeto simple desde DevicePairingRegistrationData. También convierte valores a otros tipos si se especifica.
             * @param message DevicePairingRegistrationData
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ClientPayload.DevicePairingRegistrationData, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DevicePairingRegistrationData a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** IOSAppExtension enum. */
        enum IOSAppExtension {
            SHARE_EXTENSION = 0,
            SERVICE_EXTENSION = 1,
            INTENTS_EXTENSION = 2
        }

        /** Product enum. */
        enum Product {
            WHATSAPP = 0,
            MESSENGER = 1
        }

        /** Propiedades de un UserAgent. */
        interface IUserAgent {

            /** UserAgent platform */
            platform?: (proto.ClientPayload.UserAgent.Platform|null);

            /** UserAgent appVersion */
            appVersion?: (proto.ClientPayload.UserAgent.IAppVersion|null);

            /** UserAgent mcc */
            mcc?: (string|null);

            /** UserAgent mnc */
            mnc?: (string|null);

            /** UserAgent osVersion */
            osVersion?: (string|null);

            /** UserAgent manufacturer */
            manufacturer?: (string|null);

            /** UserAgent device */
            device?: (string|null);

            /** UserAgent osBuildNumber */
            osBuildNumber?: (string|null);

            /** UserAgent phoneId */
            phoneId?: (string|null);

            /** UserAgent releaseChannel */
            releaseChannel?: (proto.ClientPayload.UserAgent.ReleaseChannel|null);

            /** UserAgent localeLanguageIso6391 */
            localeLanguageIso6391?: (string|null);

            /** UserAgent localeCountryIso31661Alpha2 */
            localeCountryIso31661Alpha2?: (string|null);

            /** UserAgent deviceBoard */
            deviceBoard?: (string|null);
        }

        /** Representa un UserAgent. */
        class UserAgent implements IUserAgent {

            /**
             * Construya un nuevo UserAgent.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ClientPayload.IUserAgent);

            /** UserAgent platform. */
            public platform: proto.ClientPayload.UserAgent.Platform;

            /** UserAgent appVersion. */
            public appVersion?: (proto.ClientPayload.UserAgent.IAppVersion|null);

            /** UserAgent mcc. */
            public mcc: string;

            /** UserAgent mnc. */
            public mnc: string;

            /** UserAgent osVersion. */
            public osVersion: string;

            /** UserAgent manufacturer. */
            public manufacturer: string;

            /** UserAgent device. */
            public device: string;

            /** UserAgent osBuildNumber. */
            public osBuildNumber: string;

            /** UserAgent phoneId. */
            public phoneId: string;

            /** UserAgent releaseChannel. */
            public releaseChannel: proto.ClientPayload.UserAgent.ReleaseChannel;

            /** UserAgent localeLanguageIso6391. */
            public localeLanguageIso6391: string;

            /** UserAgent localeCountryIso31661Alpha2. */
            public localeCountryIso31661Alpha2: string;

            /** UserAgent deviceBoard. */
            public deviceBoard: string;

            /**
             * Crea una nueva instancia UserAgent utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns UserAgent instance
             */
            public static create(properties?: proto.ClientPayload.IUserAgent): proto.ClientPayload.UserAgent;

            /**
             * Codifica el mensaje UserAgent. No implícitamente mensajes {@link proto.ClientPayload.UserAgent.verify|verify}.
             * @param message UserAgent mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ClientPayload.IUserAgent, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje UserAgent message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.UserAgent.verify|verify}.
             * @param message UserAgent mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ClientPayload.IUserAgent, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a UserAgent message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns UserAgent
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.UserAgent;

            /**
             * Decodes a UserAgent message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns UserAgent
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.UserAgent;

            /**
             * Verifies a UserAgent message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a UserAgent message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns UserAgent
             */
            public static fromObject(object: { [k: string]: any }): proto.ClientPayload.UserAgent;

            /**
             * Crea un objeto simple desde UserAgent. También convierte valores a otros tipos si se especifica.
             * @param message UserAgent
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ClientPayload.UserAgent, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  UserAgent a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace UserAgent {

            /** Propiedades de unn AppVersion. */
            interface IAppVersion {

                /** AppVersion primary */
                primary?: (number|null);

                /** AppVersion secondary */
                secondary?: (number|null);

                /** AppVersion tertiary */
                tertiary?: (number|null);

                /** AppVersion quaternary */
                quaternary?: (number|null);

                /** AppVersion quinary */
                quinary?: (number|null);
            }

            /** Representa unn AppVersion. */
            class AppVersion implements IAppVersion {

                /**
                 * Construya un nuevo AppVersion.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.ClientPayload.UserAgent.IAppVersion);

                /** AppVersion primary. */
                public primary: number;

                /** AppVersion secondary. */
                public secondary: number;

                /** AppVersion tertiary. */
                public tertiary: number;

                /** AppVersion quaternary. */
                public quaternary: number;

                /** AppVersion quinary. */
                public quinary: number;

                /**
                 * Crea una nueva instancia AppVersion utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns AppVersion instance
                 */
                public static create(properties?: proto.ClientPayload.UserAgent.IAppVersion): proto.ClientPayload.UserAgent.AppVersion;

                /**
                 * Codifica el mensaje AppVersion. No implícitamente mensajes {@link proto.ClientPayload.UserAgent.AppVersion.verify|verify}.
                 * @param message AppVersion mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.ClientPayload.UserAgent.IAppVersion, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje AppVersion message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.UserAgent.AppVersion.verify|verify}.
                 * @param message AppVersion mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.ClientPayload.UserAgent.IAppVersion, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AppVersion message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns AppVersion
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.UserAgent.AppVersion;

                /**
                 * Decodes an AppVersion message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns AppVersion
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.UserAgent.AppVersion;

                /**
                 * Verifies an AppVersion message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AppVersion message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns AppVersion
                 */
                public static fromObject(object: { [k: string]: any }): proto.ClientPayload.UserAgent.AppVersion;

                /**
                 * Crea un objeto simple desden AppVersion. También convierte valores a otros tipos si se especifica.
                 * @param message AppVersion
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.ClientPayload.UserAgent.AppVersion, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  AppVersion a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Platform enum. */
            enum Platform {
                ANDROID = 0,
                IOS = 1,
                WINDOWS_PHONE = 2,
                BLACKBERRY = 3,
                BLACKBERRYX = 4,
                S40 = 5,
                S60 = 6,
                PYTHON_CLIENT = 7,
                TIZEN = 8,
                ENTERPRISE = 9,
                SMB_ANDROID = 10,
                KAIOS = 11,
                SMB_IOS = 12,
                WINDOWS = 13,
                WEB = 14,
                PORTAL = 15,
                GREEN_ANDROID = 16,
                GREEN_IPHONE = 17,
                BLUE_ANDROID = 18,
                BLUE_IPHONE = 19,
                FBLITE_ANDROID = 20,
                MLITE_ANDROID = 21,
                IGLITE_ANDROID = 22,
                PAGE = 23,
                MACOS = 24,
                OCULUS_MSG = 25,
                OCULUS_CALL = 26,
                MILAN = 27,
                CAPI = 28,
                WEAROS = 29,
                ARDEVICE = 30,
                VRDEVICE = 31,
                BLUE_WEB = 32
            }

            /** ReleaseChannel enum. */
            enum ReleaseChannel {
                RELEASE = 0,
                BETA = 1,
                ALPHA = 2,
                DEBUG = 3
            }
        }

        /** Propiedades de un WebInfo. */
        interface IWebInfo {

            /** WebInfo refToken */
            refToken?: (string|null);

            /** WebInfo version */
            version?: (string|null);

            /** WebInfo webdPayload */
            webdPayload?: (proto.ClientPayload.WebInfo.IWebdPayload|null);

            /** WebInfo webSubPlatform */
            webSubPlatform?: (proto.ClientPayload.WebInfo.WebSubPlatform|null);
        }

        /** Representa un WebInfo. */
        class WebInfo implements IWebInfo {

            /**
             * Construya un nuevo WebInfo.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ClientPayload.IWebInfo);

            /** WebInfo refToken. */
            public refToken: string;

            /** WebInfo version. */
            public version: string;

            /** WebInfo webdPayload. */
            public webdPayload?: (proto.ClientPayload.WebInfo.IWebdPayload|null);

            /** WebInfo webSubPlatform. */
            public webSubPlatform: proto.ClientPayload.WebInfo.WebSubPlatform;

            /**
             * Crea una nueva instancia WebInfo utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns WebInfo instance
             */
            public static create(properties?: proto.ClientPayload.IWebInfo): proto.ClientPayload.WebInfo;

            /**
             * Codifica el mensaje WebInfo. No implícitamente mensajes {@link proto.ClientPayload.WebInfo.verify|verify}.
             * @param message WebInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ClientPayload.IWebInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje WebInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.WebInfo.verify|verify}.
             * @param message WebInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ClientPayload.IWebInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WebInfo message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns WebInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.WebInfo;

            /**
             * Decodes a WebInfo message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns WebInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.WebInfo;

            /**
             * Verifies a WebInfo message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a WebInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns WebInfo
             */
            public static fromObject(object: { [k: string]: any }): proto.ClientPayload.WebInfo;

            /**
             * Crea un objeto simple desde WebInfo. También convierte valores a otros tipos si se especifica.
             * @param message WebInfo
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ClientPayload.WebInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  WebInfo a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace WebInfo {

            /** WebSubPlatform enum. */
            enum WebSubPlatform {
                WEB_BROWSER = 0,
                APP_STORE = 1,
                WIN_STORE = 2,
                DARWIN = 3,
                WIN32 = 4
            }

            /** Propiedades de un WebdPayload. */
            interface IWebdPayload {

                /** WebdPayload usesParticipantInKey */
                usesParticipantInKey?: (boolean|null);

                /** WebdPayload supportsStarredMessages */
                supportsStarredMessages?: (boolean|null);

                /** WebdPayload supportsDocumentMessages */
                supportsDocumentMessages?: (boolean|null);

                /** WebdPayload supportsUrlMessages */
                supportsUrlMessages?: (boolean|null);

                /** WebdPayload supportsMediaRetry */
                supportsMediaRetry?: (boolean|null);

                /** WebdPayload supportsE2EImage */
                supportsE2EImage?: (boolean|null);

                /** WebdPayload supportsE2EVideo */
                supportsE2EVideo?: (boolean|null);

                /** WebdPayload supportsE2EAudio */
                supportsE2EAudio?: (boolean|null);

                /** WebdPayload supportsE2EDocument */
                supportsE2EDocument?: (boolean|null);

                /** WebdPayload documentTypes */
                documentTypes?: (string|null);

                /** WebdPayload features */
                features?: (Uint8Array|null);
            }

            /** Representa un WebdPayload. */
            class WebdPayload implements IWebdPayload {

                /**
                 * Construya un nuevo WebdPayload.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.ClientPayload.WebInfo.IWebdPayload);

                /** WebdPayload usesParticipantInKey. */
                public usesParticipantInKey: boolean;

                /** WebdPayload supportsStarredMessages. */
                public supportsStarredMessages: boolean;

                /** WebdPayload supportsDocumentMessages. */
                public supportsDocumentMessages: boolean;

                /** WebdPayload supportsUrlMessages. */
                public supportsUrlMessages: boolean;

                /** WebdPayload supportsMediaRetry. */
                public supportsMediaRetry: boolean;

                /** WebdPayload supportsE2EImage. */
                public supportsE2EImage: boolean;

                /** WebdPayload supportsE2EVideo. */
                public supportsE2EVideo: boolean;

                /** WebdPayload supportsE2EAudio. */
                public supportsE2EAudio: boolean;

                /** WebdPayload supportsE2EDocument. */
                public supportsE2EDocument: boolean;

                /** WebdPayload documentTypes. */
                public documentTypes: string;

                /** WebdPayload features. */
                public features: Uint8Array;

                /**
                 * Crea una nueva instancia WebdPayload utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns WebdPayload instance
                 */
                public static create(properties?: proto.ClientPayload.WebInfo.IWebdPayload): proto.ClientPayload.WebInfo.WebdPayload;

                /**
                 * Codifica el mensaje WebdPayload. No implícitamente mensajes {@link proto.ClientPayload.WebInfo.WebdPayload.verify|verify}.
                 * @param message WebdPayload mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.ClientPayload.WebInfo.IWebdPayload, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje WebdPayload message, delimitado por longitud. No implícitamente mensajes {@link proto.ClientPayload.WebInfo.WebdPayload.verify|verify}.
                 * @param message WebdPayload mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.ClientPayload.WebInfo.IWebdPayload, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WebdPayload message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns WebdPayload
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ClientPayload.WebInfo.WebdPayload;

                /**
                 * Decodes a WebdPayload message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns WebdPayload
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ClientPayload.WebInfo.WebdPayload;

                /**
                 * Verifies a WebdPayload message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WebdPayload message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns WebdPayload
                 */
                public static fromObject(object: { [k: string]: any }): proto.ClientPayload.WebInfo.WebdPayload;

                /**
                 * Crea un objeto simple desde WebdPayload. También convierte valores a otros tipos si se especifica.
                 * @param message WebdPayload
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.ClientPayload.WebInfo.WebdPayload, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  WebdPayload a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Propiedades de un ContextInfo. */
    interface IContextInfo {

        /** ContextInfo stanzaId */
        stanzaId?: (string|null);

        /** ContextInfo participant */
        participant?: (string|null);

        /** ContextInfo quotedMessage */
        quotedMessage?: (proto.IMessage|null);

        /** ContextInfo remoteJid */
        remoteJid?: (string|null);

        /** ContextInfo mentionedJid */
        mentionedJid?: (string[]|null);

        /** ContextInfo conversionSource */
        conversionSource?: (string|null);

        /** ContextInfo conversionData */
        conversionData?: (Uint8Array|null);

        /** ContextInfo conversionDelaySeconds */
        conversionDelaySeconds?: (number|null);

        /** ContextInfo forwardingScore */
        forwardingScore?: (number|null);

        /** ContextInfo isForwarded */
        isForwarded?: (boolean|null);

        /** ContextInfo quotedAd */
        quotedAd?: (proto.ContextInfo.IAdReplyInfo|null);

        /** ContextInfo placeholderKey */
        placeholderKey?: (proto.IMessageKey|null);

        /** ContextInfo expiration */
        expiration?: (number|null);

        /** ContextInfo ephemeralSettingTimestamp */
        ephemeralSettingTimestamp?: (number|Long|null);

        /** ContextInfo ephemeralSharedSecret */
        ephemeralSharedSecret?: (Uint8Array|null);

        /** ContextInfo externalAdReply */
        externalAdReply?: (proto.ContextInfo.IExternalAdReplyInfo|null);

        /** ContextInfo entryPointConversionSource */
        entryPointConversionSource?: (string|null);

        /** ContextInfo entryPointConversionApp */
        entryPointConversionApp?: (string|null);

        /** ContextInfo entryPointConversionDelaySeconds */
        entryPointConversionDelaySeconds?: (number|null);

        /** ContextInfo disappearingMode */
        disappearingMode?: (proto.IDisappearingMode|null);

        /** ContextInfo actionLink */
        actionLink?: (proto.IActionLink|null);

        /** ContextInfo groupSubject */
        groupSubject?: (string|null);

        /** ContextInfo parentGroupJid */
        parentGroupJid?: (string|null);

        /** ContextInfo trustBannerType */
        trustBannerType?: (string|null);

        /** ContextInfo trustBannerAction */
        trustBannerAction?: (number|null);

        /** ContextInfo isSampled */
        isSampled?: (boolean|null);

        /** ContextInfo groupMentions */
        groupMentions?: (proto.IGroupMention[]|null);

        /** ContextInfo utm */
        utm?: (proto.ContextInfo.IUTMInfo|null);
    }

    /** Representa un ContextInfo. */
    class ContextInfo implements IContextInfo {

        /**
         * Construya un nuevo ContextInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IContextInfo);

        /** ContextInfo stanzaId. */
        public stanzaId: string;

        /** ContextInfo participant. */
        public participant: string;

        /** ContextInfo quotedMessage. */
        public quotedMessage?: (proto.IMessage|null);

        /** ContextInfo remoteJid. */
        public remoteJid: string;

        /** ContextInfo mentionedJid. */
        public mentionedJid: string[];

        /** ContextInfo conversionSource. */
        public conversionSource: string;

        /** ContextInfo conversionData. */
        public conversionData: Uint8Array;

        /** ContextInfo conversionDelaySeconds. */
        public conversionDelaySeconds: number;

        /** ContextInfo forwardingScore. */
        public forwardingScore: number;

        /** ContextInfo isForwarded. */
        public isForwarded: boolean;

        /** ContextInfo quotedAd. */
        public quotedAd?: (proto.ContextInfo.IAdReplyInfo|null);

        /** ContextInfo placeholderKey. */
        public placeholderKey?: (proto.IMessageKey|null);

        /** ContextInfo expiration. */
        public expiration: number;

        /** ContextInfo ephemeralSettingTimestamp. */
        public ephemeralSettingTimestamp: (number|Long);

        /** ContextInfo ephemeralSharedSecret. */
        public ephemeralSharedSecret: Uint8Array;

        /** ContextInfo externalAdReply. */
        public externalAdReply?: (proto.ContextInfo.IExternalAdReplyInfo|null);

        /** ContextInfo entryPointConversionSource. */
        public entryPointConversionSource: string;

        /** ContextInfo entryPointConversionApp. */
        public entryPointConversionApp: string;

        /** ContextInfo entryPointConversionDelaySeconds. */
        public entryPointConversionDelaySeconds: number;

        /** ContextInfo disappearingMode. */
        public disappearingMode?: (proto.IDisappearingMode|null);

        /** ContextInfo actionLink. */
        public actionLink?: (proto.IActionLink|null);

        /** ContextInfo groupSubject. */
        public groupSubject: string;

        /** ContextInfo parentGroupJid. */
        public parentGroupJid: string;

        /** ContextInfo trustBannerType. */
        public trustBannerType: string;

        /** ContextInfo trustBannerAction. */
        public trustBannerAction: number;

        /** ContextInfo isSampled. */
        public isSampled: boolean;

        /** ContextInfo groupMentions. */
        public groupMentions: proto.IGroupMention[];

        /** ContextInfo utm. */
        public utm?: (proto.ContextInfo.IUTMInfo|null);

        /**
         * Crea una nueva instancia ContextInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ContextInfo instance
         */
        public static create(properties?: proto.IContextInfo): proto.ContextInfo;

        /**
         * Codifica el mensaje ContextInfo. No implícitamente mensajes {@link proto.ContextInfo.verify|verify}.
         * @param message ContextInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IContextInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ContextInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.ContextInfo.verify|verify}.
         * @param message ContextInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IContextInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ContextInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ContextInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ContextInfo;

        /**
         * Decodes a ContextInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ContextInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ContextInfo;

        /**
         * Verifies a ContextInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ContextInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ContextInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.ContextInfo;

        /**
         * Crea un objeto simple desde ContextInfo. También convierte valores a otros tipos si se especifica.
         * @param message ContextInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ContextInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ContextInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace ContextInfo {

        /** Propiedades de unn AdReplyInfo. */
        interface IAdReplyInfo {

            /** AdReplyInfo advertiserName */
            advertiserName?: (string|null);

            /** AdReplyInfo mediaType */
            mediaType?: (proto.ContextInfo.AdReplyInfo.MediaType|null);

            /** AdReplyInfo jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** AdReplyInfo caption */
            caption?: (string|null);
        }

        /** Representa unn AdReplyInfo. */
        class AdReplyInfo implements IAdReplyInfo {

            /**
             * Construya un nuevo AdReplyInfo.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ContextInfo.IAdReplyInfo);

            /** AdReplyInfo advertiserName. */
            public advertiserName: string;

            /** AdReplyInfo mediaType. */
            public mediaType: proto.ContextInfo.AdReplyInfo.MediaType;

            /** AdReplyInfo jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** AdReplyInfo caption. */
            public caption: string;

            /**
             * Crea una nueva instancia AdReplyInfo utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AdReplyInfo instance
             */
            public static create(properties?: proto.ContextInfo.IAdReplyInfo): proto.ContextInfo.AdReplyInfo;

            /**
             * Codifica el mensaje AdReplyInfo. No implícitamente mensajes {@link proto.ContextInfo.AdReplyInfo.verify|verify}.
             * @param message AdReplyInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ContextInfo.IAdReplyInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AdReplyInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.ContextInfo.AdReplyInfo.verify|verify}.
             * @param message AdReplyInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ContextInfo.IAdReplyInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AdReplyInfo message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AdReplyInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ContextInfo.AdReplyInfo;

            /**
             * Decodes an AdReplyInfo message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AdReplyInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ContextInfo.AdReplyInfo;

            /**
             * Verifies an AdReplyInfo message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AdReplyInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AdReplyInfo
             */
            public static fromObject(object: { [k: string]: any }): proto.ContextInfo.AdReplyInfo;

            /**
             * Crea un objeto simple desden AdReplyInfo. También convierte valores a otros tipos si se especifica.
             * @param message AdReplyInfo
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ContextInfo.AdReplyInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AdReplyInfo a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace AdReplyInfo {

            /** MediaType enum. */
            enum MediaType {
                NONE = 0,
                IMAGE = 1,
                VIDEO = 2
            }
        }

        /** Propiedades de unn ExternalAdReplyInfo. */
        interface IExternalAdReplyInfo {

            /** ExternalAdReplyInfo title */
            title?: (string|null);

            /** ExternalAdReplyInfo body */
            body?: (string|null);

            /** ExternalAdReplyInfo mediaType */
            mediaType?: (proto.ContextInfo.ExternalAdReplyInfo.MediaType|null);

            /** ExternalAdReplyInfo thumbnailUrl */
            thumbnailUrl?: (string|null);

            /** ExternalAdReplyInfo mediaUrl */
            mediaUrl?: (string|null);

            /** ExternalAdReplyInfo thumbnail */
            thumbnail?: (Uint8Array|null);

            /** ExternalAdReplyInfo sourceType */
            sourceType?: (string|null);

            /** ExternalAdReplyInfo sourceId */
            sourceId?: (string|null);

            /** ExternalAdReplyInfo sourceUrl */
            sourceUrl?: (string|null);

            /** ExternalAdReplyInfo containsAutoReply */
            containsAutoReply?: (boolean|null);

            /** ExternalAdReplyInfo renderLargerThumbnail */
            renderLargerThumbnail?: (boolean|null);

            /** ExternalAdReplyInfo showAdAttribution */
            showAdAttribution?: (boolean|null);

            /** ExternalAdReplyInfo ctwaClid */
            ctwaClid?: (string|null);
        }

        /** Representa unn ExternalAdReplyInfo. */
        class ExternalAdReplyInfo implements IExternalAdReplyInfo {

            /**
             * Construya un nuevo ExternalAdReplyInfo.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ContextInfo.IExternalAdReplyInfo);

            /** ExternalAdReplyInfo title. */
            public title: string;

            /** ExternalAdReplyInfo body. */
            public body: string;

            /** ExternalAdReplyInfo mediaType. */
            public mediaType: proto.ContextInfo.ExternalAdReplyInfo.MediaType;

            /** ExternalAdReplyInfo thumbnailUrl. */
            public thumbnailUrl: string;

            /** ExternalAdReplyInfo mediaUrl. */
            public mediaUrl: string;

            /** ExternalAdReplyInfo thumbnail. */
            public thumbnail: Uint8Array;

            /** ExternalAdReplyInfo sourceType. */
            public sourceType: string;

            /** ExternalAdReplyInfo sourceId. */
            public sourceId: string;

            /** ExternalAdReplyInfo sourceUrl. */
            public sourceUrl: string;

            /** ExternalAdReplyInfo containsAutoReply. */
            public containsAutoReply: boolean;

            /** ExternalAdReplyInfo renderLargerThumbnail. */
            public renderLargerThumbnail: boolean;

            /** ExternalAdReplyInfo showAdAttribution. */
            public showAdAttribution: boolean;

            /** ExternalAdReplyInfo ctwaClid. */
            public ctwaClid: string;

            /**
             * Crea una nueva instancia ExternalAdReplyInfo utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ExternalAdReplyInfo instance
             */
            public static create(properties?: proto.ContextInfo.IExternalAdReplyInfo): proto.ContextInfo.ExternalAdReplyInfo;

            /**
             * Codifica el mensaje ExternalAdReplyInfo. No implícitamente mensajes {@link proto.ContextInfo.ExternalAdReplyInfo.verify|verify}.
             * @param message ExternalAdReplyInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ContextInfo.IExternalAdReplyInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ExternalAdReplyInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.ContextInfo.ExternalAdReplyInfo.verify|verify}.
             * @param message ExternalAdReplyInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ContextInfo.IExternalAdReplyInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExternalAdReplyInfo message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ExternalAdReplyInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ContextInfo.ExternalAdReplyInfo;

            /**
             * Decodes an ExternalAdReplyInfo message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ExternalAdReplyInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ContextInfo.ExternalAdReplyInfo;

            /**
             * Verifies an ExternalAdReplyInfo message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an ExternalAdReplyInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ExternalAdReplyInfo
             */
            public static fromObject(object: { [k: string]: any }): proto.ContextInfo.ExternalAdReplyInfo;

            /**
             * Crea un objeto simple desden ExternalAdReplyInfo. También convierte valores a otros tipos si se especifica.
             * @param message ExternalAdReplyInfo
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ContextInfo.ExternalAdReplyInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ExternalAdReplyInfo a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ExternalAdReplyInfo {

            /** MediaType enum. */
            enum MediaType {
                NONE = 0,
                IMAGE = 1,
                VIDEO = 2
            }
        }

        /** Propiedades de un UTMInfo. */
        interface IUTMInfo {

            /** UTMInfo utmSource */
            utmSource?: (string|null);

            /** UTMInfo utmCampaign */
            utmCampaign?: (string|null);
        }

        /** Representa un UTMInfo. */
        class UTMInfo implements IUTMInfo {

            /**
             * Construya un nuevo UTMInfo.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.ContextInfo.IUTMInfo);

            /** UTMInfo utmSource. */
            public utmSource: string;

            /** UTMInfo utmCampaign. */
            public utmCampaign: string;

            /**
             * Crea una nueva instancia UTMInfo utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns UTMInfo instance
             */
            public static create(properties?: proto.ContextInfo.IUTMInfo): proto.ContextInfo.UTMInfo;

            /**
             * Codifica el mensaje UTMInfo. No implícitamente mensajes {@link proto.ContextInfo.UTMInfo.verify|verify}.
             * @param message UTMInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.ContextInfo.IUTMInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje UTMInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.ContextInfo.UTMInfo.verify|verify}.
             * @param message UTMInfo mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.ContextInfo.IUTMInfo, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a UTMInfo message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns UTMInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ContextInfo.UTMInfo;

            /**
             * Decodes a UTMInfo message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns UTMInfo
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ContextInfo.UTMInfo;

            /**
             * Verifies a UTMInfo message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a UTMInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns UTMInfo
             */
            public static fromObject(object: { [k: string]: any }): proto.ContextInfo.UTMInfo;

            /**
             * Crea un objeto simple desde UTMInfo. También convierte valores a otros tipos si se especifica.
             * @param message UTMInfo
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.ContextInfo.UTMInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  UTMInfo a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un Conversation. */
    interface IConversation {

        /** Conversation id */
        id: string;

        /** Conversation messages */
        messages?: (proto.IHistorySyncMsg[]|null);

        /** Conversation newJid */
        newJid?: (string|null);

        /** Conversation oldJid */
        oldJid?: (string|null);

        /** Conversation lastMsgTimestamp */
        lastMsgTimestamp?: (number|Long|null);

        /** Conversation unreadCount */
        unreadCount?: (number|null);

        /** Conversation readOnly */
        readOnly?: (boolean|null);

        /** Conversation endOfHistoryTransfer */
        endOfHistoryTransfer?: (boolean|null);

        /** Conversation ephemeralExpiration */
        ephemeralExpiration?: (number|null);

        /** Conversation ephemeralSettingTimestamp */
        ephemeralSettingTimestamp?: (number|Long|null);

        /** Conversation endOfHistoryTransferType */
        endOfHistoryTransferType?: (proto.Conversation.EndOfHistoryTransferType|null);

        /** Conversation conversationTimestamp */
        conversationTimestamp?: (number|Long|null);

        /** Conversation name */
        name?: (string|null);

        /** Conversation pHash */
        pHash?: (string|null);

        /** Conversation notSpam */
        notSpam?: (boolean|null);

        /** Conversation archived */
        archived?: (boolean|null);

        /** Conversation disappearingMode */
        disappearingMode?: (proto.IDisappearingMode|null);

        /** Conversation unreadMentionCount */
        unreadMentionCount?: (number|null);

        /** Conversation markedAsUnread */
        markedAsUnread?: (boolean|null);

        /** Conversation participant */
        participant?: (proto.IGroupParticipant[]|null);

        /** Conversation tcToken */
        tcToken?: (Uint8Array|null);

        /** Conversation tcTokenTimestamp */
        tcTokenTimestamp?: (number|Long|null);

        /** Conversation contactPrimaryIdentityKey */
        contactPrimaryIdentityKey?: (Uint8Array|null);

        /** Conversation pinned */
        pinned?: (number|null);

        /** Conversation muteEndTime */
        muteEndTime?: (number|Long|null);

        /** Conversation wallpaper */
        wallpaper?: (proto.IWallpaperSettings|null);

        /** Conversation mediaVisibility */
        mediaVisibility?: (proto.MediaVisibility|null);

        /** Conversation tcTokenSenderTimestamp */
        tcTokenSenderTimestamp?: (number|Long|null);

        /** Conversation suspended */
        suspended?: (boolean|null);

        /** Conversation terminated */
        terminated?: (boolean|null);

        /** Conversation createdAt */
        createdAt?: (number|Long|null);

        /** Conversation createdBy */
        createdBy?: (string|null);

        /** Conversation description */
        description?: (string|null);

        /** Conversation support */
        support?: (boolean|null);

        /** Conversation isParentGroup */
        isParentGroup?: (boolean|null);

        /** Conversation parentGroupId */
        parentGroupId?: (string|null);

        /** Conversation isDefaultSubgroup */
        isDefaultSubgroup?: (boolean|null);

        /** Conversation displayName */
        displayName?: (string|null);

        /** Conversation pnJid */
        pnJid?: (string|null);

        /** Conversation shareOwnPn */
        shareOwnPn?: (boolean|null);

        /** Conversation pnhDuplicateLidThread */
        pnhDuplicateLidThread?: (boolean|null);

        /** Conversation lidJid */
        lidJid?: (string|null);
    }

    /** Representa un Conversation. */
    class Conversation implements IConversation {

        /**
         * Construya un nuevo Conversation.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IConversation);

        /** Conversation id. */
        public id: string;

        /** Conversation messages. */
        public messages: proto.IHistorySyncMsg[];

        /** Conversation newJid. */
        public newJid: string;

        /** Conversation oldJid. */
        public oldJid: string;

        /** Conversation lastMsgTimestamp. */
        public lastMsgTimestamp: (number|Long);

        /** Conversation unreadCount. */
        public unreadCount: number;

        /** Conversation readOnly. */
        public readOnly: boolean;

        /** Conversation endOfHistoryTransfer. */
        public endOfHistoryTransfer: boolean;

        /** Conversation ephemeralExpiration. */
        public ephemeralExpiration: number;

        /** Conversation ephemeralSettingTimestamp. */
        public ephemeralSettingTimestamp: (number|Long);

        /** Conversation endOfHistoryTransferType. */
        public endOfHistoryTransferType: proto.Conversation.EndOfHistoryTransferType;

        /** Conversation conversationTimestamp. */
        public conversationTimestamp: (number|Long);

        /** Conversation name. */
        public name: string;

        /** Conversation pHash. */
        public pHash: string;

        /** Conversation notSpam. */
        public notSpam: boolean;

        /** Conversation archived. */
        public archived: boolean;

        /** Conversation disappearingMode. */
        public disappearingMode?: (proto.IDisappearingMode|null);

        /** Conversation unreadMentionCount. */
        public unreadMentionCount: number;

        /** Conversation markedAsUnread. */
        public markedAsUnread: boolean;

        /** Conversation participant. */
        public participant: proto.IGroupParticipant[];

        /** Conversation tcToken. */
        public tcToken: Uint8Array;

        /** Conversation tcTokenTimestamp. */
        public tcTokenTimestamp: (number|Long);

        /** Conversation contactPrimaryIdentityKey. */
        public contactPrimaryIdentityKey: Uint8Array;

        /** Conversation pinned. */
        public pinned: number;

        /** Conversation muteEndTime. */
        public muteEndTime: (number|Long);

        /** Conversation wallpaper. */
        public wallpaper?: (proto.IWallpaperSettings|null);

        /** Conversation mediaVisibility. */
        public mediaVisibility: proto.MediaVisibility;

        /** Conversation tcTokenSenderTimestamp. */
        public tcTokenSenderTimestamp: (number|Long);

        /** Conversation suspended. */
        public suspended: boolean;

        /** Conversation terminated. */
        public terminated: boolean;

        /** Conversation createdAt. */
        public createdAt: (number|Long);

        /** Conversation createdBy. */
        public createdBy: string;

        /** Conversation description. */
        public description: string;

        /** Conversation support. */
        public support: boolean;

        /** Conversation isParentGroup. */
        public isParentGroup: boolean;

        /** Conversation parentGroupId. */
        public parentGroupId: string;

        /** Conversation isDefaultSubgroup. */
        public isDefaultSubgroup: boolean;

        /** Conversation displayName. */
        public displayName: string;

        /** Conversation pnJid. */
        public pnJid: string;

        /** Conversation shareOwnPn. */
        public shareOwnPn: boolean;

        /** Conversation pnhDuplicateLidThread. */
        public pnhDuplicateLidThread: boolean;

        /** Conversation lidJid. */
        public lidJid: string;

        /**
         * Crea una nueva instancia Conversation utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Conversation instance
         */
        public static create(properties?: proto.IConversation): proto.Conversation;

        /**
         * Codifica el mensaje Conversation. No implícitamente mensajes {@link proto.Conversation.verify|verify}.
         * @param message Conversation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IConversation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Conversation message, delimitado por longitud. No implícitamente mensajes {@link proto.Conversation.verify|verify}.
         * @param message Conversation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IConversation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Conversation message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Conversation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Conversation;

        /**
         * Decodes a Conversation message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Conversation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Conversation;

        /**
         * Verifies a Conversation message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Conversation message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Conversation
         */
        public static fromObject(object: { [k: string]: any }): proto.Conversation;

        /**
         * Crea un objeto simple desde Conversation. También convierte valores a otros tipos si se especifica.
         * @param message Conversation
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Conversation, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Conversation a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace Conversation {

        /** EndOfHistoryTransferType enum. */
        enum EndOfHistoryTransferType {
            COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY = 0,
            COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY = 1
        }
    }

    /** Propiedades de un DeviceListMetadata. */
    interface IDeviceListMetadata {

        /** DeviceListMetadata senderKeyHash */
        senderKeyHash?: (Uint8Array|null);

        /** DeviceListMetadata senderTimestamp */
        senderTimestamp?: (number|Long|null);

        /** DeviceListMetadata senderKeyIndexes */
        senderKeyIndexes?: (number[]|null);

        /** DeviceListMetadata recipientKeyHash */
        recipientKeyHash?: (Uint8Array|null);

        /** DeviceListMetadata recipientTimestamp */
        recipientTimestamp?: (number|Long|null);

        /** DeviceListMetadata recipientKeyIndexes */
        recipientKeyIndexes?: (number[]|null);
    }

    /** Representa un DeviceListMetadata. */
    class DeviceListMetadata implements IDeviceListMetadata {

        /**
         * Construya un nuevo DeviceListMetadata.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IDeviceListMetadata);

        /** DeviceListMetadata senderKeyHash. */
        public senderKeyHash: Uint8Array;

        /** DeviceListMetadata senderTimestamp. */
        public senderTimestamp: (number|Long);

        /** DeviceListMetadata senderKeyIndexes. */
        public senderKeyIndexes: number[];

        /** DeviceListMetadata recipientKeyHash. */
        public recipientKeyHash: Uint8Array;

        /** DeviceListMetadata recipientTimestamp. */
        public recipientTimestamp: (number|Long);

        /** DeviceListMetadata recipientKeyIndexes. */
        public recipientKeyIndexes: number[];

        /**
         * Crea una nueva instancia DeviceListMetadata utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns DeviceListMetadata instance
         */
        public static create(properties?: proto.IDeviceListMetadata): proto.DeviceListMetadata;

        /**
         * Codifica el mensaje DeviceListMetadata. No implícitamente mensajes {@link proto.DeviceListMetadata.verify|verify}.
         * @param message DeviceListMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IDeviceListMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje DeviceListMetadata message, delimitado por longitud. No implícitamente mensajes {@link proto.DeviceListMetadata.verify|verify}.
         * @param message DeviceListMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IDeviceListMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a DeviceListMetadata message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns DeviceListMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.DeviceListMetadata;

        /**
         * Decodes a DeviceListMetadata message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns DeviceListMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.DeviceListMetadata;

        /**
         * Verifies a DeviceListMetadata message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a DeviceListMetadata message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns DeviceListMetadata
         */
        public static fromObject(object: { [k: string]: any }): proto.DeviceListMetadata;

        /**
         * Crea un objeto simple desde DeviceListMetadata. También convierte valores a otros tipos si se especifica.
         * @param message DeviceListMetadata
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.DeviceListMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  DeviceListMetadata a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un DeviceProps. */
    interface IDeviceProps {

        /** DeviceProps os */
        os?: (string|null);

        /** DeviceProps version */
        version?: (proto.DeviceProps.IAppVersion|null);

        /** DeviceProps platformType */
        platformType?: (proto.DeviceProps.PlatformType|null);

        /** DeviceProps requireFullSync */
        requireFullSync?: (boolean|null);

        /** DeviceProps historySyncConfig */
        historySyncConfig?: (proto.DeviceProps.IHistorySyncConfig|null);
    }

    /** Representa un DeviceProps. */
    class DeviceProps implements IDeviceProps {

        /**
         * Construya un nuevo DeviceProps.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IDeviceProps);

        /** DeviceProps os. */
        public os: string;

        /** DeviceProps version. */
        public version?: (proto.DeviceProps.IAppVersion|null);

        /** DeviceProps platformType. */
        public platformType: proto.DeviceProps.PlatformType;

        /** DeviceProps requireFullSync. */
        public requireFullSync: boolean;

        /** DeviceProps historySyncConfig. */
        public historySyncConfig?: (proto.DeviceProps.IHistorySyncConfig|null);

        /**
         * Crea una nueva instancia DeviceProps utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns DeviceProps instance
         */
        public static create(properties?: proto.IDeviceProps): proto.DeviceProps;

        /**
         * Codifica el mensaje DeviceProps. No implícitamente mensajes {@link proto.DeviceProps.verify|verify}.
         * @param message DeviceProps mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IDeviceProps, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje DeviceProps message, delimitado por longitud. No implícitamente mensajes {@link proto.DeviceProps.verify|verify}.
         * @param message DeviceProps mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IDeviceProps, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a DeviceProps message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns DeviceProps
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.DeviceProps;

        /**
         * Decodes a DeviceProps message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns DeviceProps
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.DeviceProps;

        /**
         * Verifies a DeviceProps message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a DeviceProps message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns DeviceProps
         */
        public static fromObject(object: { [k: string]: any }): proto.DeviceProps;

        /**
         * Crea un objeto simple desde DeviceProps. También convierte valores a otros tipos si se especifica.
         * @param message DeviceProps
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.DeviceProps, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  DeviceProps a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace DeviceProps {

        /** Propiedades de unn AppVersion. */
        interface IAppVersion {

            /** AppVersion primary */
            primary?: (number|null);

            /** AppVersion secondary */
            secondary?: (number|null);

            /** AppVersion tertiary */
            tertiary?: (number|null);

            /** AppVersion quaternary */
            quaternary?: (number|null);

            /** AppVersion quinary */
            quinary?: (number|null);
        }

        /** Representa unn AppVersion. */
        class AppVersion implements IAppVersion {

            /**
             * Construya un nuevo AppVersion.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.DeviceProps.IAppVersion);

            /** AppVersion primary. */
            public primary: number;

            /** AppVersion secondary. */
            public secondary: number;

            /** AppVersion tertiary. */
            public tertiary: number;

            /** AppVersion quaternary. */
            public quaternary: number;

            /** AppVersion quinary. */
            public quinary: number;

            /**
             * Crea una nueva instancia AppVersion utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppVersion instance
             */
            public static create(properties?: proto.DeviceProps.IAppVersion): proto.DeviceProps.AppVersion;

            /**
             * Codifica el mensaje AppVersion. No implícitamente mensajes {@link proto.DeviceProps.AppVersion.verify|verify}.
             * @param message AppVersion mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.DeviceProps.IAppVersion, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppVersion message, delimitado por longitud. No implícitamente mensajes {@link proto.DeviceProps.AppVersion.verify|verify}.
             * @param message AppVersion mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.DeviceProps.IAppVersion, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppVersion message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppVersion
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.DeviceProps.AppVersion;

            /**
             * Decodes an AppVersion message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppVersion
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.DeviceProps.AppVersion;

            /**
             * Verifies an AppVersion message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppVersion message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppVersion
             */
            public static fromObject(object: { [k: string]: any }): proto.DeviceProps.AppVersion;

            /**
             * Crea un objeto simple desden AppVersion. También convierte valores a otros tipos si se especifica.
             * @param message AppVersion
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.DeviceProps.AppVersion, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppVersion a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un HistorySyncConfig. */
        interface IHistorySyncConfig {

            /** HistorySyncConfig fullSyncDaysLimit */
            fullSyncDaysLimit?: (number|null);

            /** HistorySyncConfig fullSyncSizeMbLimit */
            fullSyncSizeMbLimit?: (number|null);

            /** HistorySyncConfig storageQuotaMb */
            storageQuotaMb?: (number|null);
        }

        /** Representa un HistorySyncConfig. */
        class HistorySyncConfig implements IHistorySyncConfig {

            /**
             * Construya un nuevo HistorySyncConfig.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.DeviceProps.IHistorySyncConfig);

            /** HistorySyncConfig fullSyncDaysLimit. */
            public fullSyncDaysLimit: number;

            /** HistorySyncConfig fullSyncSizeMbLimit. */
            public fullSyncSizeMbLimit: number;

            /** HistorySyncConfig storageQuotaMb. */
            public storageQuotaMb: number;

            /**
             * Crea una nueva instancia HistorySyncConfig utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HistorySyncConfig instance
             */
            public static create(properties?: proto.DeviceProps.IHistorySyncConfig): proto.DeviceProps.HistorySyncConfig;

            /**
             * Codifica el mensaje HistorySyncConfig. No implícitamente mensajes {@link proto.DeviceProps.HistorySyncConfig.verify|verify}.
             * @param message HistorySyncConfig mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.DeviceProps.IHistorySyncConfig, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HistorySyncConfig message, delimitado por longitud. No implícitamente mensajes {@link proto.DeviceProps.HistorySyncConfig.verify|verify}.
             * @param message HistorySyncConfig mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.DeviceProps.IHistorySyncConfig, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HistorySyncConfig message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HistorySyncConfig
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.DeviceProps.HistorySyncConfig;

            /**
             * Decodes a HistorySyncConfig message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HistorySyncConfig
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.DeviceProps.HistorySyncConfig;

            /**
             * Verifies a HistorySyncConfig message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HistorySyncConfig message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HistorySyncConfig
             */
            public static fromObject(object: { [k: string]: any }): proto.DeviceProps.HistorySyncConfig;

            /**
             * Crea un objeto simple desde HistorySyncConfig. También convierte valores a otros tipos si se especifica.
             * @param message HistorySyncConfig
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.DeviceProps.HistorySyncConfig, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HistorySyncConfig a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** PlatformType enum. */
        enum PlatformType {
            UNKNOWN = 0,
            CHROME = 1,
            FIREFOX = 2,
            IE = 3,
            OPERA = 4,
            SAFARI = 5,
            EDGE = 6,
            DESKTOP = 7,
            IPAD = 8,
            ANDROID_TABLET = 9,
            OHANA = 10,
            ALOHA = 11,
            CATALINA = 12,
            TCL_TV = 13,
            IOS_PHONE = 14,
            IOS_CATALYST = 15,
            ANDROID_PHONE = 16,
            ANDROID_AMBIGUOUS = 17
        }
    }

    /** Propiedades de un DisappearingMode. */
    interface IDisappearingMode {

        /** DisappearingMode initiator */
        initiator?: (proto.DisappearingMode.Initiator|null);
    }

    /** Representa un DisappearingMode. */
    class DisappearingMode implements IDisappearingMode {

        /**
         * Construya un nuevo DisappearingMode.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IDisappearingMode);

        /** DisappearingMode initiator. */
        public initiator: proto.DisappearingMode.Initiator;

        /**
         * Crea una nueva instancia DisappearingMode utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns DisappearingMode instance
         */
        public static create(properties?: proto.IDisappearingMode): proto.DisappearingMode;

        /**
         * Codifica el mensaje DisappearingMode. No implícitamente mensajes {@link proto.DisappearingMode.verify|verify}.
         * @param message DisappearingMode mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IDisappearingMode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje DisappearingMode message, delimitado por longitud. No implícitamente mensajes {@link proto.DisappearingMode.verify|verify}.
         * @param message DisappearingMode mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IDisappearingMode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a DisappearingMode message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns DisappearingMode
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.DisappearingMode;

        /**
         * Decodes a DisappearingMode message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns DisappearingMode
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.DisappearingMode;

        /**
         * Verifies a DisappearingMode message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a DisappearingMode message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns DisappearingMode
         */
        public static fromObject(object: { [k: string]: any }): proto.DisappearingMode;

        /**
         * Crea un objeto simple desde DisappearingMode. También convierte valores a otros tipos si se especifica.
         * @param message DisappearingMode
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.DisappearingMode, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  DisappearingMode a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace DisappearingMode {

        /** Initiator enum. */
        enum Initiator {
            CHANGED_IN_CHAT = 0,
            INITIATED_BY_ME = 1,
            INITIATED_BY_OTHER = 2
        }
    }

    /** Propiedades de unn EphemeralSetting. */
    interface IEphemeralSetting {

        /** EphemeralSetting duration */
        duration?: (number|null);

        /** EphemeralSetting timestamp */
        timestamp?: (number|Long|null);
    }

    /** Representa unn EphemeralSetting. */
    class EphemeralSetting implements IEphemeralSetting {

        /**
         * Construya un nuevo EphemeralSetting.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IEphemeralSetting);

        /** EphemeralSetting duration. */
        public duration: number;

        /** EphemeralSetting timestamp. */
        public timestamp: (number|Long);

        /**
         * Crea una nueva instancia EphemeralSetting utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns EphemeralSetting instance
         */
        public static create(properties?: proto.IEphemeralSetting): proto.EphemeralSetting;

        /**
         * Codifica el mensaje EphemeralSetting. No implícitamente mensajes {@link proto.EphemeralSetting.verify|verify}.
         * @param message EphemeralSetting mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IEphemeralSetting, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje EphemeralSetting message, delimitado por longitud. No implícitamente mensajes {@link proto.EphemeralSetting.verify|verify}.
         * @param message EphemeralSetting mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IEphemeralSetting, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an EphemeralSetting message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns EphemeralSetting
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.EphemeralSetting;

        /**
         * Decodes an EphemeralSetting message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns EphemeralSetting
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.EphemeralSetting;

        /**
         * Verifies an EphemeralSetting message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an EphemeralSetting message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns EphemeralSetting
         */
        public static fromObject(object: { [k: string]: any }): proto.EphemeralSetting;

        /**
         * Crea un objeto simple desden EphemeralSetting. También convierte valores a otros tipos si se especifica.
         * @param message EphemeralSetting
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.EphemeralSetting, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  EphemeralSetting a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn ExitCode. */
    interface IExitCode {

        /** ExitCode code */
        code?: (number|Long|null);

        /** ExitCode text */
        text?: (string|null);
    }

    /** Representa unn ExitCode. */
    class ExitCode implements IExitCode {

        /**
         * Construya un nuevo ExitCode.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IExitCode);

        /** ExitCode code. */
        public code: (number|Long);

        /** ExitCode text. */
        public text: string;

        /**
         * Crea una nueva instancia ExitCode utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ExitCode instance
         */
        public static create(properties?: proto.IExitCode): proto.ExitCode;

        /**
         * Codifica el mensaje ExitCode. No implícitamente mensajes {@link proto.ExitCode.verify|verify}.
         * @param message ExitCode mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IExitCode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ExitCode message, delimitado por longitud. No implícitamente mensajes {@link proto.ExitCode.verify|verify}.
         * @param message ExitCode mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IExitCode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an ExitCode message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ExitCode
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ExitCode;

        /**
         * Decodes an ExitCode message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ExitCode
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ExitCode;

        /**
         * Verifies an ExitCode message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an ExitCode message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ExitCode
         */
        public static fromObject(object: { [k: string]: any }): proto.ExitCode;

        /**
         * Crea un objeto simple desden ExitCode. También convierte valores a otros tipos si se especifica.
         * @param message ExitCode
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ExitCode, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ExitCode a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn ExternalBlobReference. */
    interface IExternalBlobReference {

        /** ExternalBlobReference mediaKey */
        mediaKey?: (Uint8Array|null);

        /** ExternalBlobReference directPath */
        directPath?: (string|null);

        /** ExternalBlobReference handle */
        handle?: (string|null);

        /** ExternalBlobReference fileSizeBytes */
        fileSizeBytes?: (number|Long|null);

        /** ExternalBlobReference fileSha256 */
        fileSha256?: (Uint8Array|null);

        /** ExternalBlobReference fileEncSha256 */
        fileEncSha256?: (Uint8Array|null);
    }

    /** Representa unn ExternalBlobReference. */
    class ExternalBlobReference implements IExternalBlobReference {

        /**
         * Construya un nuevo ExternalBlobReference.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IExternalBlobReference);

        /** ExternalBlobReference mediaKey. */
        public mediaKey: Uint8Array;

        /** ExternalBlobReference directPath. */
        public directPath: string;

        /** ExternalBlobReference handle. */
        public handle: string;

        /** ExternalBlobReference fileSizeBytes. */
        public fileSizeBytes: (number|Long);

        /** ExternalBlobReference fileSha256. */
        public fileSha256: Uint8Array;

        /** ExternalBlobReference fileEncSha256. */
        public fileEncSha256: Uint8Array;

        /**
         * Crea una nueva instancia ExternalBlobReference utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ExternalBlobReference instance
         */
        public static create(properties?: proto.IExternalBlobReference): proto.ExternalBlobReference;

        /**
         * Codifica el mensaje ExternalBlobReference. No implícitamente mensajes {@link proto.ExternalBlobReference.verify|verify}.
         * @param message ExternalBlobReference mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IExternalBlobReference, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ExternalBlobReference message, delimitado por longitud. No implícitamente mensajes {@link proto.ExternalBlobReference.verify|verify}.
         * @param message ExternalBlobReference mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IExternalBlobReference, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an ExternalBlobReference message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ExternalBlobReference
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ExternalBlobReference;

        /**
         * Decodes an ExternalBlobReference message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ExternalBlobReference
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ExternalBlobReference;

        /**
         * Verifies an ExternalBlobReference message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an ExternalBlobReference message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ExternalBlobReference
         */
        public static fromObject(object: { [k: string]: any }): proto.ExternalBlobReference;

        /**
         * Crea un objeto simple desden ExternalBlobReference. También convierte valores a otros tipos si se especifica.
         * @param message ExternalBlobReference
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ExternalBlobReference, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ExternalBlobReference a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un GlobalSettings. */
    interface IGlobalSettings {

        /** GlobalSettings lightThemeWallpaper */
        lightThemeWallpaper?: (proto.IWallpaperSettings|null);

        /** GlobalSettings mediaVisibility */
        mediaVisibility?: (proto.MediaVisibility|null);

        /** GlobalSettings darkThemeWallpaper */
        darkThemeWallpaper?: (proto.IWallpaperSettings|null);

        /** GlobalSettings autoDownloadWiFi */
        autoDownloadWiFi?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings autoDownloadCellular */
        autoDownloadCellular?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings autoDownloadRoaming */
        autoDownloadRoaming?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings showIndividualNotificationsPreview */
        showIndividualNotificationsPreview?: (boolean|null);

        /** GlobalSettings showGroupNotificationsPreview */
        showGroupNotificationsPreview?: (boolean|null);

        /** GlobalSettings disappearingModeDuration */
        disappearingModeDuration?: (number|null);

        /** GlobalSettings disappearingModeTimestamp */
        disappearingModeTimestamp?: (number|Long|null);

        /** GlobalSettings avatarUserSettings */
        avatarUserSettings?: (proto.IAvatarUserSettings|null);
    }

    /** Representa un GlobalSettings. */
    class GlobalSettings implements IGlobalSettings {

        /**
         * Construya un nuevo GlobalSettings.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IGlobalSettings);

        /** GlobalSettings lightThemeWallpaper. */
        public lightThemeWallpaper?: (proto.IWallpaperSettings|null);

        /** GlobalSettings mediaVisibility. */
        public mediaVisibility: proto.MediaVisibility;

        /** GlobalSettings darkThemeWallpaper. */
        public darkThemeWallpaper?: (proto.IWallpaperSettings|null);

        /** GlobalSettings autoDownloadWiFi. */
        public autoDownloadWiFi?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings autoDownloadCellular. */
        public autoDownloadCellular?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings autoDownloadRoaming. */
        public autoDownloadRoaming?: (proto.IAutoDownloadSettings|null);

        /** GlobalSettings showIndividualNotificationsPreview. */
        public showIndividualNotificationsPreview: boolean;

        /** GlobalSettings showGroupNotificationsPreview. */
        public showGroupNotificationsPreview: boolean;

        /** GlobalSettings disappearingModeDuration. */
        public disappearingModeDuration: number;

        /** GlobalSettings disappearingModeTimestamp. */
        public disappearingModeTimestamp: (number|Long);

        /** GlobalSettings avatarUserSettings. */
        public avatarUserSettings?: (proto.IAvatarUserSettings|null);

        /**
         * Crea una nueva instancia GlobalSettings utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns GlobalSettings instance
         */
        public static create(properties?: proto.IGlobalSettings): proto.GlobalSettings;

        /**
         * Codifica el mensaje GlobalSettings. No implícitamente mensajes {@link proto.GlobalSettings.verify|verify}.
         * @param message GlobalSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IGlobalSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje GlobalSettings message, delimitado por longitud. No implícitamente mensajes {@link proto.GlobalSettings.verify|verify}.
         * @param message GlobalSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IGlobalSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GlobalSettings message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns GlobalSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.GlobalSettings;

        /**
         * Decodes a GlobalSettings message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns GlobalSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.GlobalSettings;

        /**
         * Verifies a GlobalSettings message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GlobalSettings message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns GlobalSettings
         */
        public static fromObject(object: { [k: string]: any }): proto.GlobalSettings;

        /**
         * Crea un objeto simple desde GlobalSettings. También convierte valores a otros tipos si se especifica.
         * @param message GlobalSettings
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.GlobalSettings, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  GlobalSettings a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un GroupMention. */
    interface IGroupMention {

        /** GroupMention groupJid */
        groupJid?: (string|null);

        /** GroupMention groupSubject */
        groupSubject?: (string|null);
    }

    /** Representa un GroupMention. */
    class GroupMention implements IGroupMention {

        /**
         * Construya un nuevo GroupMention.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IGroupMention);

        /** GroupMention groupJid. */
        public groupJid: string;

        /** GroupMention groupSubject. */
        public groupSubject: string;

        /**
         * Crea una nueva instancia GroupMention utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns GroupMention instance
         */
        public static create(properties?: proto.IGroupMention): proto.GroupMention;

        /**
         * Codifica el mensaje GroupMention. No implícitamente mensajes {@link proto.GroupMention.verify|verify}.
         * @param message GroupMention mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IGroupMention, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje GroupMention message, delimitado por longitud. No implícitamente mensajes {@link proto.GroupMention.verify|verify}.
         * @param message GroupMention mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IGroupMention, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GroupMention message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns GroupMention
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.GroupMention;

        /**
         * Decodes a GroupMention message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns GroupMention
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.GroupMention;

        /**
         * Verifies a GroupMention message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GroupMention message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns GroupMention
         */
        public static fromObject(object: { [k: string]: any }): proto.GroupMention;

        /**
         * Crea un objeto simple desde GroupMention. También convierte valores a otros tipos si se especifica.
         * @param message GroupMention
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.GroupMention, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  GroupMention a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un GroupParticipant. */
    interface IGroupParticipant {

        /** GroupParticipant userJid */
        userJid: string;

        /** GroupParticipant rank */
        rank?: (proto.GroupParticipant.Rank|null);
    }

    /** Representa un GroupParticipant. */
    class GroupParticipant implements IGroupParticipant {

        /**
         * Construya un nuevo GroupParticipant.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IGroupParticipant);

        /** GroupParticipant userJid. */
        public userJid: string;

        /** GroupParticipant rank. */
        public rank: proto.GroupParticipant.Rank;

        /**
         * Crea una nueva instancia GroupParticipant utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns GroupParticipant instance
         */
        public static create(properties?: proto.IGroupParticipant): proto.GroupParticipant;

        /**
         * Codifica el mensaje GroupParticipant. No implícitamente mensajes {@link proto.GroupParticipant.verify|verify}.
         * @param message GroupParticipant mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IGroupParticipant, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje GroupParticipant message, delimitado por longitud. No implícitamente mensajes {@link proto.GroupParticipant.verify|verify}.
         * @param message GroupParticipant mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IGroupParticipant, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GroupParticipant message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns GroupParticipant
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.GroupParticipant;

        /**
         * Decodes a GroupParticipant message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns GroupParticipant
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.GroupParticipant;

        /**
         * Verifies a GroupParticipant message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GroupParticipant message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns GroupParticipant
         */
        public static fromObject(object: { [k: string]: any }): proto.GroupParticipant;

        /**
         * Crea un objeto simple desde GroupParticipant. También convierte valores a otros tipos si se especifica.
         * @param message GroupParticipant
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.GroupParticipant, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  GroupParticipant a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace GroupParticipant {

        /** Rank enum. */
        enum Rank {
            REGULAR = 0,
            ADMIN = 1,
            SUPERADMIN = 2
        }
    }

    /** Propiedades de un HandshakeMessage. */
    interface IHandshakeMessage {

        /** HandshakeMessage clientHello */
        clientHello?: (proto.HandshakeMessage.IClientHello|null);

        /** HandshakeMessage serverHello */
        serverHello?: (proto.HandshakeMessage.IServerHello|null);

        /** HandshakeMessage clientFinish */
        clientFinish?: (proto.HandshakeMessage.IClientFinish|null);
    }

    /** Representa un HandshakeMessage. */
    class HandshakeMessage implements IHandshakeMessage {

        /**
         * Construya un nuevo HandshakeMessage.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IHandshakeMessage);

        /** HandshakeMessage clientHello. */
        public clientHello?: (proto.HandshakeMessage.IClientHello|null);

        /** HandshakeMessage serverHello. */
        public serverHello?: (proto.HandshakeMessage.IServerHello|null);

        /** HandshakeMessage clientFinish. */
        public clientFinish?: (proto.HandshakeMessage.IClientFinish|null);

        /**
         * Crea una nueva instancia HandshakeMessage utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns HandshakeMessage instance
         */
        public static create(properties?: proto.IHandshakeMessage): proto.HandshakeMessage;

        /**
         * Codifica el mensaje HandshakeMessage. No implícitamente mensajes {@link proto.HandshakeMessage.verify|verify}.
         * @param message HandshakeMessage mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IHandshakeMessage, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje HandshakeMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.HandshakeMessage.verify|verify}.
         * @param message HandshakeMessage mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IHandshakeMessage, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a HandshakeMessage message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns HandshakeMessage
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HandshakeMessage;

        /**
         * Decodes a HandshakeMessage message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns HandshakeMessage
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HandshakeMessage;

        /**
         * Verifies a HandshakeMessage message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a HandshakeMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns HandshakeMessage
         */
        public static fromObject(object: { [k: string]: any }): proto.HandshakeMessage;

        /**
         * Crea un objeto simple desde HandshakeMessage. También convierte valores a otros tipos si se especifica.
         * @param message HandshakeMessage
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.HandshakeMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  HandshakeMessage a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace HandshakeMessage {

        /** Propiedades de un ClientFinish. */
        interface IClientFinish {

            /** ClientFinish static */
            "static"?: (Uint8Array|null);

            /** ClientFinish payload */
            payload?: (Uint8Array|null);
        }

        /** Representa un ClientFinish. */
        class ClientFinish implements IClientFinish {

            /**
             * Construya un nuevo ClientFinish.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HandshakeMessage.IClientFinish);

            /** ClientFinish static. */
            public static: Uint8Array;

            /** ClientFinish payload. */
            public payload: Uint8Array;

            /**
             * Crea una nueva instancia ClientFinish utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ClientFinish instance
             */
            public static create(properties?: proto.HandshakeMessage.IClientFinish): proto.HandshakeMessage.ClientFinish;

            /**
             * Codifica el mensaje ClientFinish. No implícitamente mensajes {@link proto.HandshakeMessage.ClientFinish.verify|verify}.
             * @param message ClientFinish mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HandshakeMessage.IClientFinish, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ClientFinish message, delimitado por longitud. No implícitamente mensajes {@link proto.HandshakeMessage.ClientFinish.verify|verify}.
             * @param message ClientFinish mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HandshakeMessage.IClientFinish, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ClientFinish message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ClientFinish
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HandshakeMessage.ClientFinish;

            /**
             * Decodes a ClientFinish message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ClientFinish
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HandshakeMessage.ClientFinish;

            /**
             * Verifies a ClientFinish message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ClientFinish message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ClientFinish
             */
            public static fromObject(object: { [k: string]: any }): proto.HandshakeMessage.ClientFinish;

            /**
             * Crea un objeto simple desde ClientFinish. También convierte valores a otros tipos si se especifica.
             * @param message ClientFinish
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HandshakeMessage.ClientFinish, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ClientFinish a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ClientHello. */
        interface IClientHello {

            /** ClientHello ephemeral */
            ephemeral?: (Uint8Array|null);

            /** ClientHello static */
            "static"?: (Uint8Array|null);

            /** ClientHello payload */
            payload?: (Uint8Array|null);
        }

        /** Representa un ClientHello. */
        class ClientHello implements IClientHello {

            /**
             * Construya un nuevo ClientHello.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HandshakeMessage.IClientHello);

            /** ClientHello ephemeral. */
            public ephemeral: Uint8Array;

            /** ClientHello static. */
            public static: Uint8Array;

            /** ClientHello payload. */
            public payload: Uint8Array;

            /**
             * Crea una nueva instancia ClientHello utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ClientHello instance
             */
            public static create(properties?: proto.HandshakeMessage.IClientHello): proto.HandshakeMessage.ClientHello;

            /**
             * Codifica el mensaje ClientHello. No implícitamente mensajes {@link proto.HandshakeMessage.ClientHello.verify|verify}.
             * @param message ClientHello mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HandshakeMessage.IClientHello, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ClientHello message, delimitado por longitud. No implícitamente mensajes {@link proto.HandshakeMessage.ClientHello.verify|verify}.
             * @param message ClientHello mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HandshakeMessage.IClientHello, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ClientHello message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ClientHello
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HandshakeMessage.ClientHello;

            /**
             * Decodes a ClientHello message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ClientHello
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HandshakeMessage.ClientHello;

            /**
             * Verifies a ClientHello message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ClientHello message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ClientHello
             */
            public static fromObject(object: { [k: string]: any }): proto.HandshakeMessage.ClientHello;

            /**
             * Crea un objeto simple desde ClientHello. También convierte valores a otros tipos si se especifica.
             * @param message ClientHello
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HandshakeMessage.ClientHello, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ClientHello a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ServerHello. */
        interface IServerHello {

            /** ServerHello ephemeral */
            ephemeral?: (Uint8Array|null);

            /** ServerHello static */
            "static"?: (Uint8Array|null);

            /** ServerHello payload */
            payload?: (Uint8Array|null);
        }

        /** Representa un ServerHello. */
        class ServerHello implements IServerHello {

            /**
             * Construya un nuevo ServerHello.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HandshakeMessage.IServerHello);

            /** ServerHello ephemeral. */
            public ephemeral: Uint8Array;

            /** ServerHello static. */
            public static: Uint8Array;

            /** ServerHello payload. */
            public payload: Uint8Array;

            /**
             * Crea una nueva instancia ServerHello utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ServerHello instance
             */
            public static create(properties?: proto.HandshakeMessage.IServerHello): proto.HandshakeMessage.ServerHello;

            /**
             * Codifica el mensaje ServerHello. No implícitamente mensajes {@link proto.HandshakeMessage.ServerHello.verify|verify}.
             * @param message ServerHello mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HandshakeMessage.IServerHello, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ServerHello message, delimitado por longitud. No implícitamente mensajes {@link proto.HandshakeMessage.ServerHello.verify|verify}.
             * @param message ServerHello mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HandshakeMessage.IServerHello, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServerHello message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ServerHello
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HandshakeMessage.ServerHello;

            /**
             * Decodes a ServerHello message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ServerHello
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HandshakeMessage.ServerHello;

            /**
             * Verifies a ServerHello message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ServerHello message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ServerHello
             */
            public static fromObject(object: { [k: string]: any }): proto.HandshakeMessage.ServerHello;

            /**
             * Crea un objeto simple desde ServerHello. También convierte valores a otros tipos si se especifica.
             * @param message ServerHello
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HandshakeMessage.ServerHello, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ServerHello a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un HistorySync. */
    interface IHistorySync {

        /** HistorySync syncType */
        syncType: proto.HistorySync.HistorySyncType;

        /** HistorySync conversations */
        conversations?: (proto.IConversation[]|null);

        /** HistorySync statusV3Messages */
        statusV3Messages?: (proto.IWebMessageInfo[]|null);

        /** HistorySync chunkOrder */
        chunkOrder?: (number|null);

        /** HistorySync progress */
        progress?: (number|null);

        /** HistorySync pushnames */
        pushnames?: (proto.IPushname[]|null);

        /** HistorySync globalSettings */
        globalSettings?: (proto.IGlobalSettings|null);

        /** HistorySync threadIdUserSecret */
        threadIdUserSecret?: (Uint8Array|null);

        /** HistorySync threadDsTimeframeOffset */
        threadDsTimeframeOffset?: (number|null);

        /** HistorySync recentStickers */
        recentStickers?: (proto.IStickerMetadata[]|null);

        /** HistorySync pastParticipants */
        pastParticipants?: (proto.IPastParticipants[]|null);
    }

    /** Representa un HistorySync. */
    class HistorySync implements IHistorySync {

        /**
         * Construya un nuevo HistorySync.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IHistorySync);

        /** HistorySync syncType. */
        public syncType: proto.HistorySync.HistorySyncType;

        /** HistorySync conversations. */
        public conversations: proto.IConversation[];

        /** HistorySync statusV3Messages. */
        public statusV3Messages: proto.IWebMessageInfo[];

        /** HistorySync chunkOrder. */
        public chunkOrder: number;

        /** HistorySync progress. */
        public progress: number;

        /** HistorySync pushnames. */
        public pushnames: proto.IPushname[];

        /** HistorySync globalSettings. */
        public globalSettings?: (proto.IGlobalSettings|null);

        /** HistorySync threadIdUserSecret. */
        public threadIdUserSecret: Uint8Array;

        /** HistorySync threadDsTimeframeOffset. */
        public threadDsTimeframeOffset: number;

        /** HistorySync recentStickers. */
        public recentStickers: proto.IStickerMetadata[];

        /** HistorySync pastParticipants. */
        public pastParticipants: proto.IPastParticipants[];

        /**
         * Crea una nueva instancia HistorySync utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns HistorySync instance
         */
        public static create(properties?: proto.IHistorySync): proto.HistorySync;

        /**
         * Codifica el mensaje HistorySync. No implícitamente mensajes {@link proto.HistorySync.verify|verify}.
         * @param message HistorySync mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IHistorySync, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje HistorySync message, delimitado por longitud. No implícitamente mensajes {@link proto.HistorySync.verify|verify}.
         * @param message HistorySync mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IHistorySync, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a HistorySync message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns HistorySync
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HistorySync;

        /**
         * Decodes a HistorySync message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns HistorySync
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HistorySync;

        /**
         * Verifies a HistorySync message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a HistorySync message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns HistorySync
         */
        public static fromObject(object: { [k: string]: any }): proto.HistorySync;

        /**
         * Crea un objeto simple desde HistorySync. También convierte valores a otros tipos si se especifica.
         * @param message HistorySync
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.HistorySync, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  HistorySync a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace HistorySync {

        /** HistorySyncType enum. */
        enum HistorySyncType {
            INITIAL_BOOTSTRAP = 0,
            INITIAL_STATUS_V3 = 1,
            FULL = 2,
            RECENT = 3,
            PUSH_NAME = 4,
            NON_BLOCKING_DATA = 5,
            ON_DEMAND = 6
        }
    }

    /** Propiedades de un HistorySyncMsg. */
    interface IHistorySyncMsg {

        /** HistorySyncMsg message */
        message?: (proto.IWebMessageInfo|null);

        /** HistorySyncMsg msgOrderId */
        msgOrderId?: (number|Long|null);
    }

    /** Representa un HistorySyncMsg. */
    class HistorySyncMsg implements IHistorySyncMsg {

        /**
         * Construya un nuevo HistorySyncMsg.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IHistorySyncMsg);

        /** HistorySyncMsg message. */
        public message?: (proto.IWebMessageInfo|null);

        /** HistorySyncMsg msgOrderId. */
        public msgOrderId: (number|Long);

        /**
         * Crea una nueva instancia HistorySyncMsg utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns HistorySyncMsg instance
         */
        public static create(properties?: proto.IHistorySyncMsg): proto.HistorySyncMsg;

        /**
         * Codifica el mensaje HistorySyncMsg. No implícitamente mensajes {@link proto.HistorySyncMsg.verify|verify}.
         * @param message HistorySyncMsg mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IHistorySyncMsg, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje HistorySyncMsg message, delimitado por longitud. No implícitamente mensajes {@link proto.HistorySyncMsg.verify|verify}.
         * @param message HistorySyncMsg mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IHistorySyncMsg, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a HistorySyncMsg message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns HistorySyncMsg
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HistorySyncMsg;

        /**
         * Decodes a HistorySyncMsg message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns HistorySyncMsg
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HistorySyncMsg;

        /**
         * Verifies a HistorySyncMsg message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a HistorySyncMsg message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns HistorySyncMsg
         */
        public static fromObject(object: { [k: string]: any }): proto.HistorySyncMsg;

        /**
         * Crea un objeto simple desde HistorySyncMsg. También convierte valores a otros tipos si se especifica.
         * @param message HistorySyncMsg
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.HistorySyncMsg, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  HistorySyncMsg a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un HydratedTemplateButton. */
    interface IHydratedTemplateButton {

        /** HydratedTemplateButton index */
        index?: (number|null);

        /** HydratedTemplateButton quickReplyButton */
        quickReplyButton?: (proto.HydratedTemplateButton.IHydratedQuickReplyButton|null);

        /** HydratedTemplateButton urlButton */
        urlButton?: (proto.HydratedTemplateButton.IHydratedURLButton|null);

        /** HydratedTemplateButton callButton */
        callButton?: (proto.HydratedTemplateButton.IHydratedCallButton|null);
    }

    /** Representa un HydratedTemplateButton. */
    class HydratedTemplateButton implements IHydratedTemplateButton {

        /**
         * Construya un nuevo HydratedTemplateButton.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IHydratedTemplateButton);

        /** HydratedTemplateButton index. */
        public index: number;

        /** HydratedTemplateButton quickReplyButton. */
        public quickReplyButton?: (proto.HydratedTemplateButton.IHydratedQuickReplyButton|null);

        /** HydratedTemplateButton urlButton. */
        public urlButton?: (proto.HydratedTemplateButton.IHydratedURLButton|null);

        /** HydratedTemplateButton callButton. */
        public callButton?: (proto.HydratedTemplateButton.IHydratedCallButton|null);

        /** HydratedTemplateButton hydratedButton. */
        public hydratedButton?: ("quickReplyButton"|"urlButton"|"callButton");

        /**
         * Crea una nueva instancia HydratedTemplateButton utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns HydratedTemplateButton instance
         */
        public static create(properties?: proto.IHydratedTemplateButton): proto.HydratedTemplateButton;

        /**
         * Codifica el mensaje HydratedTemplateButton. No implícitamente mensajes {@link proto.HydratedTemplateButton.verify|verify}.
         * @param message HydratedTemplateButton mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IHydratedTemplateButton, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje HydratedTemplateButton message, delimitado por longitud. No implícitamente mensajes {@link proto.HydratedTemplateButton.verify|verify}.
         * @param message HydratedTemplateButton mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IHydratedTemplateButton, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a HydratedTemplateButton message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns HydratedTemplateButton
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HydratedTemplateButton;

        /**
         * Decodes a HydratedTemplateButton message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns HydratedTemplateButton
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HydratedTemplateButton;

        /**
         * Verifies a HydratedTemplateButton message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a HydratedTemplateButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns HydratedTemplateButton
         */
        public static fromObject(object: { [k: string]: any }): proto.HydratedTemplateButton;

        /**
         * Crea un objeto simple desde HydratedTemplateButton. También convierte valores a otros tipos si se especifica.
         * @param message HydratedTemplateButton
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.HydratedTemplateButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  HydratedTemplateButton a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace HydratedTemplateButton {

        /** Propiedades de un HydratedCallButton. */
        interface IHydratedCallButton {

            /** HydratedCallButton displayText */
            displayText?: (string|null);

            /** HydratedCallButton phoneNumber */
            phoneNumber?: (string|null);
        }

        /** Representa un HydratedCallButton. */
        class HydratedCallButton implements IHydratedCallButton {

            /**
             * Construya un nuevo HydratedCallButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HydratedTemplateButton.IHydratedCallButton);

            /** HydratedCallButton displayText. */
            public displayText: string;

            /** HydratedCallButton phoneNumber. */
            public phoneNumber: string;

            /**
             * Crea una nueva instancia HydratedCallButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HydratedCallButton instance
             */
            public static create(properties?: proto.HydratedTemplateButton.IHydratedCallButton): proto.HydratedTemplateButton.HydratedCallButton;

            /**
             * Codifica el mensaje HydratedCallButton. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedCallButton.verify|verify}.
             * @param message HydratedCallButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HydratedTemplateButton.IHydratedCallButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HydratedCallButton message, delimitado por longitud. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedCallButton.verify|verify}.
             * @param message HydratedCallButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HydratedTemplateButton.IHydratedCallButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HydratedCallButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HydratedCallButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HydratedTemplateButton.HydratedCallButton;

            /**
             * Decodes a HydratedCallButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HydratedCallButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HydratedTemplateButton.HydratedCallButton;

            /**
             * Verifies a HydratedCallButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HydratedCallButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HydratedCallButton
             */
            public static fromObject(object: { [k: string]: any }): proto.HydratedTemplateButton.HydratedCallButton;

            /**
             * Crea un objeto simple desde HydratedCallButton. También convierte valores a otros tipos si se especifica.
             * @param message HydratedCallButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HydratedTemplateButton.HydratedCallButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HydratedCallButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un HydratedQuickReplyButton. */
        interface IHydratedQuickReplyButton {

            /** HydratedQuickReplyButton displayText */
            displayText?: (string|null);

            /** HydratedQuickReplyButton id */
            id?: (string|null);
        }

        /** Representa un HydratedQuickReplyButton. */
        class HydratedQuickReplyButton implements IHydratedQuickReplyButton {

            /**
             * Construya un nuevo HydratedQuickReplyButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HydratedTemplateButton.IHydratedQuickReplyButton);

            /** HydratedQuickReplyButton displayText. */
            public displayText: string;

            /** HydratedQuickReplyButton id. */
            public id: string;

            /**
             * Crea una nueva instancia HydratedQuickReplyButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HydratedQuickReplyButton instance
             */
            public static create(properties?: proto.HydratedTemplateButton.IHydratedQuickReplyButton): proto.HydratedTemplateButton.HydratedQuickReplyButton;

            /**
             * Codifica el mensaje HydratedQuickReplyButton. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedQuickReplyButton.verify|verify}.
             * @param message HydratedQuickReplyButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HydratedTemplateButton.IHydratedQuickReplyButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HydratedQuickReplyButton message, delimitado por longitud. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedQuickReplyButton.verify|verify}.
             * @param message HydratedQuickReplyButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HydratedTemplateButton.IHydratedQuickReplyButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HydratedQuickReplyButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HydratedQuickReplyButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HydratedTemplateButton.HydratedQuickReplyButton;

            /**
             * Decodes a HydratedQuickReplyButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HydratedQuickReplyButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HydratedTemplateButton.HydratedQuickReplyButton;

            /**
             * Verifies a HydratedQuickReplyButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HydratedQuickReplyButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HydratedQuickReplyButton
             */
            public static fromObject(object: { [k: string]: any }): proto.HydratedTemplateButton.HydratedQuickReplyButton;

            /**
             * Crea un objeto simple desde HydratedQuickReplyButton. También convierte valores a otros tipos si se especifica.
             * @param message HydratedQuickReplyButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HydratedTemplateButton.HydratedQuickReplyButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HydratedQuickReplyButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un HydratedURLButton. */
        interface IHydratedURLButton {

            /** HydratedURLButton displayText */
            displayText?: (string|null);

            /** HydratedURLButton url */
            url?: (string|null);
        }

        /** Representa un HydratedURLButton. */
        class HydratedURLButton implements IHydratedURLButton {

            /**
             * Construya un nuevo HydratedURLButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.HydratedTemplateButton.IHydratedURLButton);

            /** HydratedURLButton displayText. */
            public displayText: string;

            /** HydratedURLButton url. */
            public url: string;

            /**
             * Crea una nueva instancia HydratedURLButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HydratedURLButton instance
             */
            public static create(properties?: proto.HydratedTemplateButton.IHydratedURLButton): proto.HydratedTemplateButton.HydratedURLButton;

            /**
             * Codifica el mensaje HydratedURLButton. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedURLButton.verify|verify}.
             * @param message HydratedURLButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.HydratedTemplateButton.IHydratedURLButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HydratedURLButton message, delimitado por longitud. No implícitamente mensajes {@link proto.HydratedTemplateButton.HydratedURLButton.verify|verify}.
             * @param message HydratedURLButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.HydratedTemplateButton.IHydratedURLButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HydratedURLButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HydratedURLButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.HydratedTemplateButton.HydratedURLButton;

            /**
             * Decodes a HydratedURLButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HydratedURLButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.HydratedTemplateButton.HydratedURLButton;

            /**
             * Verifies a HydratedURLButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HydratedURLButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HydratedURLButton
             */
            public static fromObject(object: { [k: string]: any }): proto.HydratedTemplateButton.HydratedURLButton;

            /**
             * Crea un objeto simple desde HydratedURLButton. También convierte valores a otros tipos si se especifica.
             * @param message HydratedURLButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.HydratedTemplateButton.HydratedURLButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HydratedURLButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de unn IdentityKeyPairStructure. */
    interface IIdentityKeyPairStructure {

        /** IdentityKeyPairStructure publicKey */
        publicKey?: (Uint8Array|null);

        /** IdentityKeyPairStructure privateKey */
        privateKey?: (Uint8Array|null);
    }

    /** Representa unn IdentityKeyPairStructure. */
    class IdentityKeyPairStructure implements IIdentityKeyPairStructure {

        /**
         * Construya un nuevo IdentityKeyPairStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IIdentityKeyPairStructure);

        /** IdentityKeyPairStructure publicKey. */
        public publicKey: Uint8Array;

        /** IdentityKeyPairStructure privateKey. */
        public privateKey: Uint8Array;

        /**
         * Crea una nueva instancia IdentityKeyPairStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns IdentityKeyPairStructure instance
         */
        public static create(properties?: proto.IIdentityKeyPairStructure): proto.IdentityKeyPairStructure;

        /**
         * Codifica el mensaje IdentityKeyPairStructure. No implícitamente mensajes {@link proto.IdentityKeyPairStructure.verify|verify}.
         * @param message IdentityKeyPairStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IIdentityKeyPairStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje IdentityKeyPairStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.IdentityKeyPairStructure.verify|verify}.
         * @param message IdentityKeyPairStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IIdentityKeyPairStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an IdentityKeyPairStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns IdentityKeyPairStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.IdentityKeyPairStructure;

        /**
         * Decodes an IdentityKeyPairStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns IdentityKeyPairStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.IdentityKeyPairStructure;

        /**
         * Verifies an IdentityKeyPairStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an IdentityKeyPairStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns IdentityKeyPairStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.IdentityKeyPairStructure;

        /**
         * Crea un objeto simple desden IdentityKeyPairStructure. También convierte valores a otros tipos si se especifica.
         * @param message IdentityKeyPairStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.IdentityKeyPairStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  IdentityKeyPairStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de unn InteractiveAnnotation. */
    interface IInteractiveAnnotation {

        /** InteractiveAnnotation polygonVertices */
        polygonVertices?: (proto.IPoint[]|null);

        /** InteractiveAnnotation location */
        location?: (proto.ILocation|null);
    }

    /** Representa unn InteractiveAnnotation. */
    class InteractiveAnnotation implements IInteractiveAnnotation {

        /**
         * Construya un nuevo InteractiveAnnotation.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IInteractiveAnnotation);

        /** InteractiveAnnotation polygonVertices. */
        public polygonVertices: proto.IPoint[];

        /** InteractiveAnnotation location. */
        public location?: (proto.ILocation|null);

        /** InteractiveAnnotation action. */
        public action?: "location";

        /**
         * Crea una nueva instancia InteractiveAnnotation utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns InteractiveAnnotation instance
         */
        public static create(properties?: proto.IInteractiveAnnotation): proto.InteractiveAnnotation;

        /**
         * Codifica el mensaje InteractiveAnnotation. No implícitamente mensajes {@link proto.InteractiveAnnotation.verify|verify}.
         * @param message InteractiveAnnotation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IInteractiveAnnotation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje InteractiveAnnotation message, delimitado por longitud. No implícitamente mensajes {@link proto.InteractiveAnnotation.verify|verify}.
         * @param message InteractiveAnnotation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IInteractiveAnnotation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an InteractiveAnnotation message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns InteractiveAnnotation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.InteractiveAnnotation;

        /**
         * Decodes an InteractiveAnnotation message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns InteractiveAnnotation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.InteractiveAnnotation;

        /**
         * Verifies an InteractiveAnnotation message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an InteractiveAnnotation message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns InteractiveAnnotation
         */
        public static fromObject(object: { [k: string]: any }): proto.InteractiveAnnotation;

        /**
         * Crea un objeto simple desden InteractiveAnnotation. También convierte valores a otros tipos si se especifica.
         * @param message InteractiveAnnotation
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.InteractiveAnnotation, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  InteractiveAnnotation a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un KeepInChat. */
    interface IKeepInChat {

        /** KeepInChat keepType */
        keepType?: (proto.KeepType|null);

        /** KeepInChat serverTimestamp */
        serverTimestamp?: (number|Long|null);

        /** KeepInChat key */
        key?: (proto.IMessageKey|null);

        /** KeepInChat deviceJid */
        deviceJid?: (string|null);

        /** KeepInChat clientTimestampMs */
        clientTimestampMs?: (number|Long|null);

        /** KeepInChat serverTimestampMs */
        serverTimestampMs?: (number|Long|null);
    }

    /** Representa un KeepInChat. */
    class KeepInChat implements IKeepInChat {

        /**
         * Construya un nuevo KeepInChat.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IKeepInChat);

        /** KeepInChat keepType. */
        public keepType: proto.KeepType;

        /** KeepInChat serverTimestamp. */
        public serverTimestamp: (number|Long);

        /** KeepInChat key. */
        public key?: (proto.IMessageKey|null);

        /** KeepInChat deviceJid. */
        public deviceJid: string;

        /** KeepInChat clientTimestampMs. */
        public clientTimestampMs: (number|Long);

        /** KeepInChat serverTimestampMs. */
        public serverTimestampMs: (number|Long);

        /**
         * Crea una nueva instancia KeepInChat utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns KeepInChat instance
         */
        public static create(properties?: proto.IKeepInChat): proto.KeepInChat;

        /**
         * Codifica el mensaje KeepInChat. No implícitamente mensajes {@link proto.KeepInChat.verify|verify}.
         * @param message KeepInChat mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IKeepInChat, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje KeepInChat message, delimitado por longitud. No implícitamente mensajes {@link proto.KeepInChat.verify|verify}.
         * @param message KeepInChat mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IKeepInChat, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a KeepInChat message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns KeepInChat
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.KeepInChat;

        /**
         * Decodes a KeepInChat message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns KeepInChat
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.KeepInChat;

        /**
         * Verifies a KeepInChat message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a KeepInChat message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns KeepInChat
         */
        public static fromObject(object: { [k: string]: any }): proto.KeepInChat;

        /**
         * Crea un objeto simple desde KeepInChat. También convierte valores a otros tipos si se especifica.
         * @param message KeepInChat
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.KeepInChat, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  KeepInChat a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** KeepType enum. */
    enum KeepType {
        UNKNOWN = 0,
        KEEP_FOR_ALL = 1,
        UNDO_KEEP_FOR_ALL = 2
    }

    /** Propiedades de un KeyId. */
    interface IKeyId {

        /** KeyId id */
        id?: (Uint8Array|null);
    }

    /** Representa un KeyId. */
    class KeyId implements IKeyId {

        /**
         * Construya un nuevo KeyId.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IKeyId);

        /** KeyId id. */
        public id: Uint8Array;

        /**
         * Crea una nueva instancia KeyId utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns KeyId instance
         */
        public static create(properties?: proto.IKeyId): proto.KeyId;

        /**
         * Codifica el mensaje KeyId. No implícitamente mensajes {@link proto.KeyId.verify|verify}.
         * @param message KeyId mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IKeyId, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje KeyId message, delimitado por longitud. No implícitamente mensajes {@link proto.KeyId.verify|verify}.
         * @param message KeyId mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IKeyId, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a KeyId message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns KeyId
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.KeyId;

        /**
         * Decodes a KeyId message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns KeyId
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.KeyId;

        /**
         * Verifies a KeyId message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a KeyId message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns KeyId
         */
        public static fromObject(object: { [k: string]: any }): proto.KeyId;

        /**
         * Crea un objeto simple desde KeyId. También convierte valores a otros tipos si se especifica.
         * @param message KeyId
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.KeyId, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  KeyId a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un LocalizedName. */
    interface ILocalizedName {

        /** LocalizedName lg */
        lg?: (string|null);

        /** LocalizedName lc */
        lc?: (string|null);

        /** LocalizedName verifiedName */
        verifiedName?: (string|null);
    }

    /** Representa un LocalizedName. */
    class LocalizedName implements ILocalizedName {

        /**
         * Construya un nuevo LocalizedName.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ILocalizedName);

        /** LocalizedName lg. */
        public lg: string;

        /** LocalizedName lc. */
        public lc: string;

        /** LocalizedName verifiedName. */
        public verifiedName: string;

        /**
         * Crea una nueva instancia LocalizedName utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns LocalizedName instance
         */
        public static create(properties?: proto.ILocalizedName): proto.LocalizedName;

        /**
         * Codifica el mensaje LocalizedName. No implícitamente mensajes {@link proto.LocalizedName.verify|verify}.
         * @param message LocalizedName mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ILocalizedName, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje LocalizedName message, delimitado por longitud. No implícitamente mensajes {@link proto.LocalizedName.verify|verify}.
         * @param message LocalizedName mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ILocalizedName, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a LocalizedName message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns LocalizedName
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.LocalizedName;

        /**
         * Decodes a LocalizedName message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns LocalizedName
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.LocalizedName;

        /**
         * Verifies a LocalizedName message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a LocalizedName message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns LocalizedName
         */
        public static fromObject(object: { [k: string]: any }): proto.LocalizedName;

        /**
         * Crea un objeto simple desde LocalizedName. También convierte valores a otros tipos si se especifica.
         * @param message LocalizedName
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.LocalizedName, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  LocalizedName a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un Location. */
    interface ILocation {

        /** Location degreesLatitude */
        degreesLatitude?: (number|null);

        /** Location degreesLongitude */
        degreesLongitude?: (number|null);

        /** Location name */
        name?: (string|null);
    }

    /** Representa un Location. */
    class Location implements ILocation {

        /**
         * Construya un nuevo Location.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ILocation);

        /** Location degreesLatitude. */
        public degreesLatitude: number;

        /** Location degreesLongitude. */
        public degreesLongitude: number;

        /** Location name. */
        public name: string;

        /**
         * Crea una nueva instancia Location utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Location instance
         */
        public static create(properties?: proto.ILocation): proto.Location;

        /**
         * Codifica el mensaje Location. No implícitamente mensajes {@link proto.Location.verify|verify}.
         * @param message Location mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ILocation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Location message, delimitado por longitud. No implícitamente mensajes {@link proto.Location.verify|verify}.
         * @param message Location mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ILocation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Location
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Location;

        /**
         * Decodes a Location message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Location
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Location;

        /**
         * Verifies a Location message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Location message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Location
         */
        public static fromObject(object: { [k: string]: any }): proto.Location;

        /**
         * Crea un objeto simple desde Location. También convierte valores a otros tipos si se especifica.
         * @param message Location
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Location, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Location a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un MediaData. */
    interface IMediaData {

        /** MediaData localPath */
        localPath?: (string|null);
    }

    /** Representa un MediaData. */
    class MediaData implements IMediaData {

        /**
         * Construya un nuevo MediaData.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMediaData);

        /** MediaData localPath. */
        public localPath: string;

        /**
         * Crea una nueva instancia MediaData utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MediaData instance
         */
        public static create(properties?: proto.IMediaData): proto.MediaData;

        /**
         * Codifica el mensaje MediaData. No implícitamente mensajes {@link proto.MediaData.verify|verify}.
         * @param message MediaData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMediaData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MediaData message, delimitado por longitud. No implícitamente mensajes {@link proto.MediaData.verify|verify}.
         * @param message MediaData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMediaData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MediaData message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MediaData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MediaData;

        /**
         * Decodes a MediaData message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MediaData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MediaData;

        /**
         * Verifies a MediaData message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MediaData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MediaData
         */
        public static fromObject(object: { [k: string]: any }): proto.MediaData;

        /**
         * Crea un objeto simple desde MediaData. También convierte valores a otros tipos si se especifica.
         * @param message MediaData
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MediaData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MediaData a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un MediaRetryNotification. */
    interface IMediaRetryNotification {

        /** MediaRetryNotification stanzaId */
        stanzaId?: (string|null);

        /** MediaRetryNotification directPath */
        directPath?: (string|null);

        /** MediaRetryNotification result */
        result?: (proto.MediaRetryNotification.ResultType|null);
    }

    /** Representa un MediaRetryNotification. */
    class MediaRetryNotification implements IMediaRetryNotification {

        /**
         * Construya un nuevo MediaRetryNotification.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMediaRetryNotification);

        /** MediaRetryNotification stanzaId. */
        public stanzaId: string;

        /** MediaRetryNotification directPath. */
        public directPath: string;

        /** MediaRetryNotification result. */
        public result: proto.MediaRetryNotification.ResultType;

        /**
         * Crea una nueva instancia MediaRetryNotification utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MediaRetryNotification instance
         */
        public static create(properties?: proto.IMediaRetryNotification): proto.MediaRetryNotification;

        /**
         * Codifica el mensaje MediaRetryNotification. No implícitamente mensajes {@link proto.MediaRetryNotification.verify|verify}.
         * @param message MediaRetryNotification mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMediaRetryNotification, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MediaRetryNotification message, delimitado por longitud. No implícitamente mensajes {@link proto.MediaRetryNotification.verify|verify}.
         * @param message MediaRetryNotification mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMediaRetryNotification, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MediaRetryNotification message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MediaRetryNotification
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MediaRetryNotification;

        /**
         * Decodes a MediaRetryNotification message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MediaRetryNotification
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MediaRetryNotification;

        /**
         * Verifies a MediaRetryNotification message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MediaRetryNotification message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MediaRetryNotification
         */
        public static fromObject(object: { [k: string]: any }): proto.MediaRetryNotification;

        /**
         * Crea un objeto simple desde MediaRetryNotification. También convierte valores a otros tipos si se especifica.
         * @param message MediaRetryNotification
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MediaRetryNotification, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MediaRetryNotification a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace MediaRetryNotification {

        /** ResultType enum. */
        enum ResultType {
            GENERAL_ERROR = 0,
            SUCCESS = 1,
            NOT_FOUND = 2,
            DECRYPTION_ERROR = 3
        }
    }

    /** MediaVisibility enum. */
    enum MediaVisibility {
        DEFAULT = 0,
        OFF = 1,
        ON = 2
    }

    /** Propiedades de un Message. */
    interface IMessage {

        /** Message conversation */
        conversation?: (string|null);

        /** Message senderKeyDistributionMessage */
        senderKeyDistributionMessage?: (proto.Message.ISenderKeyDistributionMessage|null);

        /** Message imageMessage */
        imageMessage?: (proto.Message.IImageMessage|null);

        /** Message contactMessage */
        contactMessage?: (proto.Message.IContactMessage|null);

        /** Message locationMessage */
        locationMessage?: (proto.Message.ILocationMessage|null);

        /** Message extendedTextMessage */
        extendedTextMessage?: (proto.Message.IExtendedTextMessage|null);

        /** Message documentMessage */
        documentMessage?: (proto.Message.IDocumentMessage|null);

        /** Message audioMessage */
        audioMessage?: (proto.Message.IAudioMessage|null);

        /** Message videoMessage */
        videoMessage?: (proto.Message.IVideoMessage|null);

        /** Message call */
        call?: (proto.Message.ICall|null);

        /** Message chat */
        chat?: (proto.Message.IChat|null);

        /** Message protocolMessage */
        protocolMessage?: (proto.Message.IProtocolMessage|null);

        /** Message contactsArrayMessage */
        contactsArrayMessage?: (proto.Message.IContactsArrayMessage|null);

        /** Message highlyStructuredMessage */
        highlyStructuredMessage?: (proto.Message.IHighlyStructuredMessage|null);

        /** Message fastRatchetKeySenderKeyDistributionMessage */
        fastRatchetKeySenderKeyDistributionMessage?: (proto.Message.ISenderKeyDistributionMessage|null);

        /** Message sendPaymentMessage */
        sendPaymentMessage?: (proto.Message.ISendPaymentMessage|null);

        /** Message liveLocationMessage */
        liveLocationMessage?: (proto.Message.ILiveLocationMessage|null);

        /** Message requestPaymentMessage */
        requestPaymentMessage?: (proto.Message.IRequestPaymentMessage|null);

        /** Message declinePaymentRequestMessage */
        declinePaymentRequestMessage?: (proto.Message.IDeclinePaymentRequestMessage|null);

        /** Message cancelPaymentRequestMessage */
        cancelPaymentRequestMessage?: (proto.Message.ICancelPaymentRequestMessage|null);

        /** Message templateMessage */
        templateMessage?: (proto.Message.ITemplateMessage|null);

        /** Message stickerMessage */
        stickerMessage?: (proto.Message.IStickerMessage|null);

        /** Message groupInviteMessage */
        groupInviteMessage?: (proto.Message.IGroupInviteMessage|null);

        /** Message templateButtonReplyMessage */
        templateButtonReplyMessage?: (proto.Message.ITemplateButtonReplyMessage|null);

        /** Message productMessage */
        productMessage?: (proto.Message.IProductMessage|null);

        /** Message deviceSentMessage */
        deviceSentMessage?: (proto.Message.IDeviceSentMessage|null);

        /** Message messageContextInfo */
        messageContextInfo?: (proto.IMessageContextInfo|null);

        /** Message listMessage */
        listMessage?: (proto.Message.IListMessage|null);

        /** Message viewOnceMessage */
        viewOnceMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message orderMessage */
        orderMessage?: (proto.Message.IOrderMessage|null);

        /** Message listResponseMessage */
        listResponseMessage?: (proto.Message.IListResponseMessage|null);

        /** Message ephemeralMessage */
        ephemeralMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message invoiceMessage */
        invoiceMessage?: (proto.Message.IInvoiceMessage|null);

        /** Message buttonsMessage */
        buttonsMessage?: (proto.Message.IButtonsMessage|null);

        /** Message buttonsResponseMessage */
        buttonsResponseMessage?: (proto.Message.IButtonsResponseMessage|null);

        /** Message paymentInviteMessage */
        paymentInviteMessage?: (proto.Message.IPaymentInviteMessage|null);

        /** Message interactiveMessage */
        interactiveMessage?: (proto.Message.IInteractiveMessage|null);

        /** Message reactionMessage */
        reactionMessage?: (proto.Message.IReactionMessage|null);

        /** Message stickerSyncRmrMessage */
        stickerSyncRmrMessage?: (proto.Message.IStickerSyncRMRMessage|null);

        /** Message interactiveResponseMessage */
        interactiveResponseMessage?: (proto.Message.IInteractiveResponseMessage|null);

        /** Message pollCreationMessage */
        pollCreationMessage?: (proto.Message.IPollCreationMessage|null);

        /** Message pollUpdateMessage */
        pollUpdateMessage?: (proto.Message.IPollUpdateMessage|null);

        /** Message keepInChatMessage */
        keepInChatMessage?: (proto.Message.IKeepInChatMessage|null);

        /** Message documentWithCaptionMessage */
        documentWithCaptionMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message requestPhoneNumberMessage */
        requestPhoneNumberMessage?: (proto.Message.IRequestPhoneNumberMessage|null);

        /** Message viewOnceMessageV2 */
        viewOnceMessageV2?: (proto.Message.IFutureProofMessage|null);

        /** Message encReactionMessage */
        encReactionMessage?: (proto.Message.IEncReactionMessage|null);

        /** Message editedMessage */
        editedMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message viewOnceMessageV2Extension */
        viewOnceMessageV2Extension?: (proto.Message.IFutureProofMessage|null);

        /** Message pollCreationMessageV2 */
        pollCreationMessageV2?: (proto.Message.IPollCreationMessage|null);

        /** Message scheduledCallCreationMessage */
        scheduledCallCreationMessage?: (proto.Message.IScheduledCallCreationMessage|null);

        /** Message groupMentionedMessage */
        groupMentionedMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message pinMessage */
        pinMessage?: (proto.Message.IPinMessage|null);

        /** Message pollCreationMessageV3 */
        pollCreationMessageV3?: (proto.Message.IPollCreationMessage|null);

        /** Message scheduledCallEditMessage */
        scheduledCallEditMessage?: (proto.Message.IScheduledCallEditMessage|null);

        /** Message ptvMessage */
        ptvMessage?: (proto.Message.IVideoMessage|null);
    }

    /** Representa un Message. */
    class Message implements IMessage {

        /**
         * Construya un nuevo Message.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMessage);

        /** Message conversation. */
        public conversation: string;

        /** Message senderKeyDistributionMessage. */
        public senderKeyDistributionMessage?: (proto.Message.ISenderKeyDistributionMessage|null);

        /** Message imageMessage. */
        public imageMessage?: (proto.Message.IImageMessage|null);

        /** Message contactMessage. */
        public contactMessage?: (proto.Message.IContactMessage|null);

        /** Message locationMessage. */
        public locationMessage?: (proto.Message.ILocationMessage|null);

        /** Message extendedTextMessage. */
        public extendedTextMessage?: (proto.Message.IExtendedTextMessage|null);

        /** Message documentMessage. */
        public documentMessage?: (proto.Message.IDocumentMessage|null);

        /** Message audioMessage. */
        public audioMessage?: (proto.Message.IAudioMessage|null);

        /** Message videoMessage. */
        public videoMessage?: (proto.Message.IVideoMessage|null);

        /** Message call. */
        public call?: (proto.Message.ICall|null);

        /** Message chat. */
        public chat?: (proto.Message.IChat|null);

        /** Message protocolMessage. */
        public protocolMessage?: (proto.Message.IProtocolMessage|null);

        /** Message contactsArrayMessage. */
        public contactsArrayMessage?: (proto.Message.IContactsArrayMessage|null);

        /** Message highlyStructuredMessage. */
        public highlyStructuredMessage?: (proto.Message.IHighlyStructuredMessage|null);

        /** Message fastRatchetKeySenderKeyDistributionMessage. */
        public fastRatchetKeySenderKeyDistributionMessage?: (proto.Message.ISenderKeyDistributionMessage|null);

        /** Message sendPaymentMessage. */
        public sendPaymentMessage?: (proto.Message.ISendPaymentMessage|null);

        /** Message liveLocationMessage. */
        public liveLocationMessage?: (proto.Message.ILiveLocationMessage|null);

        /** Message requestPaymentMessage. */
        public requestPaymentMessage?: (proto.Message.IRequestPaymentMessage|null);

        /** Message declinePaymentRequestMessage. */
        public declinePaymentRequestMessage?: (proto.Message.IDeclinePaymentRequestMessage|null);

        /** Message cancelPaymentRequestMessage. */
        public cancelPaymentRequestMessage?: (proto.Message.ICancelPaymentRequestMessage|null);

        /** Message templateMessage. */
        public templateMessage?: (proto.Message.ITemplateMessage|null);

        /** Message stickerMessage. */
        public stickerMessage?: (proto.Message.IStickerMessage|null);

        /** Message groupInviteMessage. */
        public groupInviteMessage?: (proto.Message.IGroupInviteMessage|null);

        /** Message templateButtonReplyMessage. */
        public templateButtonReplyMessage?: (proto.Message.ITemplateButtonReplyMessage|null);

        /** Message productMessage. */
        public productMessage?: (proto.Message.IProductMessage|null);

        /** Message deviceSentMessage. */
        public deviceSentMessage?: (proto.Message.IDeviceSentMessage|null);

        /** Message messageContextInfo. */
        public messageContextInfo?: (proto.IMessageContextInfo|null);

        /** Message listMessage. */
        public listMessage?: (proto.Message.IListMessage|null);

        /** Message viewOnceMessage. */
        public viewOnceMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message orderMessage. */
        public orderMessage?: (proto.Message.IOrderMessage|null);

        /** Message listResponseMessage. */
        public listResponseMessage?: (proto.Message.IListResponseMessage|null);

        /** Message ephemeralMessage. */
        public ephemeralMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message invoiceMessage. */
        public invoiceMessage?: (proto.Message.IInvoiceMessage|null);

        /** Message buttonsMessage. */
        public buttonsMessage?: (proto.Message.IButtonsMessage|null);

        /** Message buttonsResponseMessage. */
        public buttonsResponseMessage?: (proto.Message.IButtonsResponseMessage|null);

        /** Message paymentInviteMessage. */
        public paymentInviteMessage?: (proto.Message.IPaymentInviteMessage|null);

        /** Message interactiveMessage. */
        public interactiveMessage?: (proto.Message.IInteractiveMessage|null);

        /** Message reactionMessage. */
        public reactionMessage?: (proto.Message.IReactionMessage|null);

        /** Message stickerSyncRmrMessage. */
        public stickerSyncRmrMessage?: (proto.Message.IStickerSyncRMRMessage|null);

        /** Message interactiveResponseMessage. */
        public interactiveResponseMessage?: (proto.Message.IInteractiveResponseMessage|null);

        /** Message pollCreationMessage. */
        public pollCreationMessage?: (proto.Message.IPollCreationMessage|null);

        /** Message pollUpdateMessage. */
        public pollUpdateMessage?: (proto.Message.IPollUpdateMessage|null);

        /** Message keepInChatMessage. */
        public keepInChatMessage?: (proto.Message.IKeepInChatMessage|null);

        /** Message documentWithCaptionMessage. */
        public documentWithCaptionMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message requestPhoneNumberMessage. */
        public requestPhoneNumberMessage?: (proto.Message.IRequestPhoneNumberMessage|null);

        /** Message viewOnceMessageV2. */
        public viewOnceMessageV2?: (proto.Message.IFutureProofMessage|null);

        /** Message encReactionMessage. */
        public encReactionMessage?: (proto.Message.IEncReactionMessage|null);

        /** Message editedMessage. */
        public editedMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message viewOnceMessageV2Extension. */
        public viewOnceMessageV2Extension?: (proto.Message.IFutureProofMessage|null);

        /** Message pollCreationMessageV2. */
        public pollCreationMessageV2?: (proto.Message.IPollCreationMessage|null);

        /** Message scheduledCallCreationMessage. */
        public scheduledCallCreationMessage?: (proto.Message.IScheduledCallCreationMessage|null);

        /** Message groupMentionedMessage. */
        public groupMentionedMessage?: (proto.Message.IFutureProofMessage|null);

        /** Message pinMessage. */
        public pinMessage?: (proto.Message.IPinMessage|null);

        /** Message pollCreationMessageV3. */
        public pollCreationMessageV3?: (proto.Message.IPollCreationMessage|null);

        /** Message scheduledCallEditMessage. */
        public scheduledCallEditMessage?: (proto.Message.IScheduledCallEditMessage|null);

        /** Message ptvMessage. */
        public ptvMessage?: (proto.Message.IVideoMessage|null);

        /**
         * Crea una nueva instancia Message utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Message instance
         */
        public static create(properties?: proto.IMessage): proto.Message;

        /**
         * Codifica el mensaje Message. No implícitamente mensajes {@link proto.Message.verify|verify}.
         * @param message Message mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Message message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.verify|verify}.
         * @param message Message mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Message
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message;

        /**
         * Decodes a Message message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Message
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message;

        /**
         * Verifies a Message message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Message message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Message
         */
        public static fromObject(object: { [k: string]: any }): proto.Message;

        /**
         * Crea un objeto simple desde Message. También convierte valores a otros tipos si se especifica.
         * @param message Message
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Message, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Message a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace Message {

        /** Propiedades de unn AppStateFatalExceptionNotification. */
        interface IAppStateFatalExceptionNotification {

            /** AppStateFatalExceptionNotification collectionNames */
            collectionNames?: (string[]|null);

            /** AppStateFatalExceptionNotification timestamp */
            timestamp?: (number|Long|null);
        }

        /** Representa unn AppStateFatalExceptionNotification. */
        class AppStateFatalExceptionNotification implements IAppStateFatalExceptionNotification {

            /**
             * Construya un nuevo AppStateFatalExceptionNotification.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateFatalExceptionNotification);

            /** AppStateFatalExceptionNotification collectionNames. */
            public collectionNames: string[];

            /** AppStateFatalExceptionNotification timestamp. */
            public timestamp: (number|Long);

            /**
             * Crea una nueva instancia AppStateFatalExceptionNotification utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateFatalExceptionNotification instance
             */
            public static create(properties?: proto.Message.IAppStateFatalExceptionNotification): proto.Message.AppStateFatalExceptionNotification;

            /**
             * Codifica el mensaje AppStateFatalExceptionNotification. No implícitamente mensajes {@link proto.Message.AppStateFatalExceptionNotification.verify|verify}.
             * @param message AppStateFatalExceptionNotification mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateFatalExceptionNotification, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateFatalExceptionNotification message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateFatalExceptionNotification.verify|verify}.
             * @param message AppStateFatalExceptionNotification mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateFatalExceptionNotification, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateFatalExceptionNotification message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateFatalExceptionNotification
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateFatalExceptionNotification;

            /**
             * Decodes an AppStateFatalExceptionNotification message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateFatalExceptionNotification
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateFatalExceptionNotification;

            /**
             * Verifies an AppStateFatalExceptionNotification message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateFatalExceptionNotification message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateFatalExceptionNotification
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateFatalExceptionNotification;

            /**
             * Crea un objeto simple desden AppStateFatalExceptionNotification. También convierte valores a otros tipos si se especifica.
             * @param message AppStateFatalExceptionNotification
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateFatalExceptionNotification, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateFatalExceptionNotification a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKey. */
        interface IAppStateSyncKey {

            /** AppStateSyncKey keyId */
            keyId?: (proto.Message.IAppStateSyncKeyId|null);

            /** AppStateSyncKey keyData */
            keyData?: (proto.Message.IAppStateSyncKeyData|null);
        }

        /** Representa unn AppStateSyncKey. */
        class AppStateSyncKey implements IAppStateSyncKey {

            /**
             * Construya un nuevo AppStateSyncKey.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKey);

            /** AppStateSyncKey keyId. */
            public keyId?: (proto.Message.IAppStateSyncKeyId|null);

            /** AppStateSyncKey keyData. */
            public keyData?: (proto.Message.IAppStateSyncKeyData|null);

            /**
             * Crea una nueva instancia AppStateSyncKey utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKey instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKey): proto.Message.AppStateSyncKey;

            /**
             * Codifica el mensaje AppStateSyncKey. No implícitamente mensajes {@link proto.Message.AppStateSyncKey.verify|verify}.
             * @param message AppStateSyncKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKey message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKey.verify|verify}.
             * @param message AppStateSyncKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKey message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKey;

            /**
             * Decodes an AppStateSyncKey message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKey;

            /**
             * Verifies an AppStateSyncKey message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKey
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKey;

            /**
             * Crea un objeto simple desden AppStateSyncKey. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKey
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKey a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKeyData. */
        interface IAppStateSyncKeyData {

            /** AppStateSyncKeyData keyData */
            keyData?: (Uint8Array|null);

            /** AppStateSyncKeyData fingerprint */
            fingerprint?: (proto.Message.IAppStateSyncKeyFingerprint|null);

            /** AppStateSyncKeyData timestamp */
            timestamp?: (number|Long|null);
        }

        /** Representa unn AppStateSyncKeyData. */
        class AppStateSyncKeyData implements IAppStateSyncKeyData {

            /**
             * Construya un nuevo AppStateSyncKeyData.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKeyData);

            /** AppStateSyncKeyData keyData. */
            public keyData: Uint8Array;

            /** AppStateSyncKeyData fingerprint. */
            public fingerprint?: (proto.Message.IAppStateSyncKeyFingerprint|null);

            /** AppStateSyncKeyData timestamp. */
            public timestamp: (number|Long);

            /**
             * Crea una nueva instancia AppStateSyncKeyData utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKeyData instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKeyData): proto.Message.AppStateSyncKeyData;

            /**
             * Codifica el mensaje AppStateSyncKeyData. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyData.verify|verify}.
             * @param message AppStateSyncKeyData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKeyData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKeyData message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyData.verify|verify}.
             * @param message AppStateSyncKeyData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKeyData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKeyData message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKeyData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKeyData;

            /**
             * Decodes an AppStateSyncKeyData message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKeyData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKeyData;

            /**
             * Verifies an AppStateSyncKeyData message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKeyData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKeyData
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKeyData;

            /**
             * Crea un objeto simple desden AppStateSyncKeyData. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKeyData
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKeyData, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKeyData a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKeyFingerprint. */
        interface IAppStateSyncKeyFingerprint {

            /** AppStateSyncKeyFingerprint rawId */
            rawId?: (number|null);

            /** AppStateSyncKeyFingerprint currentIndex */
            currentIndex?: (number|null);

            /** AppStateSyncKeyFingerprint deviceIndexes */
            deviceIndexes?: (number[]|null);
        }

        /** Representa unn AppStateSyncKeyFingerprint. */
        class AppStateSyncKeyFingerprint implements IAppStateSyncKeyFingerprint {

            /**
             * Construya un nuevo AppStateSyncKeyFingerprint.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKeyFingerprint);

            /** AppStateSyncKeyFingerprint rawId. */
            public rawId: number;

            /** AppStateSyncKeyFingerprint currentIndex. */
            public currentIndex: number;

            /** AppStateSyncKeyFingerprint deviceIndexes. */
            public deviceIndexes: number[];

            /**
             * Crea una nueva instancia AppStateSyncKeyFingerprint utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKeyFingerprint instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKeyFingerprint): proto.Message.AppStateSyncKeyFingerprint;

            /**
             * Codifica el mensaje AppStateSyncKeyFingerprint. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyFingerprint.verify|verify}.
             * @param message AppStateSyncKeyFingerprint mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKeyFingerprint, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKeyFingerprint message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyFingerprint.verify|verify}.
             * @param message AppStateSyncKeyFingerprint mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKeyFingerprint, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKeyFingerprint message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKeyFingerprint
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKeyFingerprint;

            /**
             * Decodes an AppStateSyncKeyFingerprint message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKeyFingerprint
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKeyFingerprint;

            /**
             * Verifies an AppStateSyncKeyFingerprint message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKeyFingerprint message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKeyFingerprint
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKeyFingerprint;

            /**
             * Crea un objeto simple desden AppStateSyncKeyFingerprint. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKeyFingerprint
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKeyFingerprint, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKeyFingerprint a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKeyId. */
        interface IAppStateSyncKeyId {

            /** AppStateSyncKeyId keyId */
            keyId?: (Uint8Array|null);
        }

        /** Representa unn AppStateSyncKeyId. */
        class AppStateSyncKeyId implements IAppStateSyncKeyId {

            /**
             * Construya un nuevo AppStateSyncKeyId.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKeyId);

            /** AppStateSyncKeyId keyId. */
            public keyId: Uint8Array;

            /**
             * Crea una nueva instancia AppStateSyncKeyId utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKeyId instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKeyId): proto.Message.AppStateSyncKeyId;

            /**
             * Codifica el mensaje AppStateSyncKeyId. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyId.verify|verify}.
             * @param message AppStateSyncKeyId mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKeyId, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKeyId message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyId.verify|verify}.
             * @param message AppStateSyncKeyId mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKeyId, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKeyId message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKeyId
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKeyId;

            /**
             * Decodes an AppStateSyncKeyId message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKeyId
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKeyId;

            /**
             * Verifies an AppStateSyncKeyId message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKeyId message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKeyId
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKeyId;

            /**
             * Crea un objeto simple desden AppStateSyncKeyId. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKeyId
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKeyId, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKeyId a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKeyRequest. */
        interface IAppStateSyncKeyRequest {

            /** AppStateSyncKeyRequest keyIds */
            keyIds?: (proto.Message.IAppStateSyncKeyId[]|null);
        }

        /** Representa unn AppStateSyncKeyRequest. */
        class AppStateSyncKeyRequest implements IAppStateSyncKeyRequest {

            /**
             * Construya un nuevo AppStateSyncKeyRequest.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKeyRequest);

            /** AppStateSyncKeyRequest keyIds. */
            public keyIds: proto.Message.IAppStateSyncKeyId[];

            /**
             * Crea una nueva instancia AppStateSyncKeyRequest utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKeyRequest instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKeyRequest): proto.Message.AppStateSyncKeyRequest;

            /**
             * Codifica el mensaje AppStateSyncKeyRequest. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyRequest.verify|verify}.
             * @param message AppStateSyncKeyRequest mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKeyRequest, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKeyRequest message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyRequest.verify|verify}.
             * @param message AppStateSyncKeyRequest mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKeyRequest, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKeyRequest message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKeyRequest
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKeyRequest;

            /**
             * Decodes an AppStateSyncKeyRequest message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKeyRequest
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKeyRequest;

            /**
             * Verifies an AppStateSyncKeyRequest message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKeyRequest message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKeyRequest
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKeyRequest;

            /**
             * Crea un objeto simple desden AppStateSyncKeyRequest. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKeyRequest
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKeyRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKeyRequest a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AppStateSyncKeyShare. */
        interface IAppStateSyncKeyShare {

            /** AppStateSyncKeyShare keys */
            keys?: (proto.Message.IAppStateSyncKey[]|null);
        }

        /** Representa unn AppStateSyncKeyShare. */
        class AppStateSyncKeyShare implements IAppStateSyncKeyShare {

            /**
             * Construya un nuevo AppStateSyncKeyShare.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAppStateSyncKeyShare);

            /** AppStateSyncKeyShare keys. */
            public keys: proto.Message.IAppStateSyncKey[];

            /**
             * Crea una nueva instancia AppStateSyncKeyShare utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AppStateSyncKeyShare instance
             */
            public static create(properties?: proto.Message.IAppStateSyncKeyShare): proto.Message.AppStateSyncKeyShare;

            /**
             * Codifica el mensaje AppStateSyncKeyShare. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyShare.verify|verify}.
             * @param message AppStateSyncKeyShare mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAppStateSyncKeyShare, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AppStateSyncKeyShare message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AppStateSyncKeyShare.verify|verify}.
             * @param message AppStateSyncKeyShare mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAppStateSyncKeyShare, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AppStateSyncKeyShare message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AppStateSyncKeyShare
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AppStateSyncKeyShare;

            /**
             * Decodes an AppStateSyncKeyShare message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AppStateSyncKeyShare
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AppStateSyncKeyShare;

            /**
             * Verifies an AppStateSyncKeyShare message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AppStateSyncKeyShare message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AppStateSyncKeyShare
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AppStateSyncKeyShare;

            /**
             * Crea un objeto simple desden AppStateSyncKeyShare. También convierte valores a otros tipos si se especifica.
             * @param message AppStateSyncKeyShare
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AppStateSyncKeyShare, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AppStateSyncKeyShare a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AudioMessage. */
        interface IAudioMessage {

            /** AudioMessage url */
            url?: (string|null);

            /** AudioMessage mimetype */
            mimetype?: (string|null);

            /** AudioMessage fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** AudioMessage fileLength */
            fileLength?: (number|Long|null);

            /** AudioMessage seconds */
            seconds?: (number|null);

            /** AudioMessage ptt */
            ptt?: (boolean|null);

            /** AudioMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** AudioMessage fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** AudioMessage directPath */
            directPath?: (string|null);

            /** AudioMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** AudioMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** AudioMessage streamingSidecar */
            streamingSidecar?: (Uint8Array|null);

            /** AudioMessage waveform */
            waveform?: (Uint8Array|null);

            /** AudioMessage backgroundArgb */
            backgroundArgb?: (number|null);

            /** AudioMessage viewOnce */
            viewOnce?: (boolean|null);
        }

        /** Representa unn AudioMessage. */
        class AudioMessage implements IAudioMessage {

            /**
             * Construya un nuevo AudioMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IAudioMessage);

            /** AudioMessage url. */
            public url: string;

            /** AudioMessage mimetype. */
            public mimetype: string;

            /** AudioMessage fileSha256. */
            public fileSha256: Uint8Array;

            /** AudioMessage fileLength. */
            public fileLength: (number|Long);

            /** AudioMessage seconds. */
            public seconds: number;

            /** AudioMessage ptt. */
            public ptt: boolean;

            /** AudioMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** AudioMessage fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** AudioMessage directPath. */
            public directPath: string;

            /** AudioMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** AudioMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** AudioMessage streamingSidecar. */
            public streamingSidecar: Uint8Array;

            /** AudioMessage waveform. */
            public waveform: Uint8Array;

            /** AudioMessage backgroundArgb. */
            public backgroundArgb: number;

            /** AudioMessage viewOnce. */
            public viewOnce: boolean;

            /**
             * Crea una nueva instancia AudioMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AudioMessage instance
             */
            public static create(properties?: proto.Message.IAudioMessage): proto.Message.AudioMessage;

            /**
             * Codifica el mensaje AudioMessage. No implícitamente mensajes {@link proto.Message.AudioMessage.verify|verify}.
             * @param message AudioMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IAudioMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AudioMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.AudioMessage.verify|verify}.
             * @param message AudioMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IAudioMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AudioMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AudioMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.AudioMessage;

            /**
             * Decodes an AudioMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AudioMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.AudioMessage;

            /**
             * Verifies an AudioMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AudioMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AudioMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.AudioMessage;

            /**
             * Crea un objeto simple desden AudioMessage. También convierte valores a otros tipos si se especifica.
             * @param message AudioMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.AudioMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AudioMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ButtonsMessage. */
        interface IButtonsMessage {

            /** ButtonsMessage contentText */
            contentText?: (string|null);

            /** ButtonsMessage footerText */
            footerText?: (string|null);

            /** ButtonsMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** ButtonsMessage buttons */
            buttons?: (proto.Message.ButtonsMessage.IButton[]|null);

            /** ButtonsMessage headerType */
            headerType?: (proto.Message.ButtonsMessage.HeaderType|null);

            /** ButtonsMessage text */
            text?: (string|null);

            /** ButtonsMessage documentMessage */
            documentMessage?: (proto.Message.IDocumentMessage|null);

            /** ButtonsMessage imageMessage */
            imageMessage?: (proto.Message.IImageMessage|null);

            /** ButtonsMessage videoMessage */
            videoMessage?: (proto.Message.IVideoMessage|null);

            /** ButtonsMessage locationMessage */
            locationMessage?: (proto.Message.ILocationMessage|null);
        }

        /** Representa un ButtonsMessage. */
        class ButtonsMessage implements IButtonsMessage {

            /**
             * Construya un nuevo ButtonsMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IButtonsMessage);

            /** ButtonsMessage contentText. */
            public contentText: string;

            /** ButtonsMessage footerText. */
            public footerText: string;

            /** ButtonsMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** ButtonsMessage buttons. */
            public buttons: proto.Message.ButtonsMessage.IButton[];

            /** ButtonsMessage headerType. */
            public headerType: proto.Message.ButtonsMessage.HeaderType;

            /** ButtonsMessage text. */
            public text?: (string|null);

            /** ButtonsMessage documentMessage. */
            public documentMessage?: (proto.Message.IDocumentMessage|null);

            /** ButtonsMessage imageMessage. */
            public imageMessage?: (proto.Message.IImageMessage|null);

            /** ButtonsMessage videoMessage. */
            public videoMessage?: (proto.Message.IVideoMessage|null);

            /** ButtonsMessage locationMessage. */
            public locationMessage?: (proto.Message.ILocationMessage|null);

            /** ButtonsMessage header. */
            public header?: ("text"|"documentMessage"|"imageMessage"|"videoMessage"|"locationMessage");

            /**
             * Crea una nueva instancia ButtonsMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ButtonsMessage instance
             */
            public static create(properties?: proto.Message.IButtonsMessage): proto.Message.ButtonsMessage;

            /**
             * Codifica el mensaje ButtonsMessage. No implícitamente mensajes {@link proto.Message.ButtonsMessage.verify|verify}.
             * @param message ButtonsMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IButtonsMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ButtonsMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ButtonsMessage.verify|verify}.
             * @param message ButtonsMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IButtonsMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ButtonsMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ButtonsMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ButtonsMessage;

            /**
             * Decodes a ButtonsMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ButtonsMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ButtonsMessage;

            /**
             * Verifies a ButtonsMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ButtonsMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ButtonsMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ButtonsMessage;

            /**
             * Crea un objeto simple desde ButtonsMessage. También convierte valores a otros tipos si se especifica.
             * @param message ButtonsMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ButtonsMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ButtonsMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ButtonsMessage {

            /** Propiedades de un Button. */
            interface IButton {

                /** Button buttonId */
                buttonId?: (string|null);

                /** Button buttonText */
                buttonText?: (proto.Message.ButtonsMessage.Button.IButtonText|null);

                /** Button type */
                type?: (proto.Message.ButtonsMessage.Button.Type|null);

                /** Button nativeFlowInfo */
                nativeFlowInfo?: (proto.Message.ButtonsMessage.Button.INativeFlowInfo|null);
            }

            /** Representa un Button. */
            class Button implements IButton {

                /**
                 * Construya un nuevo Button.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ButtonsMessage.IButton);

                /** Button buttonId. */
                public buttonId: string;

                /** Button buttonText. */
                public buttonText?: (proto.Message.ButtonsMessage.Button.IButtonText|null);

                /** Button type. */
                public type: proto.Message.ButtonsMessage.Button.Type;

                /** Button nativeFlowInfo. */
                public nativeFlowInfo?: (proto.Message.ButtonsMessage.Button.INativeFlowInfo|null);

                /**
                 * Crea una nueva instancia Button utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Button instance
                 */
                public static create(properties?: proto.Message.ButtonsMessage.IButton): proto.Message.ButtonsMessage.Button;

                /**
                 * Codifica el mensaje Button. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.verify|verify}.
                 * @param message Button mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ButtonsMessage.IButton, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Button message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.verify|verify}.
                 * @param message Button mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ButtonsMessage.IButton, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Button message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Button
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ButtonsMessage.Button;

                /**
                 * Decodes a Button message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Button
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ButtonsMessage.Button;

                /**
                 * Verifies a Button message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Button message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Button
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ButtonsMessage.Button;

                /**
                 * Crea un objeto simple desde Button. También convierte valores a otros tipos si se especifica.
                 * @param message Button
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ButtonsMessage.Button, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Button a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Button {

                /** Propiedades de un ButtonText. */
                interface IButtonText {

                    /** ButtonText displayText */
                    displayText?: (string|null);
                }

                /** Representa un ButtonText. */
                class ButtonText implements IButtonText {

                    /**
                     * Construya un nuevo ButtonText.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.ButtonsMessage.Button.IButtonText);

                    /** ButtonText displayText. */
                    public displayText: string;

                    /**
                     * Crea una nueva instancia ButtonText utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns ButtonText instance
                     */
                    public static create(properties?: proto.Message.ButtonsMessage.Button.IButtonText): proto.Message.ButtonsMessage.Button.ButtonText;

                    /**
                     * Codifica el mensaje ButtonText. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.ButtonText.verify|verify}.
                     * @param message ButtonText mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.ButtonsMessage.Button.IButtonText, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje ButtonText message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.ButtonText.verify|verify}.
                     * @param message ButtonText mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.ButtonsMessage.Button.IButtonText, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ButtonText message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns ButtonText
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ButtonsMessage.Button.ButtonText;

                    /**
                     * Decodes a ButtonText message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns ButtonText
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ButtonsMessage.Button.ButtonText;

                    /**
                     * Verifies a ButtonText message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ButtonText message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns ButtonText
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.ButtonsMessage.Button.ButtonText;

                    /**
                     * Crea un objeto simple desde ButtonText. También convierte valores a otros tipos si se especifica.
                     * @param message ButtonText
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.ButtonsMessage.Button.ButtonText, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  ButtonText a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Propiedades de un NativeFlowInfo. */
                interface INativeFlowInfo {

                    /** NativeFlowInfo name */
                    name?: (string|null);

                    /** NativeFlowInfo paramsJson */
                    paramsJson?: (string|null);
                }

                /** Representa un NativeFlowInfo. */
                class NativeFlowInfo implements INativeFlowInfo {

                    /**
                     * Construya un nuevo NativeFlowInfo.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.ButtonsMessage.Button.INativeFlowInfo);

                    /** NativeFlowInfo name. */
                    public name: string;

                    /** NativeFlowInfo paramsJson. */
                    public paramsJson: string;

                    /**
                     * Crea una nueva instancia NativeFlowInfo utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns NativeFlowInfo instance
                     */
                    public static create(properties?: proto.Message.ButtonsMessage.Button.INativeFlowInfo): proto.Message.ButtonsMessage.Button.NativeFlowInfo;

                    /**
                     * Codifica el mensaje NativeFlowInfo. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.NativeFlowInfo.verify|verify}.
                     * @param message NativeFlowInfo mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.ButtonsMessage.Button.INativeFlowInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje NativeFlowInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ButtonsMessage.Button.NativeFlowInfo.verify|verify}.
                     * @param message NativeFlowInfo mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.ButtonsMessage.Button.INativeFlowInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a NativeFlowInfo message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns NativeFlowInfo
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ButtonsMessage.Button.NativeFlowInfo;

                    /**
                     * Decodes a NativeFlowInfo message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns NativeFlowInfo
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ButtonsMessage.Button.NativeFlowInfo;

                    /**
                     * Verifies a NativeFlowInfo message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a NativeFlowInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns NativeFlowInfo
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.ButtonsMessage.Button.NativeFlowInfo;

                    /**
                     * Crea un objeto simple desde NativeFlowInfo. También convierte valores a otros tipos si se especifica.
                     * @param message NativeFlowInfo
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.ButtonsMessage.Button.NativeFlowInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  NativeFlowInfo a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Type enum. */
                enum Type {
                    UNKNOWN = 0,
                    RESPONSE = 1,
                    NATIVE_FLOW = 2
                }
            }

            /** HeaderType enum. */
            enum HeaderType {
                UNKNOWN = 0,
                EMPTY = 1,
                TEXT = 2,
                DOCUMENT = 3,
                IMAGE = 4,
                VIDEO = 5,
                LOCATION = 6
            }
        }

        /** Propiedades de un ButtonsResponseMessage. */
        interface IButtonsResponseMessage {

            /** ButtonsResponseMessage selectedButtonId */
            selectedButtonId?: (string|null);

            /** ButtonsResponseMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** ButtonsResponseMessage type */
            type?: (proto.Message.ButtonsResponseMessage.Type|null);

            /** ButtonsResponseMessage selectedDisplayText */
            selectedDisplayText?: (string|null);
        }

        /** Representa un ButtonsResponseMessage. */
        class ButtonsResponseMessage implements IButtonsResponseMessage {

            /**
             * Construya un nuevo ButtonsResponseMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IButtonsResponseMessage);

            /** ButtonsResponseMessage selectedButtonId. */
            public selectedButtonId: string;

            /** ButtonsResponseMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** ButtonsResponseMessage type. */
            public type: proto.Message.ButtonsResponseMessage.Type;

            /** ButtonsResponseMessage selectedDisplayText. */
            public selectedDisplayText?: (string|null);

            /** ButtonsResponseMessage response. */
            public response?: "selectedDisplayText";

            /**
             * Crea una nueva instancia ButtonsResponseMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ButtonsResponseMessage instance
             */
            public static create(properties?: proto.Message.IButtonsResponseMessage): proto.Message.ButtonsResponseMessage;

            /**
             * Codifica el mensaje ButtonsResponseMessage. No implícitamente mensajes {@link proto.Message.ButtonsResponseMessage.verify|verify}.
             * @param message ButtonsResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IButtonsResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ButtonsResponseMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ButtonsResponseMessage.verify|verify}.
             * @param message ButtonsResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IButtonsResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ButtonsResponseMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ButtonsResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ButtonsResponseMessage;

            /**
             * Decodes a ButtonsResponseMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ButtonsResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ButtonsResponseMessage;

            /**
             * Verifies a ButtonsResponseMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ButtonsResponseMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ButtonsResponseMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ButtonsResponseMessage;

            /**
             * Crea un objeto simple desde ButtonsResponseMessage. También convierte valores a otros tipos si se especifica.
             * @param message ButtonsResponseMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ButtonsResponseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ButtonsResponseMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ButtonsResponseMessage {

            /** Type enum. */
            enum Type {
                UNKNOWN = 0,
                DISPLAY_TEXT = 1
            }
        }

        /** Propiedades de un Call. */
        interface ICall {

            /** Call callKey */
            callKey?: (Uint8Array|null);

            /** Call conversionSource */
            conversionSource?: (string|null);

            /** Call conversionData */
            conversionData?: (Uint8Array|null);

            /** Call conversionDelaySeconds */
            conversionDelaySeconds?: (number|null);
        }

        /** Representa un Call. */
        class Call implements ICall {

            /**
             * Construya un nuevo Call.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ICall);

            /** Call callKey. */
            public callKey: Uint8Array;

            /** Call conversionSource. */
            public conversionSource: string;

            /** Call conversionData. */
            public conversionData: Uint8Array;

            /** Call conversionDelaySeconds. */
            public conversionDelaySeconds: number;

            /**
             * Crea una nueva instancia Call utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns Call instance
             */
            public static create(properties?: proto.Message.ICall): proto.Message.Call;

            /**
             * Codifica el mensaje Call. No implícitamente mensajes {@link proto.Message.Call.verify|verify}.
             * @param message Call mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ICall, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje Call message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.Call.verify|verify}.
             * @param message Call mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ICall, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Call message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns Call
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.Call;

            /**
             * Decodes a Call message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns Call
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.Call;

            /**
             * Verifies a Call message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Call message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns Call
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.Call;

            /**
             * Crea un objeto simple desde Call. También convierte valores a otros tipos si se especifica.
             * @param message Call
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.Call, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  Call a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un CancelPaymentRequestMessage. */
        interface ICancelPaymentRequestMessage {

            /** CancelPaymentRequestMessage key */
            key?: (proto.IMessageKey|null);
        }

        /** Representa un CancelPaymentRequestMessage. */
        class CancelPaymentRequestMessage implements ICancelPaymentRequestMessage {

            /**
             * Construya un nuevo CancelPaymentRequestMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ICancelPaymentRequestMessage);

            /** CancelPaymentRequestMessage key. */
            public key?: (proto.IMessageKey|null);

            /**
             * Crea una nueva instancia CancelPaymentRequestMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns CancelPaymentRequestMessage instance
             */
            public static create(properties?: proto.Message.ICancelPaymentRequestMessage): proto.Message.CancelPaymentRequestMessage;

            /**
             * Codifica el mensaje CancelPaymentRequestMessage. No implícitamente mensajes {@link proto.Message.CancelPaymentRequestMessage.verify|verify}.
             * @param message CancelPaymentRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ICancelPaymentRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje CancelPaymentRequestMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.CancelPaymentRequestMessage.verify|verify}.
             * @param message CancelPaymentRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ICancelPaymentRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CancelPaymentRequestMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns CancelPaymentRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.CancelPaymentRequestMessage;

            /**
             * Decodes a CancelPaymentRequestMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns CancelPaymentRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.CancelPaymentRequestMessage;

            /**
             * Verifies a CancelPaymentRequestMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a CancelPaymentRequestMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns CancelPaymentRequestMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.CancelPaymentRequestMessage;

            /**
             * Crea un objeto simple desde CancelPaymentRequestMessage. También convierte valores a otros tipos si se especifica.
             * @param message CancelPaymentRequestMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.CancelPaymentRequestMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  CancelPaymentRequestMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un Chat. */
        interface IChat {

            /** Chat displayName */
            displayName?: (string|null);

            /** Chat id */
            id?: (string|null);
        }

        /** Representa un Chat. */
        class Chat implements IChat {

            /**
             * Construya un nuevo Chat.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IChat);

            /** Chat displayName. */
            public displayName: string;

            /** Chat id. */
            public id: string;

            /**
             * Crea una nueva instancia Chat utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns Chat instance
             */
            public static create(properties?: proto.Message.IChat): proto.Message.Chat;

            /**
             * Codifica el mensaje Chat. No implícitamente mensajes {@link proto.Message.Chat.verify|verify}.
             * @param message Chat mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IChat, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje Chat message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.Chat.verify|verify}.
             * @param message Chat mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IChat, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Chat message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns Chat
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.Chat;

            /**
             * Decodes a Chat message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns Chat
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.Chat;

            /**
             * Verifies a Chat message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Chat message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns Chat
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.Chat;

            /**
             * Crea un objeto simple desde Chat. También convierte valores a otros tipos si se especifica.
             * @param message Chat
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.Chat, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  Chat a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ContactMessage. */
        interface IContactMessage {

            /** ContactMessage displayName */
            displayName?: (string|null);

            /** ContactMessage vcard */
            vcard?: (string|null);

            /** ContactMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un ContactMessage. */
        class ContactMessage implements IContactMessage {

            /**
             * Construya un nuevo ContactMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IContactMessage);

            /** ContactMessage displayName. */
            public displayName: string;

            /** ContactMessage vcard. */
            public vcard: string;

            /** ContactMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia ContactMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ContactMessage instance
             */
            public static create(properties?: proto.Message.IContactMessage): proto.Message.ContactMessage;

            /**
             * Codifica el mensaje ContactMessage. No implícitamente mensajes {@link proto.Message.ContactMessage.verify|verify}.
             * @param message ContactMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IContactMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ContactMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ContactMessage.verify|verify}.
             * @param message ContactMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IContactMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContactMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ContactMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ContactMessage;

            /**
             * Decodes a ContactMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ContactMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ContactMessage;

            /**
             * Verifies a ContactMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ContactMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ContactMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ContactMessage;

            /**
             * Crea un objeto simple desde ContactMessage. También convierte valores a otros tipos si se especifica.
             * @param message ContactMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ContactMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ContactMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ContactsArrayMessage. */
        interface IContactsArrayMessage {

            /** ContactsArrayMessage displayName */
            displayName?: (string|null);

            /** ContactsArrayMessage contacts */
            contacts?: (proto.Message.IContactMessage[]|null);

            /** ContactsArrayMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un ContactsArrayMessage. */
        class ContactsArrayMessage implements IContactsArrayMessage {

            /**
             * Construya un nuevo ContactsArrayMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IContactsArrayMessage);

            /** ContactsArrayMessage displayName. */
            public displayName: string;

            /** ContactsArrayMessage contacts. */
            public contacts: proto.Message.IContactMessage[];

            /** ContactsArrayMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia ContactsArrayMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ContactsArrayMessage instance
             */
            public static create(properties?: proto.Message.IContactsArrayMessage): proto.Message.ContactsArrayMessage;

            /**
             * Codifica el mensaje ContactsArrayMessage. No implícitamente mensajes {@link proto.Message.ContactsArrayMessage.verify|verify}.
             * @param message ContactsArrayMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IContactsArrayMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ContactsArrayMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ContactsArrayMessage.verify|verify}.
             * @param message ContactsArrayMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IContactsArrayMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContactsArrayMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ContactsArrayMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ContactsArrayMessage;

            /**
             * Decodes a ContactsArrayMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ContactsArrayMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ContactsArrayMessage;

            /**
             * Verifies a ContactsArrayMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ContactsArrayMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ContactsArrayMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ContactsArrayMessage;

            /**
             * Crea un objeto simple desde ContactsArrayMessage. También convierte valores a otros tipos si se especifica.
             * @param message ContactsArrayMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ContactsArrayMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ContactsArrayMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un DeclinePaymentRequestMessage. */
        interface IDeclinePaymentRequestMessage {

            /** DeclinePaymentRequestMessage key */
            key?: (proto.IMessageKey|null);
        }

        /** Representa un DeclinePaymentRequestMessage. */
        class DeclinePaymentRequestMessage implements IDeclinePaymentRequestMessage {

            /**
             * Construya un nuevo DeclinePaymentRequestMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IDeclinePaymentRequestMessage);

            /** DeclinePaymentRequestMessage key. */
            public key?: (proto.IMessageKey|null);

            /**
             * Crea una nueva instancia DeclinePaymentRequestMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DeclinePaymentRequestMessage instance
             */
            public static create(properties?: proto.Message.IDeclinePaymentRequestMessage): proto.Message.DeclinePaymentRequestMessage;

            /**
             * Codifica el mensaje DeclinePaymentRequestMessage. No implícitamente mensajes {@link proto.Message.DeclinePaymentRequestMessage.verify|verify}.
             * @param message DeclinePaymentRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IDeclinePaymentRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DeclinePaymentRequestMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.DeclinePaymentRequestMessage.verify|verify}.
             * @param message DeclinePaymentRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IDeclinePaymentRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DeclinePaymentRequestMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DeclinePaymentRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.DeclinePaymentRequestMessage;

            /**
             * Decodes a DeclinePaymentRequestMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DeclinePaymentRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.DeclinePaymentRequestMessage;

            /**
             * Verifies a DeclinePaymentRequestMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DeclinePaymentRequestMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DeclinePaymentRequestMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.DeclinePaymentRequestMessage;

            /**
             * Crea un objeto simple desde DeclinePaymentRequestMessage. También convierte valores a otros tipos si se especifica.
             * @param message DeclinePaymentRequestMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.DeclinePaymentRequestMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DeclinePaymentRequestMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un DeviceSentMessage. */
        interface IDeviceSentMessage {

            /** DeviceSentMessage destinationJid */
            destinationJid?: (string|null);

            /** DeviceSentMessage message */
            message?: (proto.IMessage|null);

            /** DeviceSentMessage phash */
            phash?: (string|null);
        }

        /** Representa un DeviceSentMessage. */
        class DeviceSentMessage implements IDeviceSentMessage {

            /**
             * Construya un nuevo DeviceSentMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IDeviceSentMessage);

            /** DeviceSentMessage destinationJid. */
            public destinationJid: string;

            /** DeviceSentMessage message. */
            public message?: (proto.IMessage|null);

            /** DeviceSentMessage phash. */
            public phash: string;

            /**
             * Crea una nueva instancia DeviceSentMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DeviceSentMessage instance
             */
            public static create(properties?: proto.Message.IDeviceSentMessage): proto.Message.DeviceSentMessage;

            /**
             * Codifica el mensaje DeviceSentMessage. No implícitamente mensajes {@link proto.Message.DeviceSentMessage.verify|verify}.
             * @param message DeviceSentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IDeviceSentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DeviceSentMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.DeviceSentMessage.verify|verify}.
             * @param message DeviceSentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IDeviceSentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DeviceSentMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DeviceSentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.DeviceSentMessage;

            /**
             * Decodes a DeviceSentMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DeviceSentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.DeviceSentMessage;

            /**
             * Verifies a DeviceSentMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DeviceSentMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DeviceSentMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.DeviceSentMessage;

            /**
             * Crea un objeto simple desde DeviceSentMessage. También convierte valores a otros tipos si se especifica.
             * @param message DeviceSentMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.DeviceSentMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DeviceSentMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un DocumentMessage. */
        interface IDocumentMessage {

            /** DocumentMessage url */
            url?: (string|null);

            /** DocumentMessage mimetype */
            mimetype?: (string|null);

            /** DocumentMessage title */
            title?: (string|null);

            /** DocumentMessage fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** DocumentMessage fileLength */
            fileLength?: (number|Long|null);

            /** DocumentMessage pageCount */
            pageCount?: (number|null);

            /** DocumentMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** DocumentMessage fileName */
            fileName?: (string|null);

            /** DocumentMessage fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** DocumentMessage directPath */
            directPath?: (string|null);

            /** DocumentMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** DocumentMessage contactVcard */
            contactVcard?: (boolean|null);

            /** DocumentMessage thumbnailDirectPath */
            thumbnailDirectPath?: (string|null);

            /** DocumentMessage thumbnailSha256 */
            thumbnailSha256?: (Uint8Array|null);

            /** DocumentMessage thumbnailEncSha256 */
            thumbnailEncSha256?: (Uint8Array|null);

            /** DocumentMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** DocumentMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** DocumentMessage thumbnailHeight */
            thumbnailHeight?: (number|null);

            /** DocumentMessage thumbnailWidth */
            thumbnailWidth?: (number|null);

            /** DocumentMessage caption */
            caption?: (string|null);
        }

        /** Representa un DocumentMessage. */
        class DocumentMessage implements IDocumentMessage {

            /**
             * Construya un nuevo DocumentMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IDocumentMessage);

            /** DocumentMessage url. */
            public url: string;

            /** DocumentMessage mimetype. */
            public mimetype: string;

            /** DocumentMessage title. */
            public title: string;

            /** DocumentMessage fileSha256. */
            public fileSha256: Uint8Array;

            /** DocumentMessage fileLength. */
            public fileLength: (number|Long);

            /** DocumentMessage pageCount. */
            public pageCount: number;

            /** DocumentMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** DocumentMessage fileName. */
            public fileName: string;

            /** DocumentMessage fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** DocumentMessage directPath. */
            public directPath: string;

            /** DocumentMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** DocumentMessage contactVcard. */
            public contactVcard: boolean;

            /** DocumentMessage thumbnailDirectPath. */
            public thumbnailDirectPath: string;

            /** DocumentMessage thumbnailSha256. */
            public thumbnailSha256: Uint8Array;

            /** DocumentMessage thumbnailEncSha256. */
            public thumbnailEncSha256: Uint8Array;

            /** DocumentMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** DocumentMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** DocumentMessage thumbnailHeight. */
            public thumbnailHeight: number;

            /** DocumentMessage thumbnailWidth. */
            public thumbnailWidth: number;

            /** DocumentMessage caption. */
            public caption: string;

            /**
             * Crea una nueva instancia DocumentMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DocumentMessage instance
             */
            public static create(properties?: proto.Message.IDocumentMessage): proto.Message.DocumentMessage;

            /**
             * Codifica el mensaje DocumentMessage. No implícitamente mensajes {@link proto.Message.DocumentMessage.verify|verify}.
             * @param message DocumentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IDocumentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DocumentMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.DocumentMessage.verify|verify}.
             * @param message DocumentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IDocumentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DocumentMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DocumentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.DocumentMessage;

            /**
             * Decodes a DocumentMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DocumentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.DocumentMessage;

            /**
             * Verifies a DocumentMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DocumentMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DocumentMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.DocumentMessage;

            /**
             * Crea un objeto simple desde DocumentMessage. También convierte valores a otros tipos si se especifica.
             * @param message DocumentMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.DocumentMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DocumentMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn EncReactionMessage. */
        interface IEncReactionMessage {

            /** EncReactionMessage targetMessageKey */
            targetMessageKey?: (proto.IMessageKey|null);

            /** EncReactionMessage encPayload */
            encPayload?: (Uint8Array|null);

            /** EncReactionMessage encIv */
            encIv?: (Uint8Array|null);
        }

        /** Representa unn EncReactionMessage. */
        class EncReactionMessage implements IEncReactionMessage {

            /**
             * Construya un nuevo EncReactionMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IEncReactionMessage);

            /** EncReactionMessage targetMessageKey. */
            public targetMessageKey?: (proto.IMessageKey|null);

            /** EncReactionMessage encPayload. */
            public encPayload: Uint8Array;

            /** EncReactionMessage encIv. */
            public encIv: Uint8Array;

            /**
             * Crea una nueva instancia EncReactionMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns EncReactionMessage instance
             */
            public static create(properties?: proto.Message.IEncReactionMessage): proto.Message.EncReactionMessage;

            /**
             * Codifica el mensaje EncReactionMessage. No implícitamente mensajes {@link proto.Message.EncReactionMessage.verify|verify}.
             * @param message EncReactionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IEncReactionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje EncReactionMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.EncReactionMessage.verify|verify}.
             * @param message EncReactionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IEncReactionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EncReactionMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns EncReactionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.EncReactionMessage;

            /**
             * Decodes an EncReactionMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns EncReactionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.EncReactionMessage;

            /**
             * Verifies an EncReactionMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an EncReactionMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns EncReactionMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.EncReactionMessage;

            /**
             * Crea un objeto simple desden EncReactionMessage. También convierte valores a otros tipos si se especifica.
             * @param message EncReactionMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.EncReactionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  EncReactionMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn ExtendedTextMessage. */
        interface IExtendedTextMessage {

            /** ExtendedTextMessage text */
            text?: (string|null);

            /** ExtendedTextMessage matchedText */
            matchedText?: (string|null);

            /** ExtendedTextMessage canonicalUrl */
            canonicalUrl?: (string|null);

            /** ExtendedTextMessage description */
            description?: (string|null);

            /** ExtendedTextMessage title */
            title?: (string|null);

            /** ExtendedTextMessage textArgb */
            textArgb?: (number|null);

            /** ExtendedTextMessage backgroundArgb */
            backgroundArgb?: (number|null);

            /** ExtendedTextMessage font */
            font?: (proto.Message.ExtendedTextMessage.FontType|null);

            /** ExtendedTextMessage previewType */
            previewType?: (proto.Message.ExtendedTextMessage.PreviewType|null);

            /** ExtendedTextMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** ExtendedTextMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** ExtendedTextMessage doNotPlayInline */
            doNotPlayInline?: (boolean|null);

            /** ExtendedTextMessage thumbnailDirectPath */
            thumbnailDirectPath?: (string|null);

            /** ExtendedTextMessage thumbnailSha256 */
            thumbnailSha256?: (Uint8Array|null);

            /** ExtendedTextMessage thumbnailEncSha256 */
            thumbnailEncSha256?: (Uint8Array|null);

            /** ExtendedTextMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** ExtendedTextMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** ExtendedTextMessage thumbnailHeight */
            thumbnailHeight?: (number|null);

            /** ExtendedTextMessage thumbnailWidth */
            thumbnailWidth?: (number|null);

            /** ExtendedTextMessage inviteLinkGroupType */
            inviteLinkGroupType?: (proto.Message.ExtendedTextMessage.InviteLinkGroupType|null);

            /** ExtendedTextMessage inviteLinkParentGroupSubjectV2 */
            inviteLinkParentGroupSubjectV2?: (string|null);

            /** ExtendedTextMessage inviteLinkParentGroupThumbnailV2 */
            inviteLinkParentGroupThumbnailV2?: (Uint8Array|null);

            /** ExtendedTextMessage inviteLinkGroupTypeV2 */
            inviteLinkGroupTypeV2?: (proto.Message.ExtendedTextMessage.InviteLinkGroupType|null);

            /** ExtendedTextMessage viewOnce */
            viewOnce?: (boolean|null);
        }

        /** Representa unn ExtendedTextMessage. */
        class ExtendedTextMessage implements IExtendedTextMessage {

            /**
             * Construya un nuevo ExtendedTextMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IExtendedTextMessage);

            /** ExtendedTextMessage text. */
            public text: string;

            /** ExtendedTextMessage matchedText. */
            public matchedText: string;

            /** ExtendedTextMessage canonicalUrl. */
            public canonicalUrl: string;

            /** ExtendedTextMessage description. */
            public description: string;

            /** ExtendedTextMessage title. */
            public title: string;

            /** ExtendedTextMessage textArgb. */
            public textArgb: number;

            /** ExtendedTextMessage backgroundArgb. */
            public backgroundArgb: number;

            /** ExtendedTextMessage font. */
            public font: proto.Message.ExtendedTextMessage.FontType;

            /** ExtendedTextMessage previewType. */
            public previewType: proto.Message.ExtendedTextMessage.PreviewType;

            /** ExtendedTextMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** ExtendedTextMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** ExtendedTextMessage doNotPlayInline. */
            public doNotPlayInline: boolean;

            /** ExtendedTextMessage thumbnailDirectPath. */
            public thumbnailDirectPath: string;

            /** ExtendedTextMessage thumbnailSha256. */
            public thumbnailSha256: Uint8Array;

            /** ExtendedTextMessage thumbnailEncSha256. */
            public thumbnailEncSha256: Uint8Array;

            /** ExtendedTextMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** ExtendedTextMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** ExtendedTextMessage thumbnailHeight. */
            public thumbnailHeight: number;

            /** ExtendedTextMessage thumbnailWidth. */
            public thumbnailWidth: number;

            /** ExtendedTextMessage inviteLinkGroupType. */
            public inviteLinkGroupType: proto.Message.ExtendedTextMessage.InviteLinkGroupType;

            /** ExtendedTextMessage inviteLinkParentGroupSubjectV2. */
            public inviteLinkParentGroupSubjectV2: string;

            /** ExtendedTextMessage inviteLinkParentGroupThumbnailV2. */
            public inviteLinkParentGroupThumbnailV2: Uint8Array;

            /** ExtendedTextMessage inviteLinkGroupTypeV2. */
            public inviteLinkGroupTypeV2: proto.Message.ExtendedTextMessage.InviteLinkGroupType;

            /** ExtendedTextMessage viewOnce. */
            public viewOnce: boolean;

            /**
             * Crea una nueva instancia ExtendedTextMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ExtendedTextMessage instance
             */
            public static create(properties?: proto.Message.IExtendedTextMessage): proto.Message.ExtendedTextMessage;

            /**
             * Codifica el mensaje ExtendedTextMessage. No implícitamente mensajes {@link proto.Message.ExtendedTextMessage.verify|verify}.
             * @param message ExtendedTextMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IExtendedTextMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ExtendedTextMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ExtendedTextMessage.verify|verify}.
             * @param message ExtendedTextMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IExtendedTextMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExtendedTextMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ExtendedTextMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ExtendedTextMessage;

            /**
             * Decodes an ExtendedTextMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ExtendedTextMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ExtendedTextMessage;

            /**
             * Verifies an ExtendedTextMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an ExtendedTextMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ExtendedTextMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ExtendedTextMessage;

            /**
             * Crea un objeto simple desden ExtendedTextMessage. También convierte valores a otros tipos si se especifica.
             * @param message ExtendedTextMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ExtendedTextMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ExtendedTextMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ExtendedTextMessage {

            /** FontType enum. */
            enum FontType {
                SANS_SERIF = 0,
                SERIF = 1,
                NORICAN_REGULAR = 2,
                BRYNDAN_WRITE = 3,
                BEBASNEUE_REGULAR = 4,
                OSWALD_HEAVY = 5,
                DAMION_REGULAR = 6,
                MORNINGBREEZE_REGULAR = 7,
                CALISTOGA_REGULAR = 8,
                EXO2_EXTRABOLD = 9,
                COURIERPRIME_BOLD = 10
            }

            /** InviteLinkGroupType enum. */
            enum InviteLinkGroupType {
                DEFAULT = 0,
                PARENT = 1,
                SUB = 2,
                DEFAULT_SUB = 3
            }

            /** PreviewType enum. */
            enum PreviewType {
                NONE = 0,
                VIDEO = 1
            }
        }

        /** Propiedades de un FutureProofMessage. */
        interface IFutureProofMessage {

            /** FutureProofMessage message */
            message?: (proto.IMessage|null);
        }

        /** Representa un FutureProofMessage. */
        class FutureProofMessage implements IFutureProofMessage {

            /**
             * Construya un nuevo FutureProofMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IFutureProofMessage);

            /** FutureProofMessage message. */
            public message?: (proto.IMessage|null);

            /**
             * Crea una nueva instancia FutureProofMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns FutureProofMessage instance
             */
            public static create(properties?: proto.Message.IFutureProofMessage): proto.Message.FutureProofMessage;

            /**
             * Codifica el mensaje FutureProofMessage. No implícitamente mensajes {@link proto.Message.FutureProofMessage.verify|verify}.
             * @param message FutureProofMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IFutureProofMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje FutureProofMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.FutureProofMessage.verify|verify}.
             * @param message FutureProofMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IFutureProofMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FutureProofMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns FutureProofMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.FutureProofMessage;

            /**
             * Decodes a FutureProofMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns FutureProofMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.FutureProofMessage;

            /**
             * Verifies a FutureProofMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a FutureProofMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns FutureProofMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.FutureProofMessage;

            /**
             * Crea un objeto simple desde FutureProofMessage. También convierte valores a otros tipos si se especifica.
             * @param message FutureProofMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.FutureProofMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  FutureProofMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un GroupInviteMessage. */
        interface IGroupInviteMessage {

            /** GroupInviteMessage groupJid */
            groupJid?: (string|null);

            /** GroupInviteMessage inviteCode */
            inviteCode?: (string|null);

            /** GroupInviteMessage inviteExpiration */
            inviteExpiration?: (number|Long|null);

            /** GroupInviteMessage groupName */
            groupName?: (string|null);

            /** GroupInviteMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** GroupInviteMessage caption */
            caption?: (string|null);

            /** GroupInviteMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** GroupInviteMessage groupType */
            groupType?: (proto.Message.GroupInviteMessage.GroupType|null);
        }

        /** Representa un GroupInviteMessage. */
        class GroupInviteMessage implements IGroupInviteMessage {

            /**
             * Construya un nuevo GroupInviteMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IGroupInviteMessage);

            /** GroupInviteMessage groupJid. */
            public groupJid: string;

            /** GroupInviteMessage inviteCode. */
            public inviteCode: string;

            /** GroupInviteMessage inviteExpiration. */
            public inviteExpiration: (number|Long);

            /** GroupInviteMessage groupName. */
            public groupName: string;

            /** GroupInviteMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** GroupInviteMessage caption. */
            public caption: string;

            /** GroupInviteMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** GroupInviteMessage groupType. */
            public groupType: proto.Message.GroupInviteMessage.GroupType;

            /**
             * Crea una nueva instancia GroupInviteMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns GroupInviteMessage instance
             */
            public static create(properties?: proto.Message.IGroupInviteMessage): proto.Message.GroupInviteMessage;

            /**
             * Codifica el mensaje GroupInviteMessage. No implícitamente mensajes {@link proto.Message.GroupInviteMessage.verify|verify}.
             * @param message GroupInviteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IGroupInviteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje GroupInviteMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.GroupInviteMessage.verify|verify}.
             * @param message GroupInviteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IGroupInviteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GroupInviteMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns GroupInviteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.GroupInviteMessage;

            /**
             * Decodes a GroupInviteMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns GroupInviteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.GroupInviteMessage;

            /**
             * Verifies a GroupInviteMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a GroupInviteMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns GroupInviteMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.GroupInviteMessage;

            /**
             * Crea un objeto simple desde GroupInviteMessage. También convierte valores a otros tipos si se especifica.
             * @param message GroupInviteMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.GroupInviteMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  GroupInviteMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace GroupInviteMessage {

            /** GroupType enum. */
            enum GroupType {
                DEFAULT = 0,
                PARENT = 1
            }
        }

        /** Propiedades de un HighlyStructuredMessage. */
        interface IHighlyStructuredMessage {

            /** HighlyStructuredMessage namespace */
            namespace?: (string|null);

            /** HighlyStructuredMessage elementName */
            elementName?: (string|null);

            /** HighlyStructuredMessage params */
            params?: (string[]|null);

            /** HighlyStructuredMessage fallbackLg */
            fallbackLg?: (string|null);

            /** HighlyStructuredMessage fallbackLc */
            fallbackLc?: (string|null);

            /** HighlyStructuredMessage localizableParams */
            localizableParams?: (proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter[]|null);

            /** HighlyStructuredMessage deterministicLg */
            deterministicLg?: (string|null);

            /** HighlyStructuredMessage deterministicLc */
            deterministicLc?: (string|null);

            /** HighlyStructuredMessage hydratedHsm */
            hydratedHsm?: (proto.Message.ITemplateMessage|null);
        }

        /** Representa un HighlyStructuredMessage. */
        class HighlyStructuredMessage implements IHighlyStructuredMessage {

            /**
             * Construya un nuevo HighlyStructuredMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IHighlyStructuredMessage);

            /** HighlyStructuredMessage namespace. */
            public namespace: string;

            /** HighlyStructuredMessage elementName. */
            public elementName: string;

            /** HighlyStructuredMessage params. */
            public params: string[];

            /** HighlyStructuredMessage fallbackLg. */
            public fallbackLg: string;

            /** HighlyStructuredMessage fallbackLc. */
            public fallbackLc: string;

            /** HighlyStructuredMessage localizableParams. */
            public localizableParams: proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter[];

            /** HighlyStructuredMessage deterministicLg. */
            public deterministicLg: string;

            /** HighlyStructuredMessage deterministicLc. */
            public deterministicLc: string;

            /** HighlyStructuredMessage hydratedHsm. */
            public hydratedHsm?: (proto.Message.ITemplateMessage|null);

            /**
             * Crea una nueva instancia HighlyStructuredMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HighlyStructuredMessage instance
             */
            public static create(properties?: proto.Message.IHighlyStructuredMessage): proto.Message.HighlyStructuredMessage;

            /**
             * Codifica el mensaje HighlyStructuredMessage. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.verify|verify}.
             * @param message HighlyStructuredMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IHighlyStructuredMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HighlyStructuredMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.verify|verify}.
             * @param message HighlyStructuredMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IHighlyStructuredMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HighlyStructuredMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HighlyStructuredMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage;

            /**
             * Decodes a HighlyStructuredMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HighlyStructuredMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage;

            /**
             * Verifies a HighlyStructuredMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HighlyStructuredMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HighlyStructuredMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage;

            /**
             * Crea un objeto simple desde HighlyStructuredMessage. También convierte valores a otros tipos si se especifica.
             * @param message HighlyStructuredMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.HighlyStructuredMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HighlyStructuredMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace HighlyStructuredMessage {

            /** Propiedades de un HSMLocalizableParameter. */
            interface IHSMLocalizableParameter {

                /** HSMLocalizableParameter default */
                "default"?: (string|null);

                /** HSMLocalizableParameter currency */
                currency?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency|null);

                /** HSMLocalizableParameter dateTime */
                dateTime?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime|null);
            }

            /** Representa un HSMLocalizableParameter. */
            class HSMLocalizableParameter implements IHSMLocalizableParameter {

                /**
                 * Construya un nuevo HSMLocalizableParameter.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter);

                /** HSMLocalizableParameter default. */
                public default: string;

                /** HSMLocalizableParameter currency. */
                public currency?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency|null);

                /** HSMLocalizableParameter dateTime. */
                public dateTime?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime|null);

                /** HSMLocalizableParameter paramOneof. */
                public paramOneof?: ("currency"|"dateTime");

                /**
                 * Crea una nueva instancia HSMLocalizableParameter utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns HSMLocalizableParameter instance
                 */
                public static create(properties?: proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter;

                /**
                 * Codifica el mensaje HSMLocalizableParameter. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.verify|verify}.
                 * @param message HSMLocalizableParameter mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje HSMLocalizableParameter message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.verify|verify}.
                 * @param message HSMLocalizableParameter mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HSMLocalizableParameter message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns HSMLocalizableParameter
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter;

                /**
                 * Decodes a HSMLocalizableParameter message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns HSMLocalizableParameter
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter;

                /**
                 * Verifies a HSMLocalizableParameter message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a HSMLocalizableParameter message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns HSMLocalizableParameter
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter;

                /**
                 * Crea un objeto simple desde HSMLocalizableParameter. También convierte valores a otros tipos si se especifica.
                 * @param message HSMLocalizableParameter
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  HSMLocalizableParameter a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace HSMLocalizableParameter {

                /** Propiedades de un HSMCurrency. */
                interface IHSMCurrency {

                    /** HSMCurrency currencyCode */
                    currencyCode?: (string|null);

                    /** HSMCurrency amount1000 */
                    amount1000?: (number|Long|null);
                }

                /** Representa un HSMCurrency. */
                class HSMCurrency implements IHSMCurrency {

                    /**
                     * Construya un nuevo HSMCurrency.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency);

                    /** HSMCurrency currencyCode. */
                    public currencyCode: string;

                    /** HSMCurrency amount1000. */
                    public amount1000: (number|Long);

                    /**
                     * Crea una nueva instancia HSMCurrency utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns HSMCurrency instance
                     */
                    public static create(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency;

                    /**
                     * Codifica el mensaje HSMCurrency. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.verify|verify}.
                     * @param message HSMCurrency mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje HSMCurrency message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.verify|verify}.
                     * @param message HSMCurrency mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a HSMCurrency message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns HSMCurrency
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency;

                    /**
                     * Decodes a HSMCurrency message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns HSMCurrency
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency;

                    /**
                     * Verifies a HSMCurrency message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a HSMCurrency message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns HSMCurrency
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency;

                    /**
                     * Crea un objeto simple desde HSMCurrency. También convierte valores a otros tipos si se especifica.
                     * @param message HSMCurrency
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  HSMCurrency a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Propiedades de un HSMDateTime. */
                interface IHSMDateTime {

                    /** HSMDateTime component */
                    component?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent|null);

                    /** HSMDateTime unixEpoch */
                    unixEpoch?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch|null);
                }

                /** Representa un HSMDateTime. */
                class HSMDateTime implements IHSMDateTime {

                    /**
                     * Construya un nuevo HSMDateTime.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime);

                    /** HSMDateTime component. */
                    public component?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent|null);

                    /** HSMDateTime unixEpoch. */
                    public unixEpoch?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch|null);

                    /** HSMDateTime datetimeOneof. */
                    public datetimeOneof?: ("component"|"unixEpoch");

                    /**
                     * Crea una nueva instancia HSMDateTime utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns HSMDateTime instance
                     */
                    public static create(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime;

                    /**
                     * Codifica el mensaje HSMDateTime. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.verify|verify}.
                     * @param message HSMDateTime mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje HSMDateTime message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.verify|verify}.
                     * @param message HSMDateTime mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a HSMDateTime message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns HSMDateTime
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime;

                    /**
                     * Decodes a HSMDateTime message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns HSMDateTime
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime;

                    /**
                     * Verifies a HSMDateTime message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a HSMDateTime message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns HSMDateTime
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime;

                    /**
                     * Crea un objeto simple desde HSMDateTime. También convierte valores a otros tipos si se especifica.
                     * @param message HSMDateTime
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  HSMDateTime a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                namespace HSMDateTime {

                    /** Propiedades de un HSMDateTimeComponent. */
                    interface IHSMDateTimeComponent {

                        /** HSMDateTimeComponent dayOfWeek */
                        dayOfWeek?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType|null);

                        /** HSMDateTimeComponent year */
                        year?: (number|null);

                        /** HSMDateTimeComponent month */
                        month?: (number|null);

                        /** HSMDateTimeComponent dayOfMonth */
                        dayOfMonth?: (number|null);

                        /** HSMDateTimeComponent hour */
                        hour?: (number|null);

                        /** HSMDateTimeComponent minute */
                        minute?: (number|null);

                        /** HSMDateTimeComponent calendar */
                        calendar?: (proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType|null);
                    }

                    /** Representa un HSMDateTimeComponent. */
                    class HSMDateTimeComponent implements IHSMDateTimeComponent {

                        /**
                         * Construya un nuevo HSMDateTimeComponent.
                         * @param [properties] para establecer propiedades
                         */
                        constructor(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent);

                        /** HSMDateTimeComponent dayOfWeek. */
                        public dayOfWeek: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType;

                        /** HSMDateTimeComponent year. */
                        public year: number;

                        /** HSMDateTimeComponent month. */
                        public month: number;

                        /** HSMDateTimeComponent dayOfMonth. */
                        public dayOfMonth: number;

                        /** HSMDateTimeComponent hour. */
                        public hour: number;

                        /** HSMDateTimeComponent minute. */
                        public minute: number;

                        /** HSMDateTimeComponent calendar. */
                        public calendar: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType;

                        /**
                         * Crea una nueva instancia HSMDateTimeComponent utilizando las propiedades especificadas.
                         * @param [properties] para establecer propiedades
                         * @returns HSMDateTimeComponent instance
                         */
                        public static create(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent;

                        /**
                         * Codifica el mensaje HSMDateTimeComponent. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.verify|verify}.
                         * @param message HSMDateTimeComponent mensaje o objeto simple para codificar
                         * @param [writer] Writer para codificar a
                         * @returns Writer
                         */
                        public static encode(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Codifica el mensaje HSMDateTimeComponent message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.verify|verify}.
                         * @param message HSMDateTimeComponent mensaje o objeto simple para codificar
                         * @param [writer] Writer para codificar a
                         * @returns Writer
                         */
                        public static encodeDelimited(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes a HSMDateTimeComponent message from the specified reader or buffer.
                         * @param reader Reader o búfer para decodificar desde
                         * @param [length] Longitud del mensaje si se conoce de antemano
                         * @returns HSMDateTimeComponent
                         * @throws {Error} Si la carga útil no es un lector o un búfer válido
                         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent;

                        /**
                         * Decodes a HSMDateTimeComponent message desde el especifico lector o búfer, longitud delimitada.
                         * @param reader Reader o búfer para decodificar desde
                         * @returns HSMDateTimeComponent
                         * @throws {Error} Si la carga útil no es un lector o un búfer válido
                         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                         */
                        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent;

                        /**
                         * Verifies a HSMDateTimeComponent message.
                         * @param message Objeto simple para verificar
                         * @returns `null` Si es válido, de lo contrario la razón por la que no es
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates a HSMDateTimeComponent message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                         * @param object Objeto simple
                         * @returns HSMDateTimeComponent
                         */
                        public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent;

                        /**
                         * Crea un objeto simple desde HSMDateTimeComponent. También convierte valores a otros tipos si se especifica.
                         * @param message HSMDateTimeComponent
                         * @param [options] Opciones de conversión
                         * @returns Objeto simple
                         */
                        public static toObject(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Convierte este  HSMDateTimeComponent a JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }

                    namespace HSMDateTimeComponent {

                        /** CalendarType enum. */
                        enum CalendarType {
                            GREGORIAN = 1,
                            SOLAR_HIJRI = 2
                        }

                        /** DayOfWeekType enum. */
                        enum DayOfWeekType {
                            MONDAY = 1,
                            TUESDAY = 2,
                            WEDNESDAY = 3,
                            THURSDAY = 4,
                            FRIDAY = 5,
                            SATURDAY = 6,
                            SUNDAY = 7
                        }
                    }

                    /** Propiedades de un HSMDateTimeUnixEpoch. */
                    interface IHSMDateTimeUnixEpoch {

                        /** HSMDateTimeUnixEpoch timestamp */
                        timestamp?: (number|Long|null);
                    }

                    /** Representa un HSMDateTimeUnixEpoch. */
                    class HSMDateTimeUnixEpoch implements IHSMDateTimeUnixEpoch {

                        /**
                         * Construya un nuevo HSMDateTimeUnixEpoch.
                         * @param [properties] para establecer propiedades
                         */
                        constructor(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch);

                        /** HSMDateTimeUnixEpoch timestamp. */
                        public timestamp: (number|Long);

                        /**
                         * Crea una nueva instancia HSMDateTimeUnixEpoch utilizando las propiedades especificadas.
                         * @param [properties] para establecer propiedades
                         * @returns HSMDateTimeUnixEpoch instance
                         */
                        public static create(properties?: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch;

                        /**
                         * Codifica el mensaje HSMDateTimeUnixEpoch. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.verify|verify}.
                         * @param message HSMDateTimeUnixEpoch mensaje o objeto simple para codificar
                         * @param [writer] Writer para codificar a
                         * @returns Writer
                         */
                        public static encode(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Codifica el mensaje HSMDateTimeUnixEpoch message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.verify|verify}.
                         * @param message HSMDateTimeUnixEpoch mensaje o objeto simple para codificar
                         * @param [writer] Writer para codificar a
                         * @returns Writer
                         */
                        public static encodeDelimited(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes a HSMDateTimeUnixEpoch message from the specified reader or buffer.
                         * @param reader Reader o búfer para decodificar desde
                         * @param [length] Longitud del mensaje si se conoce de antemano
                         * @returns HSMDateTimeUnixEpoch
                         * @throws {Error} Si la carga útil no es un lector o un búfer válido
                         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch;

                        /**
                         * Decodes a HSMDateTimeUnixEpoch message desde el especifico lector o búfer, longitud delimitada.
                         * @param reader Reader o búfer para decodificar desde
                         * @returns HSMDateTimeUnixEpoch
                         * @throws {Error} Si la carga útil no es un lector o un búfer válido
                         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                         */
                        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch;

                        /**
                         * Verifies a HSMDateTimeUnixEpoch message.
                         * @param message Objeto simple para verificar
                         * @returns `null` Si es válido, de lo contrario la razón por la que no es
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates a HSMDateTimeUnixEpoch message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                         * @param object Objeto simple
                         * @returns HSMDateTimeUnixEpoch
                         */
                        public static fromObject(object: { [k: string]: any }): proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch;

                        /**
                         * Crea un objeto simple desde HSMDateTimeUnixEpoch. También convierte valores a otros tipos si se especifica.
                         * @param message HSMDateTimeUnixEpoch
                         * @param [options] Opciones de conversión
                         * @returns Objeto simple
                         */
                        public static toObject(message: proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Convierte este  HSMDateTimeUnixEpoch a JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }
                }
            }
        }

        /** Propiedades de un HistorySyncNotification. */
        interface IHistorySyncNotification {

            /** HistorySyncNotification fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** HistorySyncNotification fileLength */
            fileLength?: (number|Long|null);

            /** HistorySyncNotification mediaKey */
            mediaKey?: (Uint8Array|null);

            /** HistorySyncNotification fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** HistorySyncNotification directPath */
            directPath?: (string|null);

            /** HistorySyncNotification syncType */
            syncType?: (proto.Message.HistorySyncNotification.HistorySyncType|null);

            /** HistorySyncNotification chunkOrder */
            chunkOrder?: (number|null);

            /** HistorySyncNotification originalMessageId */
            originalMessageId?: (string|null);

            /** HistorySyncNotification progress */
            progress?: (number|null);

            /** HistorySyncNotification oldestMsgInChunkTimestampSec */
            oldestMsgInChunkTimestampSec?: (number|Long|null);
        }

        /** Representa un HistorySyncNotification. */
        class HistorySyncNotification implements IHistorySyncNotification {

            /**
             * Construya un nuevo HistorySyncNotification.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IHistorySyncNotification);

            /** HistorySyncNotification fileSha256. */
            public fileSha256: Uint8Array;

            /** HistorySyncNotification fileLength. */
            public fileLength: (number|Long);

            /** HistorySyncNotification mediaKey. */
            public mediaKey: Uint8Array;

            /** HistorySyncNotification fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** HistorySyncNotification directPath. */
            public directPath: string;

            /** HistorySyncNotification syncType. */
            public syncType: proto.Message.HistorySyncNotification.HistorySyncType;

            /** HistorySyncNotification chunkOrder. */
            public chunkOrder: number;

            /** HistorySyncNotification originalMessageId. */
            public originalMessageId: string;

            /** HistorySyncNotification progress. */
            public progress: number;

            /** HistorySyncNotification oldestMsgInChunkTimestampSec. */
            public oldestMsgInChunkTimestampSec: (number|Long);

            /**
             * Crea una nueva instancia HistorySyncNotification utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns HistorySyncNotification instance
             */
            public static create(properties?: proto.Message.IHistorySyncNotification): proto.Message.HistorySyncNotification;

            /**
             * Codifica el mensaje HistorySyncNotification. No implícitamente mensajes {@link proto.Message.HistorySyncNotification.verify|verify}.
             * @param message HistorySyncNotification mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IHistorySyncNotification, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje HistorySyncNotification message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.HistorySyncNotification.verify|verify}.
             * @param message HistorySyncNotification mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IHistorySyncNotification, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HistorySyncNotification message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns HistorySyncNotification
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.HistorySyncNotification;

            /**
             * Decodes a HistorySyncNotification message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns HistorySyncNotification
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.HistorySyncNotification;

            /**
             * Verifies a HistorySyncNotification message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a HistorySyncNotification message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns HistorySyncNotification
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.HistorySyncNotification;

            /**
             * Crea un objeto simple desde HistorySyncNotification. También convierte valores a otros tipos si se especifica.
             * @param message HistorySyncNotification
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.HistorySyncNotification, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  HistorySyncNotification a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace HistorySyncNotification {

            /** HistorySyncType enum. */
            enum HistorySyncType {
                INITIAL_BOOTSTRAP = 0,
                INITIAL_STATUS_V3 = 1,
                FULL = 2,
                RECENT = 3,
                PUSH_NAME = 4,
                NON_BLOCKING_DATA = 5,
                ON_DEMAND = 6
            }
        }

        /** Propiedades de unn ImageMessage. */
        interface IImageMessage {

            /** ImageMessage url */
            url?: (string|null);

            /** ImageMessage mimetype */
            mimetype?: (string|null);

            /** ImageMessage caption */
            caption?: (string|null);

            /** ImageMessage fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** ImageMessage fileLength */
            fileLength?: (number|Long|null);

            /** ImageMessage height */
            height?: (number|null);

            /** ImageMessage width */
            width?: (number|null);

            /** ImageMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** ImageMessage fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** ImageMessage interactiveAnnotations */
            interactiveAnnotations?: (proto.IInteractiveAnnotation[]|null);

            /** ImageMessage directPath */
            directPath?: (string|null);

            /** ImageMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** ImageMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** ImageMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** ImageMessage firstScanSidecar */
            firstScanSidecar?: (Uint8Array|null);

            /** ImageMessage firstScanLength */
            firstScanLength?: (number|null);

            /** ImageMessage experimentGroupId */
            experimentGroupId?: (number|null);

            /** ImageMessage scansSidecar */
            scansSidecar?: (Uint8Array|null);

            /** ImageMessage scanLengths */
            scanLengths?: (number[]|null);

            /** ImageMessage midQualityFileSha256 */
            midQualityFileSha256?: (Uint8Array|null);

            /** ImageMessage midQualityFileEncSha256 */
            midQualityFileEncSha256?: (Uint8Array|null);

            /** ImageMessage viewOnce */
            viewOnce?: (boolean|null);

            /** ImageMessage thumbnailDirectPath */
            thumbnailDirectPath?: (string|null);

            /** ImageMessage thumbnailSha256 */
            thumbnailSha256?: (Uint8Array|null);

            /** ImageMessage thumbnailEncSha256 */
            thumbnailEncSha256?: (Uint8Array|null);

            /** ImageMessage staticUrl */
            staticUrl?: (string|null);
        }

        /** Representa unn ImageMessage. */
        class ImageMessage implements IImageMessage {

            /**
             * Construya un nuevo ImageMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IImageMessage);

            /** ImageMessage url. */
            public url: string;

            /** ImageMessage mimetype. */
            public mimetype: string;

            /** ImageMessage caption. */
            public caption: string;

            /** ImageMessage fileSha256. */
            public fileSha256: Uint8Array;

            /** ImageMessage fileLength. */
            public fileLength: (number|Long);

            /** ImageMessage height. */
            public height: number;

            /** ImageMessage width. */
            public width: number;

            /** ImageMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** ImageMessage fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** ImageMessage interactiveAnnotations. */
            public interactiveAnnotations: proto.IInteractiveAnnotation[];

            /** ImageMessage directPath. */
            public directPath: string;

            /** ImageMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** ImageMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** ImageMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** ImageMessage firstScanSidecar. */
            public firstScanSidecar: Uint8Array;

            /** ImageMessage firstScanLength. */
            public firstScanLength: number;

            /** ImageMessage experimentGroupId. */
            public experimentGroupId: number;

            /** ImageMessage scansSidecar. */
            public scansSidecar: Uint8Array;

            /** ImageMessage scanLengths. */
            public scanLengths: number[];

            /** ImageMessage midQualityFileSha256. */
            public midQualityFileSha256: Uint8Array;

            /** ImageMessage midQualityFileEncSha256. */
            public midQualityFileEncSha256: Uint8Array;

            /** ImageMessage viewOnce. */
            public viewOnce: boolean;

            /** ImageMessage thumbnailDirectPath. */
            public thumbnailDirectPath: string;

            /** ImageMessage thumbnailSha256. */
            public thumbnailSha256: Uint8Array;

            /** ImageMessage thumbnailEncSha256. */
            public thumbnailEncSha256: Uint8Array;

            /** ImageMessage staticUrl. */
            public staticUrl: string;

            /**
             * Crea una nueva instancia ImageMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ImageMessage instance
             */
            public static create(properties?: proto.Message.IImageMessage): proto.Message.ImageMessage;

            /**
             * Codifica el mensaje ImageMessage. No implícitamente mensajes {@link proto.Message.ImageMessage.verify|verify}.
             * @param message ImageMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IImageMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ImageMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ImageMessage.verify|verify}.
             * @param message ImageMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IImageMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ImageMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ImageMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ImageMessage;

            /**
             * Decodes an ImageMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ImageMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ImageMessage;

            /**
             * Verifies an ImageMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an ImageMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ImageMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ImageMessage;

            /**
             * Crea un objeto simple desden ImageMessage. También convierte valores a otros tipos si se especifica.
             * @param message ImageMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ImageMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ImageMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn InitialSecurityNotificationSettingSync. */
        interface IInitialSecurityNotificationSettingSync {

            /** InitialSecurityNotificationSettingSync securityNotificationEnabled */
            securityNotificationEnabled?: (boolean|null);
        }

        /** Representa unn InitialSecurityNotificationSettingSync. */
        class InitialSecurityNotificationSettingSync implements IInitialSecurityNotificationSettingSync {

            /**
             * Construya un nuevo InitialSecurityNotificationSettingSync.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IInitialSecurityNotificationSettingSync);

            /** InitialSecurityNotificationSettingSync securityNotificationEnabled. */
            public securityNotificationEnabled: boolean;

            /**
             * Crea una nueva instancia InitialSecurityNotificationSettingSync utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns InitialSecurityNotificationSettingSync instance
             */
            public static create(properties?: proto.Message.IInitialSecurityNotificationSettingSync): proto.Message.InitialSecurityNotificationSettingSync;

            /**
             * Codifica el mensaje InitialSecurityNotificationSettingSync. No implícitamente mensajes {@link proto.Message.InitialSecurityNotificationSettingSync.verify|verify}.
             * @param message InitialSecurityNotificationSettingSync mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IInitialSecurityNotificationSettingSync, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje InitialSecurityNotificationSettingSync message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InitialSecurityNotificationSettingSync.verify|verify}.
             * @param message InitialSecurityNotificationSettingSync mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IInitialSecurityNotificationSettingSync, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an InitialSecurityNotificationSettingSync message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns InitialSecurityNotificationSettingSync
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InitialSecurityNotificationSettingSync;

            /**
             * Decodes an InitialSecurityNotificationSettingSync message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns InitialSecurityNotificationSettingSync
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InitialSecurityNotificationSettingSync;

            /**
             * Verifies an InitialSecurityNotificationSettingSync message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an InitialSecurityNotificationSettingSync message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns InitialSecurityNotificationSettingSync
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.InitialSecurityNotificationSettingSync;

            /**
             * Crea un objeto simple desden InitialSecurityNotificationSettingSync. También convierte valores a otros tipos si se especifica.
             * @param message InitialSecurityNotificationSettingSync
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.InitialSecurityNotificationSettingSync, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  InitialSecurityNotificationSettingSync a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn InteractiveMessage. */
        interface IInteractiveMessage {

            /** InteractiveMessage header */
            header?: (proto.Message.InteractiveMessage.IHeader|null);

            /** InteractiveMessage body */
            body?: (proto.Message.InteractiveMessage.IBody|null);

            /** InteractiveMessage footer */
            footer?: (proto.Message.InteractiveMessage.IFooter|null);

            /** InteractiveMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** InteractiveMessage shopStorefrontMessage */
            shopStorefrontMessage?: (proto.Message.InteractiveMessage.IShopMessage|null);

            /** InteractiveMessage collectionMessage */
            collectionMessage?: (proto.Message.InteractiveMessage.ICollectionMessage|null);

            /** InteractiveMessage nativeFlowMessage */
            nativeFlowMessage?: (proto.Message.InteractiveMessage.INativeFlowMessage|null);
        }

        /** Representa unn InteractiveMessage. */
        class InteractiveMessage implements IInteractiveMessage {

            /**
             * Construya un nuevo InteractiveMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IInteractiveMessage);

            /** InteractiveMessage header. */
            public header?: (proto.Message.InteractiveMessage.IHeader|null);

            /** InteractiveMessage body. */
            public body?: (proto.Message.InteractiveMessage.IBody|null);

            /** InteractiveMessage footer. */
            public footer?: (proto.Message.InteractiveMessage.IFooter|null);

            /** InteractiveMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** InteractiveMessage shopStorefrontMessage. */
            public shopStorefrontMessage?: (proto.Message.InteractiveMessage.IShopMessage|null);

            /** InteractiveMessage collectionMessage. */
            public collectionMessage?: (proto.Message.InteractiveMessage.ICollectionMessage|null);

            /** InteractiveMessage nativeFlowMessage. */
            public nativeFlowMessage?: (proto.Message.InteractiveMessage.INativeFlowMessage|null);

            /** InteractiveMessage interactiveMessage. */
            public interactiveMessage?: ("shopStorefrontMessage"|"collectionMessage"|"nativeFlowMessage");

            /**
             * Crea una nueva instancia InteractiveMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns InteractiveMessage instance
             */
            public static create(properties?: proto.Message.IInteractiveMessage): proto.Message.InteractiveMessage;

            /**
             * Codifica el mensaje InteractiveMessage. No implícitamente mensajes {@link proto.Message.InteractiveMessage.verify|verify}.
             * @param message InteractiveMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IInteractiveMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje InteractiveMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.verify|verify}.
             * @param message InteractiveMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IInteractiveMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an InteractiveMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns InteractiveMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage;

            /**
             * Decodes an InteractiveMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns InteractiveMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage;

            /**
             * Verifies an InteractiveMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an InteractiveMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns InteractiveMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage;

            /**
             * Crea un objeto simple desden InteractiveMessage. También convierte valores a otros tipos si se especifica.
             * @param message InteractiveMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.InteractiveMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  InteractiveMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace InteractiveMessage {

            /** Propiedades de un Body. */
            interface IBody {

                /** Body text */
                text?: (string|null);
            }

            /** Representa un Body. */
            class Body implements IBody {

                /**
                 * Construya un nuevo Body.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.IBody);

                /** Body text. */
                public text: string;

                /**
                 * Crea una nueva instancia Body utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Body instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.IBody): proto.Message.InteractiveMessage.Body;

                /**
                 * Codifica el mensaje Body. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Body.verify|verify}.
                 * @param message Body mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.IBody, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Body message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Body.verify|verify}.
                 * @param message Body mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.IBody, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Body
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.Body;

                /**
                 * Decodes a Body message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Body
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.Body;

                /**
                 * Verifies a Body message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Body message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Body
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.Body;

                /**
                 * Crea un objeto simple desde Body. También convierte valores a otros tipos si se especifica.
                 * @param message Body
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.Body, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Body a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un CollectionMessage. */
            interface ICollectionMessage {

                /** CollectionMessage bizJid */
                bizJid?: (string|null);

                /** CollectionMessage id */
                id?: (string|null);

                /** CollectionMessage messageVersion */
                messageVersion?: (number|null);
            }

            /** Representa un CollectionMessage. */
            class CollectionMessage implements ICollectionMessage {

                /**
                 * Construya un nuevo CollectionMessage.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.ICollectionMessage);

                /** CollectionMessage bizJid. */
                public bizJid: string;

                /** CollectionMessage id. */
                public id: string;

                /** CollectionMessage messageVersion. */
                public messageVersion: number;

                /**
                 * Crea una nueva instancia CollectionMessage utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns CollectionMessage instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.ICollectionMessage): proto.Message.InteractiveMessage.CollectionMessage;

                /**
                 * Codifica el mensaje CollectionMessage. No implícitamente mensajes {@link proto.Message.InteractiveMessage.CollectionMessage.verify|verify}.
                 * @param message CollectionMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.ICollectionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje CollectionMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.CollectionMessage.verify|verify}.
                 * @param message CollectionMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.ICollectionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CollectionMessage message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns CollectionMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.CollectionMessage;

                /**
                 * Decodes a CollectionMessage message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns CollectionMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.CollectionMessage;

                /**
                 * Verifies a CollectionMessage message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CollectionMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns CollectionMessage
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.CollectionMessage;

                /**
                 * Crea un objeto simple desde CollectionMessage. También convierte valores a otros tipos si se especifica.
                 * @param message CollectionMessage
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.CollectionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  CollectionMessage a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un Footer. */
            interface IFooter {

                /** Footer text */
                text?: (string|null);
            }

            /** Representa un Footer. */
            class Footer implements IFooter {

                /**
                 * Construya un nuevo Footer.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.IFooter);

                /** Footer text. */
                public text: string;

                /**
                 * Crea una nueva instancia Footer utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Footer instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.IFooter): proto.Message.InteractiveMessage.Footer;

                /**
                 * Codifica el mensaje Footer. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Footer.verify|verify}.
                 * @param message Footer mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.IFooter, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Footer message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Footer.verify|verify}.
                 * @param message Footer mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.IFooter, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Footer message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Footer
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.Footer;

                /**
                 * Decodes a Footer message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Footer
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.Footer;

                /**
                 * Verifies a Footer message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Footer message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Footer
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.Footer;

                /**
                 * Crea un objeto simple desde Footer. También convierte valores a otros tipos si se especifica.
                 * @param message Footer
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.Footer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Footer a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un Header. */
            interface IHeader {

                /** Header title */
                title?: (string|null);

                /** Header subtitle */
                subtitle?: (string|null);

                /** Header hasMediaAttachment */
                hasMediaAttachment?: (boolean|null);

                /** Header documentMessage */
                documentMessage?: (proto.Message.IDocumentMessage|null);

                /** Header imageMessage */
                imageMessage?: (proto.Message.IImageMessage|null);

                /** Header jpegThumbnail */
                jpegThumbnail?: (Uint8Array|null);

                /** Header videoMessage */
                videoMessage?: (proto.Message.IVideoMessage|null);
            }

            /** Representa un Header. */
            class Header implements IHeader {

                /**
                 * Construya un nuevo Header.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.IHeader);

                /** Header title. */
                public title: string;

                /** Header subtitle. */
                public subtitle: string;

                /** Header hasMediaAttachment. */
                public hasMediaAttachment: boolean;

                /** Header documentMessage. */
                public documentMessage?: (proto.Message.IDocumentMessage|null);

                /** Header imageMessage. */
                public imageMessage?: (proto.Message.IImageMessage|null);

                /** Header jpegThumbnail. */
                public jpegThumbnail?: (Uint8Array|null);

                /** Header videoMessage. */
                public videoMessage?: (proto.Message.IVideoMessage|null);

                /** Header media. */
                public media?: ("documentMessage"|"imageMessage"|"jpegThumbnail"|"videoMessage");

                /**
                 * Crea una nueva instancia Header utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Header instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.IHeader): proto.Message.InteractiveMessage.Header;

                /**
                 * Codifica el mensaje Header. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Header.verify|verify}.
                 * @param message Header mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.IHeader, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Header message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.Header.verify|verify}.
                 * @param message Header mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.IHeader, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Header message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Header
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.Header;

                /**
                 * Decodes a Header message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Header
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.Header;

                /**
                 * Verifies a Header message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Header message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Header
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.Header;

                /**
                 * Crea un objeto simple desde Header. También convierte valores a otros tipos si se especifica.
                 * @param message Header
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.Header, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Header a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un NativeFlowMessage. */
            interface INativeFlowMessage {

                /** NativeFlowMessage buttons */
                buttons?: (proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton[]|null);

                /** NativeFlowMessage messageParamsJson */
                messageParamsJson?: (string|null);

                /** NativeFlowMessage messageVersion */
                messageVersion?: (number|null);
            }

            /** Representa un NativeFlowMessage. */
            class NativeFlowMessage implements INativeFlowMessage {

                /**
                 * Construya un nuevo NativeFlowMessage.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.INativeFlowMessage);

                /** NativeFlowMessage buttons. */
                public buttons: proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton[];

                /** NativeFlowMessage messageParamsJson. */
                public messageParamsJson: string;

                /** NativeFlowMessage messageVersion. */
                public messageVersion: number;

                /**
                 * Crea una nueva instancia NativeFlowMessage utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns NativeFlowMessage instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.INativeFlowMessage): proto.Message.InteractiveMessage.NativeFlowMessage;

                /**
                 * Codifica el mensaje NativeFlowMessage. No implícitamente mensajes {@link proto.Message.InteractiveMessage.NativeFlowMessage.verify|verify}.
                 * @param message NativeFlowMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.INativeFlowMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje NativeFlowMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.NativeFlowMessage.verify|verify}.
                 * @param message NativeFlowMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.INativeFlowMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NativeFlowMessage message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns NativeFlowMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.NativeFlowMessage;

                /**
                 * Decodes a NativeFlowMessage message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns NativeFlowMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.NativeFlowMessage;

                /**
                 * Verifies a NativeFlowMessage message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NativeFlowMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns NativeFlowMessage
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.NativeFlowMessage;

                /**
                 * Crea un objeto simple desde NativeFlowMessage. También convierte valores a otros tipos si se especifica.
                 * @param message NativeFlowMessage
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.NativeFlowMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  NativeFlowMessage a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace NativeFlowMessage {

                /** Propiedades de un NativeFlowButton. */
                interface INativeFlowButton {

                    /** NativeFlowButton name */
                    name?: (string|null);

                    /** NativeFlowButton buttonParamsJson */
                    buttonParamsJson?: (string|null);
                }

                /** Representa un NativeFlowButton. */
                class NativeFlowButton implements INativeFlowButton {

                    /**
                     * Construya un nuevo NativeFlowButton.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton);

                    /** NativeFlowButton name. */
                    public name: string;

                    /** NativeFlowButton buttonParamsJson. */
                    public buttonParamsJson: string;

                    /**
                     * Crea una nueva instancia NativeFlowButton utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns NativeFlowButton instance
                     */
                    public static create(properties?: proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton): proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton;

                    /**
                     * Codifica el mensaje NativeFlowButton. No implícitamente mensajes {@link proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.verify|verify}.
                     * @param message NativeFlowButton mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje NativeFlowButton message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.verify|verify}.
                     * @param message NativeFlowButton mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a NativeFlowButton message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns NativeFlowButton
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton;

                    /**
                     * Decodes a NativeFlowButton message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns NativeFlowButton
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton;

                    /**
                     * Verifies a NativeFlowButton message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a NativeFlowButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns NativeFlowButton
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton;

                    /**
                     * Crea un objeto simple desde NativeFlowButton. También convierte valores a otros tipos si se especifica.
                     * @param message NativeFlowButton
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  NativeFlowButton a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Propiedades de un ShopMessage. */
            interface IShopMessage {

                /** ShopMessage id */
                id?: (string|null);

                /** ShopMessage surface */
                surface?: (proto.Message.InteractiveMessage.ShopMessage.Surface|null);

                /** ShopMessage messageVersion */
                messageVersion?: (number|null);
            }

            /** Representa un ShopMessage. */
            class ShopMessage implements IShopMessage {

                /**
                 * Construya un nuevo ShopMessage.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveMessage.IShopMessage);

                /** ShopMessage id. */
                public id: string;

                /** ShopMessage surface. */
                public surface: proto.Message.InteractiveMessage.ShopMessage.Surface;

                /** ShopMessage messageVersion. */
                public messageVersion: number;

                /**
                 * Crea una nueva instancia ShopMessage utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ShopMessage instance
                 */
                public static create(properties?: proto.Message.InteractiveMessage.IShopMessage): proto.Message.InteractiveMessage.ShopMessage;

                /**
                 * Codifica el mensaje ShopMessage. No implícitamente mensajes {@link proto.Message.InteractiveMessage.ShopMessage.verify|verify}.
                 * @param message ShopMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveMessage.IShopMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ShopMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveMessage.ShopMessage.verify|verify}.
                 * @param message ShopMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveMessage.IShopMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ShopMessage message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ShopMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveMessage.ShopMessage;

                /**
                 * Decodes a ShopMessage message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ShopMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveMessage.ShopMessage;

                /**
                 * Verifies a ShopMessage message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ShopMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ShopMessage
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveMessage.ShopMessage;

                /**
                 * Crea un objeto simple desde ShopMessage. También convierte valores a otros tipos si se especifica.
                 * @param message ShopMessage
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveMessage.ShopMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ShopMessage a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace ShopMessage {

                /** Surface enum. */
                enum Surface {
                    UNKNOWN_SURFACE = 0,
                    FB = 1,
                    IG = 2,
                    WA = 3
                }
            }
        }

        /** Propiedades de unn InteractiveResponseMessage. */
        interface IInteractiveResponseMessage {

            /** InteractiveResponseMessage body */
            body?: (proto.Message.InteractiveResponseMessage.IBody|null);

            /** InteractiveResponseMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** InteractiveResponseMessage nativeFlowResponseMessage */
            nativeFlowResponseMessage?: (proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage|null);
        }

        /** Representa unn InteractiveResponseMessage. */
        class InteractiveResponseMessage implements IInteractiveResponseMessage {

            /**
             * Construya un nuevo InteractiveResponseMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IInteractiveResponseMessage);

            /** InteractiveResponseMessage body. */
            public body?: (proto.Message.InteractiveResponseMessage.IBody|null);

            /** InteractiveResponseMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** InteractiveResponseMessage nativeFlowResponseMessage. */
            public nativeFlowResponseMessage?: (proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage|null);

            /** InteractiveResponseMessage interactiveResponseMessage. */
            public interactiveResponseMessage?: "nativeFlowResponseMessage";

            /**
             * Crea una nueva instancia InteractiveResponseMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns InteractiveResponseMessage instance
             */
            public static create(properties?: proto.Message.IInteractiveResponseMessage): proto.Message.InteractiveResponseMessage;

            /**
             * Codifica el mensaje InteractiveResponseMessage. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.verify|verify}.
             * @param message InteractiveResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IInteractiveResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje InteractiveResponseMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.verify|verify}.
             * @param message InteractiveResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IInteractiveResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an InteractiveResponseMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns InteractiveResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveResponseMessage;

            /**
             * Decodes an InteractiveResponseMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns InteractiveResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveResponseMessage;

            /**
             * Verifies an InteractiveResponseMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an InteractiveResponseMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns InteractiveResponseMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveResponseMessage;

            /**
             * Crea un objeto simple desden InteractiveResponseMessage. También convierte valores a otros tipos si se especifica.
             * @param message InteractiveResponseMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.InteractiveResponseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  InteractiveResponseMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace InteractiveResponseMessage {

            /** Propiedades de un Body. */
            interface IBody {

                /** Body text */
                text?: (string|null);
            }

            /** Representa un Body. */
            class Body implements IBody {

                /**
                 * Construya un nuevo Body.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveResponseMessage.IBody);

                /** Body text. */
                public text: string;

                /**
                 * Crea una nueva instancia Body utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Body instance
                 */
                public static create(properties?: proto.Message.InteractiveResponseMessage.IBody): proto.Message.InteractiveResponseMessage.Body;

                /**
                 * Codifica el mensaje Body. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.Body.verify|verify}.
                 * @param message Body mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveResponseMessage.IBody, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Body message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.Body.verify|verify}.
                 * @param message Body mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveResponseMessage.IBody, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Body
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveResponseMessage.Body;

                /**
                 * Decodes a Body message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Body
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveResponseMessage.Body;

                /**
                 * Verifies a Body message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Body message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Body
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveResponseMessage.Body;

                /**
                 * Crea un objeto simple desde Body. También convierte valores a otros tipos si se especifica.
                 * @param message Body
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveResponseMessage.Body, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Body a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un NativeFlowResponseMessage. */
            interface INativeFlowResponseMessage {

                /** NativeFlowResponseMessage name */
                name?: (string|null);

                /** NativeFlowResponseMessage paramsJson */
                paramsJson?: (string|null);

                /** NativeFlowResponseMessage version */
                version?: (number|null);
            }

            /** Representa un NativeFlowResponseMessage. */
            class NativeFlowResponseMessage implements INativeFlowResponseMessage {

                /**
                 * Construya un nuevo NativeFlowResponseMessage.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage);

                /** NativeFlowResponseMessage name. */
                public name: string;

                /** NativeFlowResponseMessage paramsJson. */
                public paramsJson: string;

                /** NativeFlowResponseMessage version. */
                public version: number;

                /**
                 * Crea una nueva instancia NativeFlowResponseMessage utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns NativeFlowResponseMessage instance
                 */
                public static create(properties?: proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage): proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage;

                /**
                 * Codifica el mensaje NativeFlowResponseMessage. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.verify|verify}.
                 * @param message NativeFlowResponseMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje NativeFlowResponseMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.verify|verify}.
                 * @param message NativeFlowResponseMessage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NativeFlowResponseMessage message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns NativeFlowResponseMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage;

                /**
                 * Decodes a NativeFlowResponseMessage message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns NativeFlowResponseMessage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage;

                /**
                 * Verifies a NativeFlowResponseMessage message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NativeFlowResponseMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns NativeFlowResponseMessage
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage;

                /**
                 * Crea un objeto simple desde NativeFlowResponseMessage. También convierte valores a otros tipos si se especifica.
                 * @param message NativeFlowResponseMessage
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  NativeFlowResponseMessage a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de unn InvoiceMessage. */
        interface IInvoiceMessage {

            /** InvoiceMessage note */
            note?: (string|null);

            /** InvoiceMessage token */
            token?: (string|null);

            /** InvoiceMessage attachmentType */
            attachmentType?: (proto.Message.InvoiceMessage.AttachmentType|null);

            /** InvoiceMessage attachmentMimetype */
            attachmentMimetype?: (string|null);

            /** InvoiceMessage attachmentMediaKey */
            attachmentMediaKey?: (Uint8Array|null);

            /** InvoiceMessage attachmentMediaKeyTimestamp */
            attachmentMediaKeyTimestamp?: (number|Long|null);

            /** InvoiceMessage attachmentFileSha256 */
            attachmentFileSha256?: (Uint8Array|null);

            /** InvoiceMessage attachmentFileEncSha256 */
            attachmentFileEncSha256?: (Uint8Array|null);

            /** InvoiceMessage attachmentDirectPath */
            attachmentDirectPath?: (string|null);

            /** InvoiceMessage attachmentJpegThumbnail */
            attachmentJpegThumbnail?: (Uint8Array|null);
        }

        /** Representa unn InvoiceMessage. */
        class InvoiceMessage implements IInvoiceMessage {

            /**
             * Construya un nuevo InvoiceMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IInvoiceMessage);

            /** InvoiceMessage note. */
            public note: string;

            /** InvoiceMessage token. */
            public token: string;

            /** InvoiceMessage attachmentType. */
            public attachmentType: proto.Message.InvoiceMessage.AttachmentType;

            /** InvoiceMessage attachmentMimetype. */
            public attachmentMimetype: string;

            /** InvoiceMessage attachmentMediaKey. */
            public attachmentMediaKey: Uint8Array;

            /** InvoiceMessage attachmentMediaKeyTimestamp. */
            public attachmentMediaKeyTimestamp: (number|Long);

            /** InvoiceMessage attachmentFileSha256. */
            public attachmentFileSha256: Uint8Array;

            /** InvoiceMessage attachmentFileEncSha256. */
            public attachmentFileEncSha256: Uint8Array;

            /** InvoiceMessage attachmentDirectPath. */
            public attachmentDirectPath: string;

            /** InvoiceMessage attachmentJpegThumbnail. */
            public attachmentJpegThumbnail: Uint8Array;

            /**
             * Crea una nueva instancia InvoiceMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns InvoiceMessage instance
             */
            public static create(properties?: proto.Message.IInvoiceMessage): proto.Message.InvoiceMessage;

            /**
             * Codifica el mensaje InvoiceMessage. No implícitamente mensajes {@link proto.Message.InvoiceMessage.verify|verify}.
             * @param message InvoiceMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IInvoiceMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje InvoiceMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.InvoiceMessage.verify|verify}.
             * @param message InvoiceMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IInvoiceMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an InvoiceMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns InvoiceMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.InvoiceMessage;

            /**
             * Decodes an InvoiceMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns InvoiceMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.InvoiceMessage;

            /**
             * Verifies an InvoiceMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an InvoiceMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns InvoiceMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.InvoiceMessage;

            /**
             * Crea un objeto simple desden InvoiceMessage. También convierte valores a otros tipos si se especifica.
             * @param message InvoiceMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.InvoiceMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  InvoiceMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace InvoiceMessage {

            /** AttachmentType enum. */
            enum AttachmentType {
                IMAGE = 0,
                PDF = 1
            }
        }

        /** Propiedades de un KeepInChatMessage. */
        interface IKeepInChatMessage {

            /** KeepInChatMessage key */
            key?: (proto.IMessageKey|null);

            /** KeepInChatMessage keepType */
            keepType?: (proto.KeepType|null);

            /** KeepInChatMessage timestampMs */
            timestampMs?: (number|Long|null);
        }

        /** Representa un KeepInChatMessage. */
        class KeepInChatMessage implements IKeepInChatMessage {

            /**
             * Construya un nuevo KeepInChatMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IKeepInChatMessage);

            /** KeepInChatMessage key. */
            public key?: (proto.IMessageKey|null);

            /** KeepInChatMessage keepType. */
            public keepType: proto.KeepType;

            /** KeepInChatMessage timestampMs. */
            public timestampMs: (number|Long);

            /**
             * Crea una nueva instancia KeepInChatMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns KeepInChatMessage instance
             */
            public static create(properties?: proto.Message.IKeepInChatMessage): proto.Message.KeepInChatMessage;

            /**
             * Codifica el mensaje KeepInChatMessage. No implícitamente mensajes {@link proto.Message.KeepInChatMessage.verify|verify}.
             * @param message KeepInChatMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IKeepInChatMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje KeepInChatMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.KeepInChatMessage.verify|verify}.
             * @param message KeepInChatMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IKeepInChatMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KeepInChatMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns KeepInChatMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.KeepInChatMessage;

            /**
             * Decodes a KeepInChatMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns KeepInChatMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.KeepInChatMessage;

            /**
             * Verifies a KeepInChatMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a KeepInChatMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns KeepInChatMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.KeepInChatMessage;

            /**
             * Crea un objeto simple desde KeepInChatMessage. También convierte valores a otros tipos si se especifica.
             * @param message KeepInChatMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.KeepInChatMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  KeepInChatMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ListMessage. */
        interface IListMessage {

            /** ListMessage title */
            title?: (string|null);

            /** ListMessage description */
            description?: (string|null);

            /** ListMessage buttonText */
            buttonText?: (string|null);

            /** ListMessage listType */
            listType?: (proto.Message.ListMessage.ListType|null);

            /** ListMessage sections */
            sections?: (proto.Message.ListMessage.ISection[]|null);

            /** ListMessage productListInfo */
            productListInfo?: (proto.Message.ListMessage.IProductListInfo|null);

            /** ListMessage footerText */
            footerText?: (string|null);

            /** ListMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un ListMessage. */
        class ListMessage implements IListMessage {

            /**
             * Construya un nuevo ListMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IListMessage);

            /** ListMessage title. */
            public title: string;

            /** ListMessage description. */
            public description: string;

            /** ListMessage buttonText. */
            public buttonText: string;

            /** ListMessage listType. */
            public listType: proto.Message.ListMessage.ListType;

            /** ListMessage sections. */
            public sections: proto.Message.ListMessage.ISection[];

            /** ListMessage productListInfo. */
            public productListInfo?: (proto.Message.ListMessage.IProductListInfo|null);

            /** ListMessage footerText. */
            public footerText: string;

            /** ListMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia ListMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ListMessage instance
             */
            public static create(properties?: proto.Message.IListMessage): proto.Message.ListMessage;

            /**
             * Codifica el mensaje ListMessage. No implícitamente mensajes {@link proto.Message.ListMessage.verify|verify}.
             * @param message ListMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IListMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ListMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.verify|verify}.
             * @param message ListMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IListMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ListMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ListMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage;

            /**
             * Decodes a ListMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ListMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage;

            /**
             * Verifies a ListMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ListMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ListMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage;

            /**
             * Crea un objeto simple desde ListMessage. También convierte valores a otros tipos si se especifica.
             * @param message ListMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ListMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ListMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ListMessage {

            /** ListType enum. */
            enum ListType {
                UNKNOWN = 0,
                SINGLE_SELECT = 1,
                PRODUCT_LIST = 2
            }

            /** Propiedades de un Product. */
            interface IProduct {

                /** Product productId */
                productId?: (string|null);
            }

            /** Representa un Product. */
            class Product implements IProduct {

                /**
                 * Construya un nuevo Product.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.IProduct);

                /** Product productId. */
                public productId: string;

                /**
                 * Crea una nueva instancia Product utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Product instance
                 */
                public static create(properties?: proto.Message.ListMessage.IProduct): proto.Message.ListMessage.Product;

                /**
                 * Codifica el mensaje Product. No implícitamente mensajes {@link proto.Message.ListMessage.Product.verify|verify}.
                 * @param message Product mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.IProduct, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Product message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.Product.verify|verify}.
                 * @param message Product mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.IProduct, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Product message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Product
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.Product;

                /**
                 * Decodes a Product message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Product
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.Product;

                /**
                 * Verifies a Product message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Product message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Product
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.Product;

                /**
                 * Crea un objeto simple desde Product. También convierte valores a otros tipos si se especifica.
                 * @param message Product
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.Product, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Product a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un ProductListHeaderImage. */
            interface IProductListHeaderImage {

                /** ProductListHeaderImage productId */
                productId?: (string|null);

                /** ProductListHeaderImage jpegThumbnail */
                jpegThumbnail?: (Uint8Array|null);
            }

            /** Representa un ProductListHeaderImage. */
            class ProductListHeaderImage implements IProductListHeaderImage {

                /**
                 * Construya un nuevo ProductListHeaderImage.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.IProductListHeaderImage);

                /** ProductListHeaderImage productId. */
                public productId: string;

                /** ProductListHeaderImage jpegThumbnail. */
                public jpegThumbnail: Uint8Array;

                /**
                 * Crea una nueva instancia ProductListHeaderImage utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ProductListHeaderImage instance
                 */
                public static create(properties?: proto.Message.ListMessage.IProductListHeaderImage): proto.Message.ListMessage.ProductListHeaderImage;

                /**
                 * Codifica el mensaje ProductListHeaderImage. No implícitamente mensajes {@link proto.Message.ListMessage.ProductListHeaderImage.verify|verify}.
                 * @param message ProductListHeaderImage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.IProductListHeaderImage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ProductListHeaderImage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.ProductListHeaderImage.verify|verify}.
                 * @param message ProductListHeaderImage mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.IProductListHeaderImage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ProductListHeaderImage message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ProductListHeaderImage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.ProductListHeaderImage;

                /**
                 * Decodes a ProductListHeaderImage message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ProductListHeaderImage
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.ProductListHeaderImage;

                /**
                 * Verifies a ProductListHeaderImage message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ProductListHeaderImage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ProductListHeaderImage
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.ProductListHeaderImage;

                /**
                 * Crea un objeto simple desde ProductListHeaderImage. También convierte valores a otros tipos si se especifica.
                 * @param message ProductListHeaderImage
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.ProductListHeaderImage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ProductListHeaderImage a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un ProductListInfo. */
            interface IProductListInfo {

                /** ProductListInfo productSections */
                productSections?: (proto.Message.ListMessage.IProductSection[]|null);

                /** ProductListInfo headerImage */
                headerImage?: (proto.Message.ListMessage.IProductListHeaderImage|null);

                /** ProductListInfo businessOwnerJid */
                businessOwnerJid?: (string|null);
            }

            /** Representa un ProductListInfo. */
            class ProductListInfo implements IProductListInfo {

                /**
                 * Construya un nuevo ProductListInfo.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.IProductListInfo);

                /** ProductListInfo productSections. */
                public productSections: proto.Message.ListMessage.IProductSection[];

                /** ProductListInfo headerImage. */
                public headerImage?: (proto.Message.ListMessage.IProductListHeaderImage|null);

                /** ProductListInfo businessOwnerJid. */
                public businessOwnerJid: string;

                /**
                 * Crea una nueva instancia ProductListInfo utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ProductListInfo instance
                 */
                public static create(properties?: proto.Message.ListMessage.IProductListInfo): proto.Message.ListMessage.ProductListInfo;

                /**
                 * Codifica el mensaje ProductListInfo. No implícitamente mensajes {@link proto.Message.ListMessage.ProductListInfo.verify|verify}.
                 * @param message ProductListInfo mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.IProductListInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ProductListInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.ProductListInfo.verify|verify}.
                 * @param message ProductListInfo mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.IProductListInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ProductListInfo message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ProductListInfo
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.ProductListInfo;

                /**
                 * Decodes a ProductListInfo message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ProductListInfo
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.ProductListInfo;

                /**
                 * Verifies a ProductListInfo message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ProductListInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ProductListInfo
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.ProductListInfo;

                /**
                 * Crea un objeto simple desde ProductListInfo. También convierte valores a otros tipos si se especifica.
                 * @param message ProductListInfo
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.ProductListInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ProductListInfo a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un ProductSection. */
            interface IProductSection {

                /** ProductSection title */
                title?: (string|null);

                /** ProductSection products */
                products?: (proto.Message.ListMessage.IProduct[]|null);
            }

            /** Representa un ProductSection. */
            class ProductSection implements IProductSection {

                /**
                 * Construya un nuevo ProductSection.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.IProductSection);

                /** ProductSection title. */
                public title: string;

                /** ProductSection products. */
                public products: proto.Message.ListMessage.IProduct[];

                /**
                 * Crea una nueva instancia ProductSection utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ProductSection instance
                 */
                public static create(properties?: proto.Message.ListMessage.IProductSection): proto.Message.ListMessage.ProductSection;

                /**
                 * Codifica el mensaje ProductSection. No implícitamente mensajes {@link proto.Message.ListMessage.ProductSection.verify|verify}.
                 * @param message ProductSection mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.IProductSection, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ProductSection message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.ProductSection.verify|verify}.
                 * @param message ProductSection mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.IProductSection, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ProductSection message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ProductSection
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.ProductSection;

                /**
                 * Decodes a ProductSection message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ProductSection
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.ProductSection;

                /**
                 * Verifies a ProductSection message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ProductSection message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ProductSection
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.ProductSection;

                /**
                 * Crea un objeto simple desde ProductSection. También convierte valores a otros tipos si se especifica.
                 * @param message ProductSection
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.ProductSection, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ProductSection a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un Row. */
            interface IRow {

                /** Row title */
                title?: (string|null);

                /** Row description */
                description?: (string|null);

                /** Row rowId */
                rowId?: (string|null);
            }

            /** Representa un Row. */
            class Row implements IRow {

                /**
                 * Construya un nuevo Row.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.IRow);

                /** Row title. */
                public title: string;

                /** Row description. */
                public description: string;

                /** Row rowId. */
                public rowId: string;

                /**
                 * Crea una nueva instancia Row utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Row instance
                 */
                public static create(properties?: proto.Message.ListMessage.IRow): proto.Message.ListMessage.Row;

                /**
                 * Codifica el mensaje Row. No implícitamente mensajes {@link proto.Message.ListMessage.Row.verify|verify}.
                 * @param message Row mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.IRow, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Row message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.Row.verify|verify}.
                 * @param message Row mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.IRow, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Row message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Row
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.Row;

                /**
                 * Decodes a Row message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Row
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.Row;

                /**
                 * Verifies a Row message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Row message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Row
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.Row;

                /**
                 * Crea un objeto simple desde Row. También convierte valores a otros tipos si se especifica.
                 * @param message Row
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.Row, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Row a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un Section. */
            interface ISection {

                /** Section title */
                title?: (string|null);

                /** Section rows */
                rows?: (proto.Message.ListMessage.IRow[]|null);
            }

            /** Representa un Section. */
            class Section implements ISection {

                /**
                 * Construya un nuevo Section.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListMessage.ISection);

                /** Section title. */
                public title: string;

                /** Section rows. */
                public rows: proto.Message.ListMessage.IRow[];

                /**
                 * Crea una nueva instancia Section utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Section instance
                 */
                public static create(properties?: proto.Message.ListMessage.ISection): proto.Message.ListMessage.Section;

                /**
                 * Codifica el mensaje Section. No implícitamente mensajes {@link proto.Message.ListMessage.Section.verify|verify}.
                 * @param message Section mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListMessage.ISection, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Section message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListMessage.Section.verify|verify}.
                 * @param message Section mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListMessage.ISection, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Section message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Section
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListMessage.Section;

                /**
                 * Decodes a Section message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Section
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListMessage.Section;

                /**
                 * Verifies a Section message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Section message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Section
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListMessage.Section;

                /**
                 * Crea un objeto simple desde Section. También convierte valores a otros tipos si se especifica.
                 * @param message Section
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListMessage.Section, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Section a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un ListResponseMessage. */
        interface IListResponseMessage {

            /** ListResponseMessage title */
            title?: (string|null);

            /** ListResponseMessage listType */
            listType?: (proto.Message.ListResponseMessage.ListType|null);

            /** ListResponseMessage singleSelectReply */
            singleSelectReply?: (proto.Message.ListResponseMessage.ISingleSelectReply|null);

            /** ListResponseMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** ListResponseMessage description */
            description?: (string|null);
        }

        /** Representa un ListResponseMessage. */
        class ListResponseMessage implements IListResponseMessage {

            /**
             * Construya un nuevo ListResponseMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IListResponseMessage);

            /** ListResponseMessage title. */
            public title: string;

            /** ListResponseMessage listType. */
            public listType: proto.Message.ListResponseMessage.ListType;

            /** ListResponseMessage singleSelectReply. */
            public singleSelectReply?: (proto.Message.ListResponseMessage.ISingleSelectReply|null);

            /** ListResponseMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** ListResponseMessage description. */
            public description: string;

            /**
             * Crea una nueva instancia ListResponseMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ListResponseMessage instance
             */
            public static create(properties?: proto.Message.IListResponseMessage): proto.Message.ListResponseMessage;

            /**
             * Codifica el mensaje ListResponseMessage. No implícitamente mensajes {@link proto.Message.ListResponseMessage.verify|verify}.
             * @param message ListResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IListResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ListResponseMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListResponseMessage.verify|verify}.
             * @param message ListResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IListResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ListResponseMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ListResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListResponseMessage;

            /**
             * Decodes a ListResponseMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ListResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListResponseMessage;

            /**
             * Verifies a ListResponseMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ListResponseMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ListResponseMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ListResponseMessage;

            /**
             * Crea un objeto simple desde ListResponseMessage. También convierte valores a otros tipos si se especifica.
             * @param message ListResponseMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ListResponseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ListResponseMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ListResponseMessage {

            /** ListType enum. */
            enum ListType {
                UNKNOWN = 0,
                SINGLE_SELECT = 1
            }

            /** Propiedades de un SingleSelectReply. */
            interface ISingleSelectReply {

                /** SingleSelectReply selectedRowId */
                selectedRowId?: (string|null);
            }

            /** Representa un SingleSelectReply. */
            class SingleSelectReply implements ISingleSelectReply {

                /**
                 * Construya un nuevo SingleSelectReply.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ListResponseMessage.ISingleSelectReply);

                /** SingleSelectReply selectedRowId. */
                public selectedRowId: string;

                /**
                 * Crea una nueva instancia SingleSelectReply utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns SingleSelectReply instance
                 */
                public static create(properties?: proto.Message.ListResponseMessage.ISingleSelectReply): proto.Message.ListResponseMessage.SingleSelectReply;

                /**
                 * Codifica el mensaje SingleSelectReply. No implícitamente mensajes {@link proto.Message.ListResponseMessage.SingleSelectReply.verify|verify}.
                 * @param message SingleSelectReply mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ListResponseMessage.ISingleSelectReply, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje SingleSelectReply message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ListResponseMessage.SingleSelectReply.verify|verify}.
                 * @param message SingleSelectReply mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ListResponseMessage.ISingleSelectReply, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SingleSelectReply message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns SingleSelectReply
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ListResponseMessage.SingleSelectReply;

                /**
                 * Decodes a SingleSelectReply message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns SingleSelectReply
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ListResponseMessage.SingleSelectReply;

                /**
                 * Verifies a SingleSelectReply message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SingleSelectReply message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns SingleSelectReply
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ListResponseMessage.SingleSelectReply;

                /**
                 * Crea un objeto simple desde SingleSelectReply. También convierte valores a otros tipos si se especifica.
                 * @param message SingleSelectReply
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ListResponseMessage.SingleSelectReply, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  SingleSelectReply a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un LiveLocationMessage. */
        interface ILiveLocationMessage {

            /** LiveLocationMessage degreesLatitude */
            degreesLatitude?: (number|null);

            /** LiveLocationMessage degreesLongitude */
            degreesLongitude?: (number|null);

            /** LiveLocationMessage accuracyInMeters */
            accuracyInMeters?: (number|null);

            /** LiveLocationMessage speedInMps */
            speedInMps?: (number|null);

            /** LiveLocationMessage degreesClockwiseFromMagneticNorth */
            degreesClockwiseFromMagneticNorth?: (number|null);

            /** LiveLocationMessage caption */
            caption?: (string|null);

            /** LiveLocationMessage sequenceNumber */
            sequenceNumber?: (number|Long|null);

            /** LiveLocationMessage timeOffset */
            timeOffset?: (number|null);

            /** LiveLocationMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** LiveLocationMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un LiveLocationMessage. */
        class LiveLocationMessage implements ILiveLocationMessage {

            /**
             * Construya un nuevo LiveLocationMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ILiveLocationMessage);

            /** LiveLocationMessage degreesLatitude. */
            public degreesLatitude: number;

            /** LiveLocationMessage degreesLongitude. */
            public degreesLongitude: number;

            /** LiveLocationMessage accuracyInMeters. */
            public accuracyInMeters: number;

            /** LiveLocationMessage speedInMps. */
            public speedInMps: number;

            /** LiveLocationMessage degreesClockwiseFromMagneticNorth. */
            public degreesClockwiseFromMagneticNorth: number;

            /** LiveLocationMessage caption. */
            public caption: string;

            /** LiveLocationMessage sequenceNumber. */
            public sequenceNumber: (number|Long);

            /** LiveLocationMessage timeOffset. */
            public timeOffset: number;

            /** LiveLocationMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** LiveLocationMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia LiveLocationMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns LiveLocationMessage instance
             */
            public static create(properties?: proto.Message.ILiveLocationMessage): proto.Message.LiveLocationMessage;

            /**
             * Codifica el mensaje LiveLocationMessage. No implícitamente mensajes {@link proto.Message.LiveLocationMessage.verify|verify}.
             * @param message LiveLocationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ILiveLocationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje LiveLocationMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.LiveLocationMessage.verify|verify}.
             * @param message LiveLocationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ILiveLocationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LiveLocationMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns LiveLocationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.LiveLocationMessage;

            /**
             * Decodes a LiveLocationMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns LiveLocationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.LiveLocationMessage;

            /**
             * Verifies a LiveLocationMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a LiveLocationMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns LiveLocationMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.LiveLocationMessage;

            /**
             * Crea un objeto simple desde LiveLocationMessage. También convierte valores a otros tipos si se especifica.
             * @param message LiveLocationMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.LiveLocationMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  LiveLocationMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un LocationMessage. */
        interface ILocationMessage {

            /** LocationMessage degreesLatitude */
            degreesLatitude?: (number|null);

            /** LocationMessage degreesLongitude */
            degreesLongitude?: (number|null);

            /** LocationMessage name */
            name?: (string|null);

            /** LocationMessage address */
            address?: (string|null);

            /** LocationMessage url */
            url?: (string|null);

            /** LocationMessage isLive */
            isLive?: (boolean|null);

            /** LocationMessage accuracyInMeters */
            accuracyInMeters?: (number|null);

            /** LocationMessage speedInMps */
            speedInMps?: (number|null);

            /** LocationMessage degreesClockwiseFromMagneticNorth */
            degreesClockwiseFromMagneticNorth?: (number|null);

            /** LocationMessage comment */
            comment?: (string|null);

            /** LocationMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** LocationMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un LocationMessage. */
        class LocationMessage implements ILocationMessage {

            /**
             * Construya un nuevo LocationMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ILocationMessage);

            /** LocationMessage degreesLatitude. */
            public degreesLatitude: number;

            /** LocationMessage degreesLongitude. */
            public degreesLongitude: number;

            /** LocationMessage name. */
            public name: string;

            /** LocationMessage address. */
            public address: string;

            /** LocationMessage url. */
            public url: string;

            /** LocationMessage isLive. */
            public isLive: boolean;

            /** LocationMessage accuracyInMeters. */
            public accuracyInMeters: number;

            /** LocationMessage speedInMps. */
            public speedInMps: number;

            /** LocationMessage degreesClockwiseFromMagneticNorth. */
            public degreesClockwiseFromMagneticNorth: number;

            /** LocationMessage comment. */
            public comment: string;

            /** LocationMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** LocationMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia LocationMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns LocationMessage instance
             */
            public static create(properties?: proto.Message.ILocationMessage): proto.Message.LocationMessage;

            /**
             * Codifica el mensaje LocationMessage. No implícitamente mensajes {@link proto.Message.LocationMessage.verify|verify}.
             * @param message LocationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ILocationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje LocationMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.LocationMessage.verify|verify}.
             * @param message LocationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ILocationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LocationMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns LocationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.LocationMessage;

            /**
             * Decodes a LocationMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns LocationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.LocationMessage;

            /**
             * Verifies a LocationMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a LocationMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns LocationMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.LocationMessage;

            /**
             * Crea un objeto simple desde LocationMessage. También convierte valores a otros tipos si se especifica.
             * @param message LocationMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.LocationMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  LocationMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn OrderMessage. */
        interface IOrderMessage {

            /** OrderMessage orderId */
            orderId?: (string|null);

            /** OrderMessage thumbnail */
            thumbnail?: (Uint8Array|null);

            /** OrderMessage itemCount */
            itemCount?: (number|null);

            /** OrderMessage status */
            status?: (proto.Message.OrderMessage.OrderStatus|null);

            /** OrderMessage surface */
            surface?: (proto.Message.OrderMessage.OrderSurface|null);

            /** OrderMessage message */
            message?: (string|null);

            /** OrderMessage orderTitle */
            orderTitle?: (string|null);

            /** OrderMessage sellerJid */
            sellerJid?: (string|null);

            /** OrderMessage token */
            token?: (string|null);

            /** OrderMessage totalAmount1000 */
            totalAmount1000?: (number|Long|null);

            /** OrderMessage totalCurrencyCode */
            totalCurrencyCode?: (string|null);

            /** OrderMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa unn OrderMessage. */
        class OrderMessage implements IOrderMessage {

            /**
             * Construya un nuevo OrderMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IOrderMessage);

            /** OrderMessage orderId. */
            public orderId: string;

            /** OrderMessage thumbnail. */
            public thumbnail: Uint8Array;

            /** OrderMessage itemCount. */
            public itemCount: number;

            /** OrderMessage status. */
            public status: proto.Message.OrderMessage.OrderStatus;

            /** OrderMessage surface. */
            public surface: proto.Message.OrderMessage.OrderSurface;

            /** OrderMessage message. */
            public message: string;

            /** OrderMessage orderTitle. */
            public orderTitle: string;

            /** OrderMessage sellerJid. */
            public sellerJid: string;

            /** OrderMessage token. */
            public token: string;

            /** OrderMessage totalAmount1000. */
            public totalAmount1000: (number|Long);

            /** OrderMessage totalCurrencyCode. */
            public totalCurrencyCode: string;

            /** OrderMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia OrderMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns OrderMessage instance
             */
            public static create(properties?: proto.Message.IOrderMessage): proto.Message.OrderMessage;

            /**
             * Codifica el mensaje OrderMessage. No implícitamente mensajes {@link proto.Message.OrderMessage.verify|verify}.
             * @param message OrderMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IOrderMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje OrderMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.OrderMessage.verify|verify}.
             * @param message OrderMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IOrderMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an OrderMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns OrderMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.OrderMessage;

            /**
             * Decodes an OrderMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns OrderMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.OrderMessage;

            /**
             * Verifies an OrderMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an OrderMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns OrderMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.OrderMessage;

            /**
             * Crea un objeto simple desden OrderMessage. También convierte valores a otros tipos si se especifica.
             * @param message OrderMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.OrderMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  OrderMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace OrderMessage {

            /** OrderStatus enum. */
            enum OrderStatus {
                INQUIRY = 1
            }

            /** OrderSurface enum. */
            enum OrderSurface {
                CATALOG = 1
            }
        }

        /** Propiedades de un PaymentInviteMessage. */
        interface IPaymentInviteMessage {

            /** PaymentInviteMessage serviceType */
            serviceType?: (proto.Message.PaymentInviteMessage.ServiceType|null);

            /** PaymentInviteMessage expiryTimestamp */
            expiryTimestamp?: (number|Long|null);
        }

        /** Representa un PaymentInviteMessage. */
        class PaymentInviteMessage implements IPaymentInviteMessage {

            /**
             * Construya un nuevo PaymentInviteMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPaymentInviteMessage);

            /** PaymentInviteMessage serviceType. */
            public serviceType: proto.Message.PaymentInviteMessage.ServiceType;

            /** PaymentInviteMessage expiryTimestamp. */
            public expiryTimestamp: (number|Long);

            /**
             * Crea una nueva instancia PaymentInviteMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PaymentInviteMessage instance
             */
            public static create(properties?: proto.Message.IPaymentInviteMessage): proto.Message.PaymentInviteMessage;

            /**
             * Codifica el mensaje PaymentInviteMessage. No implícitamente mensajes {@link proto.Message.PaymentInviteMessage.verify|verify}.
             * @param message PaymentInviteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPaymentInviteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PaymentInviteMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PaymentInviteMessage.verify|verify}.
             * @param message PaymentInviteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPaymentInviteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PaymentInviteMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PaymentInviteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PaymentInviteMessage;

            /**
             * Decodes a PaymentInviteMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PaymentInviteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PaymentInviteMessage;

            /**
             * Verifies a PaymentInviteMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PaymentInviteMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PaymentInviteMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PaymentInviteMessage;

            /**
             * Crea un objeto simple desde PaymentInviteMessage. También convierte valores a otros tipos si se especifica.
             * @param message PaymentInviteMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PaymentInviteMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PaymentInviteMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace PaymentInviteMessage {

            /** ServiceType enum. */
            enum ServiceType {
                UNKNOWN = 0,
                FBPAY = 1,
                NOVI = 2,
                UPI = 3
            }
        }

        /** Propiedades de un PeerDataOperationRequestMessage. */
        interface IPeerDataOperationRequestMessage {

            /** PeerDataOperationRequestMessage peerDataOperationRequestType */
            peerDataOperationRequestType?: (proto.Message.PeerDataOperationRequestType|null);

            /** PeerDataOperationRequestMessage requestStickerReupload */
            requestStickerReupload?: (proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload[]|null);

            /** PeerDataOperationRequestMessage requestUrlPreview */
            requestUrlPreview?: (proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview[]|null);

            /** PeerDataOperationRequestMessage historySyncOnDemandRequest */
            historySyncOnDemandRequest?: (proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest|null);
        }

        /** Representa un PeerDataOperationRequestMessage. */
        class PeerDataOperationRequestMessage implements IPeerDataOperationRequestMessage {

            /**
             * Construya un nuevo PeerDataOperationRequestMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPeerDataOperationRequestMessage);

            /** PeerDataOperationRequestMessage peerDataOperationRequestType. */
            public peerDataOperationRequestType: proto.Message.PeerDataOperationRequestType;

            /** PeerDataOperationRequestMessage requestStickerReupload. */
            public requestStickerReupload: proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload[];

            /** PeerDataOperationRequestMessage requestUrlPreview. */
            public requestUrlPreview: proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview[];

            /** PeerDataOperationRequestMessage historySyncOnDemandRequest. */
            public historySyncOnDemandRequest?: (proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest|null);

            /**
             * Crea una nueva instancia PeerDataOperationRequestMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PeerDataOperationRequestMessage instance
             */
            public static create(properties?: proto.Message.IPeerDataOperationRequestMessage): proto.Message.PeerDataOperationRequestMessage;

            /**
             * Codifica el mensaje PeerDataOperationRequestMessage. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.verify|verify}.
             * @param message PeerDataOperationRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPeerDataOperationRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PeerDataOperationRequestMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.verify|verify}.
             * @param message PeerDataOperationRequestMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPeerDataOperationRequestMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PeerDataOperationRequestMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PeerDataOperationRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestMessage;

            /**
             * Decodes a PeerDataOperationRequestMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PeerDataOperationRequestMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestMessage;

            /**
             * Verifies a PeerDataOperationRequestMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PeerDataOperationRequestMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PeerDataOperationRequestMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestMessage;

            /**
             * Crea un objeto simple desde PeerDataOperationRequestMessage. También convierte valores a otros tipos si se especifica.
             * @param message PeerDataOperationRequestMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PeerDataOperationRequestMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PeerDataOperationRequestMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace PeerDataOperationRequestMessage {

            /** Propiedades de un HistorySyncOnDemandRequest. */
            interface IHistorySyncOnDemandRequest {

                /** HistorySyncOnDemandRequest chatJid */
                chatJid?: (string|null);

                /** HistorySyncOnDemandRequest oldestMsgId */
                oldestMsgId?: (string|null);

                /** HistorySyncOnDemandRequest oldestMsgFromMe */
                oldestMsgFromMe?: (boolean|null);

                /** HistorySyncOnDemandRequest onDemandMsgCount */
                onDemandMsgCount?: (number|null);

                /** HistorySyncOnDemandRequest oldestMsgTimestampMs */
                oldestMsgTimestampMs?: (number|Long|null);
            }

            /** Representa un HistorySyncOnDemandRequest. */
            class HistorySyncOnDemandRequest implements IHistorySyncOnDemandRequest {

                /**
                 * Construya un nuevo HistorySyncOnDemandRequest.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest);

                /** HistorySyncOnDemandRequest chatJid. */
                public chatJid: string;

                /** HistorySyncOnDemandRequest oldestMsgId. */
                public oldestMsgId: string;

                /** HistorySyncOnDemandRequest oldestMsgFromMe. */
                public oldestMsgFromMe: boolean;

                /** HistorySyncOnDemandRequest onDemandMsgCount. */
                public onDemandMsgCount: number;

                /** HistorySyncOnDemandRequest oldestMsgTimestampMs. */
                public oldestMsgTimestampMs: (number|Long);

                /**
                 * Crea una nueva instancia HistorySyncOnDemandRequest utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns HistorySyncOnDemandRequest instance
                 */
                public static create(properties?: proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest): proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest;

                /**
                 * Codifica el mensaje HistorySyncOnDemandRequest. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest.verify|verify}.
                 * @param message HistorySyncOnDemandRequest mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje HistorySyncOnDemandRequest message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest.verify|verify}.
                 * @param message HistorySyncOnDemandRequest mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.PeerDataOperationRequestMessage.IHistorySyncOnDemandRequest, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HistorySyncOnDemandRequest message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns HistorySyncOnDemandRequest
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest;

                /**
                 * Decodes a HistorySyncOnDemandRequest message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns HistorySyncOnDemandRequest
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest;

                /**
                 * Verifies a HistorySyncOnDemandRequest message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a HistorySyncOnDemandRequest message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns HistorySyncOnDemandRequest
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest;

                /**
                 * Crea un objeto simple desde HistorySyncOnDemandRequest. También convierte valores a otros tipos si se especifica.
                 * @param message HistorySyncOnDemandRequest
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.PeerDataOperationRequestMessage.HistorySyncOnDemandRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  HistorySyncOnDemandRequest a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un RequestStickerReupload. */
            interface IRequestStickerReupload {

                /** RequestStickerReupload fileSha256 */
                fileSha256?: (string|null);
            }

            /** Representa un RequestStickerReupload. */
            class RequestStickerReupload implements IRequestStickerReupload {

                /**
                 * Construya un nuevo RequestStickerReupload.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload);

                /** RequestStickerReupload fileSha256. */
                public fileSha256: string;

                /**
                 * Crea una nueva instancia RequestStickerReupload utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns RequestStickerReupload instance
                 */
                public static create(properties?: proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload): proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload;

                /**
                 * Codifica el mensaje RequestStickerReupload. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.verify|verify}.
                 * @param message RequestStickerReupload mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje RequestStickerReupload message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.verify|verify}.
                 * @param message RequestStickerReupload mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RequestStickerReupload message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns RequestStickerReupload
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload;

                /**
                 * Decodes a RequestStickerReupload message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns RequestStickerReupload
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload;

                /**
                 * Verifies a RequestStickerReupload message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RequestStickerReupload message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns RequestStickerReupload
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload;

                /**
                 * Crea un objeto simple desde RequestStickerReupload. También convierte valores a otros tipos si se especifica.
                 * @param message RequestStickerReupload
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  RequestStickerReupload a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un RequestUrlPreview. */
            interface IRequestUrlPreview {

                /** RequestUrlPreview url */
                url?: (string|null);
            }

            /** Representa un RequestUrlPreview. */
            class RequestUrlPreview implements IRequestUrlPreview {

                /**
                 * Construya un nuevo RequestUrlPreview.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview);

                /** RequestUrlPreview url. */
                public url: string;

                /**
                 * Crea una nueva instancia RequestUrlPreview utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns RequestUrlPreview instance
                 */
                public static create(properties?: proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview): proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview;

                /**
                 * Codifica el mensaje RequestUrlPreview. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.verify|verify}.
                 * @param message RequestUrlPreview mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje RequestUrlPreview message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.verify|verify}.
                 * @param message RequestUrlPreview mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RequestUrlPreview message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns RequestUrlPreview
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview;

                /**
                 * Decodes a RequestUrlPreview message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns RequestUrlPreview
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview;

                /**
                 * Verifies a RequestUrlPreview message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RequestUrlPreview message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns RequestUrlPreview
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview;

                /**
                 * Crea un objeto simple desde RequestUrlPreview. También convierte valores a otros tipos si se especifica.
                 * @param message RequestUrlPreview
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  RequestUrlPreview a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un PeerDataOperationRequestResponseMessage. */
        interface IPeerDataOperationRequestResponseMessage {

            /** PeerDataOperationRequestResponseMessage peerDataOperationRequestType */
            peerDataOperationRequestType?: (proto.Message.PeerDataOperationRequestType|null);

            /** PeerDataOperationRequestResponseMessage stanzaId */
            stanzaId?: (string|null);

            /** PeerDataOperationRequestResponseMessage peerDataOperationResult */
            peerDataOperationResult?: (proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult[]|null);
        }

        /** Representa un PeerDataOperationRequestResponseMessage. */
        class PeerDataOperationRequestResponseMessage implements IPeerDataOperationRequestResponseMessage {

            /**
             * Construya un nuevo PeerDataOperationRequestResponseMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPeerDataOperationRequestResponseMessage);

            /** PeerDataOperationRequestResponseMessage peerDataOperationRequestType. */
            public peerDataOperationRequestType: proto.Message.PeerDataOperationRequestType;

            /** PeerDataOperationRequestResponseMessage stanzaId. */
            public stanzaId: string;

            /** PeerDataOperationRequestResponseMessage peerDataOperationResult. */
            public peerDataOperationResult: proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult[];

            /**
             * Crea una nueva instancia PeerDataOperationRequestResponseMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PeerDataOperationRequestResponseMessage instance
             */
            public static create(properties?: proto.Message.IPeerDataOperationRequestResponseMessage): proto.Message.PeerDataOperationRequestResponseMessage;

            /**
             * Codifica el mensaje PeerDataOperationRequestResponseMessage. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.verify|verify}.
             * @param message PeerDataOperationRequestResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPeerDataOperationRequestResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PeerDataOperationRequestResponseMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.verify|verify}.
             * @param message PeerDataOperationRequestResponseMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPeerDataOperationRequestResponseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PeerDataOperationRequestResponseMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PeerDataOperationRequestResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestResponseMessage;

            /**
             * Decodes a PeerDataOperationRequestResponseMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PeerDataOperationRequestResponseMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestResponseMessage;

            /**
             * Verifies a PeerDataOperationRequestResponseMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PeerDataOperationRequestResponseMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PeerDataOperationRequestResponseMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestResponseMessage;

            /**
             * Crea un objeto simple desde PeerDataOperationRequestResponseMessage. También convierte valores a otros tipos si se especifica.
             * @param message PeerDataOperationRequestResponseMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PeerDataOperationRequestResponseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PeerDataOperationRequestResponseMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace PeerDataOperationRequestResponseMessage {

            /** Propiedades de un PeerDataOperationResult. */
            interface IPeerDataOperationResult {

                /** PeerDataOperationResult mediaUploadResult */
                mediaUploadResult?: (proto.MediaRetryNotification.ResultType|null);

                /** PeerDataOperationResult stickerMessage */
                stickerMessage?: (proto.Message.IStickerMessage|null);

                /** PeerDataOperationResult linkPreviewResponse */
                linkPreviewResponse?: (proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse|null);
            }

            /** Representa un PeerDataOperationResult. */
            class PeerDataOperationResult implements IPeerDataOperationResult {

                /**
                 * Construya un nuevo PeerDataOperationResult.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult);

                /** PeerDataOperationResult mediaUploadResult. */
                public mediaUploadResult: proto.MediaRetryNotification.ResultType;

                /** PeerDataOperationResult stickerMessage. */
                public stickerMessage?: (proto.Message.IStickerMessage|null);

                /** PeerDataOperationResult linkPreviewResponse. */
                public linkPreviewResponse?: (proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse|null);

                /**
                 * Crea una nueva instancia PeerDataOperationResult utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns PeerDataOperationResult instance
                 */
                public static create(properties?: proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult;

                /**
                 * Codifica el mensaje PeerDataOperationResult. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.verify|verify}.
                 * @param message PeerDataOperationResult mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje PeerDataOperationResult message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.verify|verify}.
                 * @param message PeerDataOperationResult mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PeerDataOperationResult message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns PeerDataOperationResult
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult;

                /**
                 * Decodes a PeerDataOperationResult message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns PeerDataOperationResult
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult;

                /**
                 * Verifies a PeerDataOperationResult message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PeerDataOperationResult message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns PeerDataOperationResult
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult;

                /**
                 * Crea un objeto simple desde PeerDataOperationResult. También convierte valores a otros tipos si se especifica.
                 * @param message PeerDataOperationResult
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  PeerDataOperationResult a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace PeerDataOperationResult {

                /** Propiedades de un LinkPreviewResponse. */
                interface ILinkPreviewResponse {

                    /** LinkPreviewResponse url */
                    url?: (string|null);

                    /** LinkPreviewResponse title */
                    title?: (string|null);

                    /** LinkPreviewResponse description */
                    description?: (string|null);

                    /** LinkPreviewResponse thumbData */
                    thumbData?: (Uint8Array|null);

                    /** LinkPreviewResponse canonicalUrl */
                    canonicalUrl?: (string|null);

                    /** LinkPreviewResponse matchText */
                    matchText?: (string|null);

                    /** LinkPreviewResponse previewType */
                    previewType?: (string|null);
                }

                /** Representa un LinkPreviewResponse. */
                class LinkPreviewResponse implements ILinkPreviewResponse {

                    /**
                     * Construya un nuevo LinkPreviewResponse.
                     * @param [properties] para establecer propiedades
                     */
                    constructor(properties?: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse);

                    /** LinkPreviewResponse url. */
                    public url: string;

                    /** LinkPreviewResponse title. */
                    public title: string;

                    /** LinkPreviewResponse description. */
                    public description: string;

                    /** LinkPreviewResponse thumbData. */
                    public thumbData: Uint8Array;

                    /** LinkPreviewResponse canonicalUrl. */
                    public canonicalUrl: string;

                    /** LinkPreviewResponse matchText. */
                    public matchText: string;

                    /** LinkPreviewResponse previewType. */
                    public previewType: string;

                    /**
                     * Crea una nueva instancia LinkPreviewResponse utilizando las propiedades especificadas.
                     * @param [properties] para establecer propiedades
                     * @returns LinkPreviewResponse instance
                     */
                    public static create(properties?: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse;

                    /**
                     * Codifica el mensaje LinkPreviewResponse. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.verify|verify}.
                     * @param message LinkPreviewResponse mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encode(message: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Codifica el mensaje LinkPreviewResponse message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.verify|verify}.
                     * @param message LinkPreviewResponse mensaje o objeto simple para codificar
                     * @param [writer] Writer para codificar a
                     * @returns Writer
                     */
                    public static encodeDelimited(message: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a LinkPreviewResponse message from the specified reader or buffer.
                     * @param reader Reader o búfer para decodificar desde
                     * @param [length] Longitud del mensaje si se conoce de antemano
                     * @returns LinkPreviewResponse
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse;

                    /**
                     * Decodes a LinkPreviewResponse message desde el especifico lector o búfer, longitud delimitada.
                     * @param reader Reader o búfer para decodificar desde
                     * @returns LinkPreviewResponse
                     * @throws {Error} Si la carga útil no es un lector o un búfer válido
                     * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse;

                    /**
                     * Verifies a LinkPreviewResponse message.
                     * @param message Objeto simple para verificar
                     * @returns `null` Si es válido, de lo contrario la razón por la que no es
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a LinkPreviewResponse message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                     * @param object Objeto simple
                     * @returns LinkPreviewResponse
                     */
                    public static fromObject(object: { [k: string]: any }): proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse;

                    /**
                     * Crea un objeto simple desde LinkPreviewResponse. También convierte valores a otros tipos si se especifica.
                     * @param message LinkPreviewResponse
                     * @param [options] Opciones de conversión
                     * @returns Objeto simple
                     */
                    public static toObject(message: proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Convierte este  LinkPreviewResponse a JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }
        }

        /** PeerDataOperationRequestType enum. */
        enum PeerDataOperationRequestType {
            UPLOAD_STICKER = 0,
            SEND_RECENT_STICKER_BOOTSTRAP = 1,
            GENERATE_LINK_PREVIEW = 2,
            HISTORY_SYNC_ON_DEMAND = 3
        }

        /** Propiedades de un PinMessage. */
        interface IPinMessage {

            /** PinMessage key */
            key?: (proto.IMessageKey|null);

            /** PinMessage pinMessageType */
            pinMessageType?: (proto.Message.PinMessage.PinMessageType|null);

            /** PinMessage senderTimestampMs */
            senderTimestampMs?: (number|Long|null);
        }

        /** Representa un PinMessage. */
        class PinMessage implements IPinMessage {

            /**
             * Construya un nuevo PinMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPinMessage);

            /** PinMessage key. */
            public key?: (proto.IMessageKey|null);

            /** PinMessage pinMessageType. */
            public pinMessageType: proto.Message.PinMessage.PinMessageType;

            /** PinMessage senderTimestampMs. */
            public senderTimestampMs: (number|Long);

            /**
             * Crea una nueva instancia PinMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PinMessage instance
             */
            public static create(properties?: proto.Message.IPinMessage): proto.Message.PinMessage;

            /**
             * Codifica el mensaje PinMessage. No implícitamente mensajes {@link proto.Message.PinMessage.verify|verify}.
             * @param message PinMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPinMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PinMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PinMessage.verify|verify}.
             * @param message PinMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPinMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PinMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PinMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PinMessage;

            /**
             * Decodes a PinMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PinMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PinMessage;

            /**
             * Verifies a PinMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PinMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PinMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PinMessage;

            /**
             * Crea un objeto simple desde PinMessage. También convierte valores a otros tipos si se especifica.
             * @param message PinMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PinMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PinMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace PinMessage {

            /** PinMessageType enum. */
            enum PinMessageType {
                UNKNOWN_PIN_MESSAGE_TYPE = 0,
                PIN_FOR_ALL = 1,
                UNPIN_FOR_ALL = 2
            }
        }

        /** Propiedades de un PollCreationMessage. */
        interface IPollCreationMessage {

            /** PollCreationMessage encKey */
            encKey?: (Uint8Array|null);

            /** PollCreationMessage name */
            name?: (string|null);

            /** PollCreationMessage options */
            options?: (proto.Message.PollCreationMessage.IOption[]|null);

            /** PollCreationMessage selectableOptionsCount */
            selectableOptionsCount?: (number|null);

            /** PollCreationMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un PollCreationMessage. */
        class PollCreationMessage implements IPollCreationMessage {

            /**
             * Construya un nuevo PollCreationMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPollCreationMessage);

            /** PollCreationMessage encKey. */
            public encKey: Uint8Array;

            /** PollCreationMessage name. */
            public name: string;

            /** PollCreationMessage options. */
            public options: proto.Message.PollCreationMessage.IOption[];

            /** PollCreationMessage selectableOptionsCount. */
            public selectableOptionsCount: number;

            /** PollCreationMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia PollCreationMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollCreationMessage instance
             */
            public static create(properties?: proto.Message.IPollCreationMessage): proto.Message.PollCreationMessage;

            /**
             * Codifica el mensaje PollCreationMessage. No implícitamente mensajes {@link proto.Message.PollCreationMessage.verify|verify}.
             * @param message PollCreationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPollCreationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollCreationMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollCreationMessage.verify|verify}.
             * @param message PollCreationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPollCreationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollCreationMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollCreationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollCreationMessage;

            /**
             * Decodes a PollCreationMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollCreationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollCreationMessage;

            /**
             * Verifies a PollCreationMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollCreationMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollCreationMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PollCreationMessage;

            /**
             * Crea un objeto simple desde PollCreationMessage. También convierte valores a otros tipos si se especifica.
             * @param message PollCreationMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PollCreationMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollCreationMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace PollCreationMessage {

            /** Propiedades de unn Option. */
            interface IOption {

                /** Option optionName */
                optionName?: (string|null);
            }

            /** Representa unn Option. */
            class Option implements IOption {

                /**
                 * Construya un nuevo Option.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.PollCreationMessage.IOption);

                /** Option optionName. */
                public optionName: string;

                /**
                 * Crea una nueva instancia Option utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns Option instance
                 */
                public static create(properties?: proto.Message.PollCreationMessage.IOption): proto.Message.PollCreationMessage.Option;

                /**
                 * Codifica el mensaje Option. No implícitamente mensajes {@link proto.Message.PollCreationMessage.Option.verify|verify}.
                 * @param message Option mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.PollCreationMessage.IOption, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje Option message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollCreationMessage.Option.verify|verify}.
                 * @param message Option mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.PollCreationMessage.IOption, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Option message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns Option
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollCreationMessage.Option;

                /**
                 * Decodes an Option message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns Option
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollCreationMessage.Option;

                /**
                 * Verifies an Option message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Option message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns Option
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.PollCreationMessage.Option;

                /**
                 * Crea un objeto simple desden Option. También convierte valores a otros tipos si se especifica.
                 * @param message Option
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.PollCreationMessage.Option, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  Option a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un PollEncValue. */
        interface IPollEncValue {

            /** PollEncValue encPayload */
            encPayload?: (Uint8Array|null);

            /** PollEncValue encIv */
            encIv?: (Uint8Array|null);
        }

        /** Representa un PollEncValue. */
        class PollEncValue implements IPollEncValue {

            /**
             * Construya un nuevo PollEncValue.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPollEncValue);

            /** PollEncValue encPayload. */
            public encPayload: Uint8Array;

            /** PollEncValue encIv. */
            public encIv: Uint8Array;

            /**
             * Crea una nueva instancia PollEncValue utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollEncValue instance
             */
            public static create(properties?: proto.Message.IPollEncValue): proto.Message.PollEncValue;

            /**
             * Codifica el mensaje PollEncValue. No implícitamente mensajes {@link proto.Message.PollEncValue.verify|verify}.
             * @param message PollEncValue mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPollEncValue, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollEncValue message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollEncValue.verify|verify}.
             * @param message PollEncValue mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPollEncValue, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollEncValue message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollEncValue
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollEncValue;

            /**
             * Decodes a PollEncValue message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollEncValue
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollEncValue;

            /**
             * Verifies a PollEncValue message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollEncValue message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollEncValue
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PollEncValue;

            /**
             * Crea un objeto simple desde PollEncValue. También convierte valores a otros tipos si se especifica.
             * @param message PollEncValue
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PollEncValue, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollEncValue a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PollUpdateMessage. */
        interface IPollUpdateMessage {

            /** PollUpdateMessage pollCreationMessageKey */
            pollCreationMessageKey?: (proto.IMessageKey|null);

            /** PollUpdateMessage vote */
            vote?: (proto.Message.IPollEncValue|null);

            /** PollUpdateMessage metadata */
            metadata?: (proto.Message.IPollUpdateMessageMetadata|null);

            /** PollUpdateMessage senderTimestampMs */
            senderTimestampMs?: (number|Long|null);
        }

        /** Representa un PollUpdateMessage. */
        class PollUpdateMessage implements IPollUpdateMessage {

            /**
             * Construya un nuevo PollUpdateMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPollUpdateMessage);

            /** PollUpdateMessage pollCreationMessageKey. */
            public pollCreationMessageKey?: (proto.IMessageKey|null);

            /** PollUpdateMessage vote. */
            public vote?: (proto.Message.IPollEncValue|null);

            /** PollUpdateMessage metadata. */
            public metadata?: (proto.Message.IPollUpdateMessageMetadata|null);

            /** PollUpdateMessage senderTimestampMs. */
            public senderTimestampMs: (number|Long);

            /**
             * Crea una nueva instancia PollUpdateMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollUpdateMessage instance
             */
            public static create(properties?: proto.Message.IPollUpdateMessage): proto.Message.PollUpdateMessage;

            /**
             * Codifica el mensaje PollUpdateMessage. No implícitamente mensajes {@link proto.Message.PollUpdateMessage.verify|verify}.
             * @param message PollUpdateMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPollUpdateMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollUpdateMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollUpdateMessage.verify|verify}.
             * @param message PollUpdateMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPollUpdateMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollUpdateMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollUpdateMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollUpdateMessage;

            /**
             * Decodes a PollUpdateMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollUpdateMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollUpdateMessage;

            /**
             * Verifies a PollUpdateMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollUpdateMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollUpdateMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PollUpdateMessage;

            /**
             * Crea un objeto simple desde PollUpdateMessage. También convierte valores a otros tipos si se especifica.
             * @param message PollUpdateMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PollUpdateMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollUpdateMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PollUpdateMessageMetadata. */
        interface IPollUpdateMessageMetadata {
        }

        /** Representa un PollUpdateMessageMetadata. */
        class PollUpdateMessageMetadata implements IPollUpdateMessageMetadata {

            /**
             * Construya un nuevo PollUpdateMessageMetadata.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPollUpdateMessageMetadata);

            /**
             * Crea una nueva instancia PollUpdateMessageMetadata utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollUpdateMessageMetadata instance
             */
            public static create(properties?: proto.Message.IPollUpdateMessageMetadata): proto.Message.PollUpdateMessageMetadata;

            /**
             * Codifica el mensaje PollUpdateMessageMetadata. No implícitamente mensajes {@link proto.Message.PollUpdateMessageMetadata.verify|verify}.
             * @param message PollUpdateMessageMetadata mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPollUpdateMessageMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollUpdateMessageMetadata message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollUpdateMessageMetadata.verify|verify}.
             * @param message PollUpdateMessageMetadata mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPollUpdateMessageMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollUpdateMessageMetadata message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollUpdateMessageMetadata
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollUpdateMessageMetadata;

            /**
             * Decodes a PollUpdateMessageMetadata message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollUpdateMessageMetadata
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollUpdateMessageMetadata;

            /**
             * Verifies a PollUpdateMessageMetadata message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollUpdateMessageMetadata message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollUpdateMessageMetadata
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PollUpdateMessageMetadata;

            /**
             * Crea un objeto simple desde PollUpdateMessageMetadata. También convierte valores a otros tipos si se especifica.
             * @param message PollUpdateMessageMetadata
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PollUpdateMessageMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollUpdateMessageMetadata a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PollVoteMessage. */
        interface IPollVoteMessage {

            /** PollVoteMessage selectedOptions */
            selectedOptions?: (Uint8Array[]|null);
        }

        /** Representa un PollVoteMessage. */
        class PollVoteMessage implements IPollVoteMessage {

            /**
             * Construya un nuevo PollVoteMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IPollVoteMessage);

            /** PollVoteMessage selectedOptions. */
            public selectedOptions: Uint8Array[];

            /**
             * Crea una nueva instancia PollVoteMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollVoteMessage instance
             */
            public static create(properties?: proto.Message.IPollVoteMessage): proto.Message.PollVoteMessage;

            /**
             * Codifica el mensaje PollVoteMessage. No implícitamente mensajes {@link proto.Message.PollVoteMessage.verify|verify}.
             * @param message PollVoteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IPollVoteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollVoteMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.PollVoteMessage.verify|verify}.
             * @param message PollVoteMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IPollVoteMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollVoteMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollVoteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.PollVoteMessage;

            /**
             * Decodes a PollVoteMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollVoteMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.PollVoteMessage;

            /**
             * Verifies a PollVoteMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollVoteMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollVoteMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.PollVoteMessage;

            /**
             * Crea un objeto simple desde PollVoteMessage. También convierte valores a otros tipos si se especifica.
             * @param message PollVoteMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.PollVoteMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollVoteMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ProductMessage. */
        interface IProductMessage {

            /** ProductMessage product */
            product?: (proto.Message.ProductMessage.IProductSnapshot|null);

            /** ProductMessage businessOwnerJid */
            businessOwnerJid?: (string|null);

            /** ProductMessage catalog */
            catalog?: (proto.Message.ProductMessage.ICatalogSnapshot|null);

            /** ProductMessage body */
            body?: (string|null);

            /** ProductMessage footer */
            footer?: (string|null);

            /** ProductMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un ProductMessage. */
        class ProductMessage implements IProductMessage {

            /**
             * Construya un nuevo ProductMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IProductMessage);

            /** ProductMessage product. */
            public product?: (proto.Message.ProductMessage.IProductSnapshot|null);

            /** ProductMessage businessOwnerJid. */
            public businessOwnerJid: string;

            /** ProductMessage catalog. */
            public catalog?: (proto.Message.ProductMessage.ICatalogSnapshot|null);

            /** ProductMessage body. */
            public body: string;

            /** ProductMessage footer. */
            public footer: string;

            /** ProductMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia ProductMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ProductMessage instance
             */
            public static create(properties?: proto.Message.IProductMessage): proto.Message.ProductMessage;

            /**
             * Codifica el mensaje ProductMessage. No implícitamente mensajes {@link proto.Message.ProductMessage.verify|verify}.
             * @param message ProductMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IProductMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ProductMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ProductMessage.verify|verify}.
             * @param message ProductMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IProductMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProductMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ProductMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ProductMessage;

            /**
             * Decodes a ProductMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ProductMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ProductMessage;

            /**
             * Verifies a ProductMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ProductMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ProductMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ProductMessage;

            /**
             * Crea un objeto simple desde ProductMessage. También convierte valores a otros tipos si se especifica.
             * @param message ProductMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ProductMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ProductMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ProductMessage {

            /** Propiedades de un CatalogSnapshot. */
            interface ICatalogSnapshot {

                /** CatalogSnapshot catalogImage */
                catalogImage?: (proto.Message.IImageMessage|null);

                /** CatalogSnapshot title */
                title?: (string|null);

                /** CatalogSnapshot description */
                description?: (string|null);
            }

            /** Representa un CatalogSnapshot. */
            class CatalogSnapshot implements ICatalogSnapshot {

                /**
                 * Construya un nuevo CatalogSnapshot.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ProductMessage.ICatalogSnapshot);

                /** CatalogSnapshot catalogImage. */
                public catalogImage?: (proto.Message.IImageMessage|null);

                /** CatalogSnapshot title. */
                public title: string;

                /** CatalogSnapshot description. */
                public description: string;

                /**
                 * Crea una nueva instancia CatalogSnapshot utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns CatalogSnapshot instance
                 */
                public static create(properties?: proto.Message.ProductMessage.ICatalogSnapshot): proto.Message.ProductMessage.CatalogSnapshot;

                /**
                 * Codifica el mensaje CatalogSnapshot. No implícitamente mensajes {@link proto.Message.ProductMessage.CatalogSnapshot.verify|verify}.
                 * @param message CatalogSnapshot mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ProductMessage.ICatalogSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje CatalogSnapshot message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ProductMessage.CatalogSnapshot.verify|verify}.
                 * @param message CatalogSnapshot mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ProductMessage.ICatalogSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CatalogSnapshot message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns CatalogSnapshot
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ProductMessage.CatalogSnapshot;

                /**
                 * Decodes a CatalogSnapshot message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns CatalogSnapshot
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ProductMessage.CatalogSnapshot;

                /**
                 * Verifies a CatalogSnapshot message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CatalogSnapshot message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns CatalogSnapshot
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ProductMessage.CatalogSnapshot;

                /**
                 * Crea un objeto simple desde CatalogSnapshot. También convierte valores a otros tipos si se especifica.
                 * @param message CatalogSnapshot
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ProductMessage.CatalogSnapshot, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  CatalogSnapshot a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un ProductSnapshot. */
            interface IProductSnapshot {

                /** ProductSnapshot productImage */
                productImage?: (proto.Message.IImageMessage|null);

                /** ProductSnapshot productId */
                productId?: (string|null);

                /** ProductSnapshot title */
                title?: (string|null);

                /** ProductSnapshot description */
                description?: (string|null);

                /** ProductSnapshot currencyCode */
                currencyCode?: (string|null);

                /** ProductSnapshot priceAmount1000 */
                priceAmount1000?: (number|Long|null);

                /** ProductSnapshot retailerId */
                retailerId?: (string|null);

                /** ProductSnapshot url */
                url?: (string|null);

                /** ProductSnapshot productImageCount */
                productImageCount?: (number|null);

                /** ProductSnapshot firstImageId */
                firstImageId?: (string|null);

                /** ProductSnapshot salePriceAmount1000 */
                salePriceAmount1000?: (number|Long|null);
            }

            /** Representa un ProductSnapshot. */
            class ProductSnapshot implements IProductSnapshot {

                /**
                 * Construya un nuevo ProductSnapshot.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.ProductMessage.IProductSnapshot);

                /** ProductSnapshot productImage. */
                public productImage?: (proto.Message.IImageMessage|null);

                /** ProductSnapshot productId. */
                public productId: string;

                /** ProductSnapshot title. */
                public title: string;

                /** ProductSnapshot description. */
                public description: string;

                /** ProductSnapshot currencyCode. */
                public currencyCode: string;

                /** ProductSnapshot priceAmount1000. */
                public priceAmount1000: (number|Long);

                /** ProductSnapshot retailerId. */
                public retailerId: string;

                /** ProductSnapshot url. */
                public url: string;

                /** ProductSnapshot productImageCount. */
                public productImageCount: number;

                /** ProductSnapshot firstImageId. */
                public firstImageId: string;

                /** ProductSnapshot salePriceAmount1000. */
                public salePriceAmount1000: (number|Long);

                /**
                 * Crea una nueva instancia ProductSnapshot utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ProductSnapshot instance
                 */
                public static create(properties?: proto.Message.ProductMessage.IProductSnapshot): proto.Message.ProductMessage.ProductSnapshot;

                /**
                 * Codifica el mensaje ProductSnapshot. No implícitamente mensajes {@link proto.Message.ProductMessage.ProductSnapshot.verify|verify}.
                 * @param message ProductSnapshot mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.ProductMessage.IProductSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ProductSnapshot message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ProductMessage.ProductSnapshot.verify|verify}.
                 * @param message ProductSnapshot mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.ProductMessage.IProductSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ProductSnapshot message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ProductSnapshot
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ProductMessage.ProductSnapshot;

                /**
                 * Decodes a ProductSnapshot message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ProductSnapshot
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ProductMessage.ProductSnapshot;

                /**
                 * Verifies a ProductSnapshot message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ProductSnapshot message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ProductSnapshot
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.ProductMessage.ProductSnapshot;

                /**
                 * Crea un objeto simple desde ProductSnapshot. También convierte valores a otros tipos si se especifica.
                 * @param message ProductSnapshot
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.ProductMessage.ProductSnapshot, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ProductSnapshot a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un ProtocolMessage. */
        interface IProtocolMessage {

            /** ProtocolMessage key */
            key?: (proto.IMessageKey|null);

            /** ProtocolMessage type */
            type?: (proto.Message.ProtocolMessage.Type|null);

            /** ProtocolMessage ephemeralExpiration */
            ephemeralExpiration?: (number|null);

            /** ProtocolMessage ephemeralSettingTimestamp */
            ephemeralSettingTimestamp?: (number|Long|null);

            /** ProtocolMessage historySyncNotification */
            historySyncNotification?: (proto.Message.IHistorySyncNotification|null);

            /** ProtocolMessage appStateSyncKeyShare */
            appStateSyncKeyShare?: (proto.Message.IAppStateSyncKeyShare|null);

            /** ProtocolMessage appStateSyncKeyRequest */
            appStateSyncKeyRequest?: (proto.Message.IAppStateSyncKeyRequest|null);

            /** ProtocolMessage initialSecurityNotificationSettingSync */
            initialSecurityNotificationSettingSync?: (proto.Message.IInitialSecurityNotificationSettingSync|null);

            /** ProtocolMessage appStateFatalExceptionNotification */
            appStateFatalExceptionNotification?: (proto.Message.IAppStateFatalExceptionNotification|null);

            /** ProtocolMessage disappearingMode */
            disappearingMode?: (proto.IDisappearingMode|null);

            /** ProtocolMessage editedMessage */
            editedMessage?: (proto.IMessage|null);

            /** ProtocolMessage timestampMs */
            timestampMs?: (number|Long|null);

            /** ProtocolMessage peerDataOperationRequestMessage */
            peerDataOperationRequestMessage?: (proto.Message.IPeerDataOperationRequestMessage|null);

            /** ProtocolMessage peerDataOperationRequestResponseMessage */
            peerDataOperationRequestResponseMessage?: (proto.Message.IPeerDataOperationRequestResponseMessage|null);
        }

        /** Representa un ProtocolMessage. */
        class ProtocolMessage implements IProtocolMessage {

            /**
             * Construya un nuevo ProtocolMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IProtocolMessage);

            /** ProtocolMessage key. */
            public key?: (proto.IMessageKey|null);

            /** ProtocolMessage type. */
            public type: proto.Message.ProtocolMessage.Type;

            /** ProtocolMessage ephemeralExpiration. */
            public ephemeralExpiration: number;

            /** ProtocolMessage ephemeralSettingTimestamp. */
            public ephemeralSettingTimestamp: (number|Long);

            /** ProtocolMessage historySyncNotification. */
            public historySyncNotification?: (proto.Message.IHistorySyncNotification|null);

            /** ProtocolMessage appStateSyncKeyShare. */
            public appStateSyncKeyShare?: (proto.Message.IAppStateSyncKeyShare|null);

            /** ProtocolMessage appStateSyncKeyRequest. */
            public appStateSyncKeyRequest?: (proto.Message.IAppStateSyncKeyRequest|null);

            /** ProtocolMessage initialSecurityNotificationSettingSync. */
            public initialSecurityNotificationSettingSync?: (proto.Message.IInitialSecurityNotificationSettingSync|null);

            /** ProtocolMessage appStateFatalExceptionNotification. */
            public appStateFatalExceptionNotification?: (proto.Message.IAppStateFatalExceptionNotification|null);

            /** ProtocolMessage disappearingMode. */
            public disappearingMode?: (proto.IDisappearingMode|null);

            /** ProtocolMessage editedMessage. */
            public editedMessage?: (proto.IMessage|null);

            /** ProtocolMessage timestampMs. */
            public timestampMs: (number|Long);

            /** ProtocolMessage peerDataOperationRequestMessage. */
            public peerDataOperationRequestMessage?: (proto.Message.IPeerDataOperationRequestMessage|null);

            /** ProtocolMessage peerDataOperationRequestResponseMessage. */
            public peerDataOperationRequestResponseMessage?: (proto.Message.IPeerDataOperationRequestResponseMessage|null);

            /**
             * Crea una nueva instancia ProtocolMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ProtocolMessage instance
             */
            public static create(properties?: proto.Message.IProtocolMessage): proto.Message.ProtocolMessage;

            /**
             * Codifica el mensaje ProtocolMessage. No implícitamente mensajes {@link proto.Message.ProtocolMessage.verify|verify}.
             * @param message ProtocolMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IProtocolMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ProtocolMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ProtocolMessage.verify|verify}.
             * @param message ProtocolMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IProtocolMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtocolMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ProtocolMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ProtocolMessage;

            /**
             * Decodes a ProtocolMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ProtocolMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ProtocolMessage;

            /**
             * Verifies a ProtocolMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ProtocolMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ProtocolMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ProtocolMessage;

            /**
             * Crea un objeto simple desde ProtocolMessage. También convierte valores a otros tipos si se especifica.
             * @param message ProtocolMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ProtocolMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ProtocolMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ProtocolMessage {

            /** Type enum. */
            enum Type {
                REVOKE = 0,
                EPHEMERAL_SETTING = 3,
                EPHEMERAL_SYNC_RESPONSE = 4,
                HISTORY_SYNC_NOTIFICATION = 5,
                APP_STATE_SYNC_KEY_SHARE = 6,
                APP_STATE_SYNC_KEY_REQUEST = 7,
                MSG_FANOUT_BACKFILL_REQUEST = 8,
                INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC = 9,
                APP_STATE_FATAL_EXCEPTION_NOTIFICATION = 10,
                SHARE_PHONE_NUMBER = 11,
                MESSAGE_EDIT = 14,
                PEER_DATA_OPERATION_REQUEST_MESSAGE = 16,
                PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE = 17
            }
        }

        /** Propiedades de un ReactionMessage. */
        interface IReactionMessage {

            /** ReactionMessage key */
            key?: (proto.IMessageKey|null);

            /** ReactionMessage text */
            text?: (string|null);

            /** ReactionMessage groupingKey */
            groupingKey?: (string|null);

            /** ReactionMessage senderTimestampMs */
            senderTimestampMs?: (number|Long|null);
        }

        /** Representa un ReactionMessage. */
        class ReactionMessage implements IReactionMessage {

            /**
             * Construya un nuevo ReactionMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IReactionMessage);

            /** ReactionMessage key. */
            public key?: (proto.IMessageKey|null);

            /** ReactionMessage text. */
            public text: string;

            /** ReactionMessage groupingKey. */
            public groupingKey: string;

            /** ReactionMessage senderTimestampMs. */
            public senderTimestampMs: (number|Long);

            /**
             * Crea una nueva instancia ReactionMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ReactionMessage instance
             */
            public static create(properties?: proto.Message.IReactionMessage): proto.Message.ReactionMessage;

            /**
             * Codifica el mensaje ReactionMessage. No implícitamente mensajes {@link proto.Message.ReactionMessage.verify|verify}.
             * @param message ReactionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IReactionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ReactionMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ReactionMessage.verify|verify}.
             * @param message ReactionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IReactionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ReactionMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ReactionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ReactionMessage;

            /**
             * Decodes a ReactionMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ReactionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ReactionMessage;

            /**
             * Verifies a ReactionMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ReactionMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ReactionMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ReactionMessage;

            /**
             * Crea un objeto simple desde ReactionMessage. También convierte valores a otros tipos si se especifica.
             * @param message ReactionMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ReactionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ReactionMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un RequestPaymentMessage. */
        interface IRequestPaymentMessage {

            /** RequestPaymentMessage noteMessage */
            noteMessage?: (proto.IMessage|null);

            /** RequestPaymentMessage currencyCodeIso4217 */
            currencyCodeIso4217?: (string|null);

            /** RequestPaymentMessage amount1000 */
            amount1000?: (number|Long|null);

            /** RequestPaymentMessage requestFrom */
            requestFrom?: (string|null);

            /** RequestPaymentMessage expiryTimestamp */
            expiryTimestamp?: (number|Long|null);

            /** RequestPaymentMessage amount */
            amount?: (proto.IMoney|null);

            /** RequestPaymentMessage background */
            background?: (proto.IPaymentBackground|null);
        }

        /** Representa un RequestPaymentMessage. */
        class RequestPaymentMessage implements IRequestPaymentMessage {

            /**
             * Construya un nuevo RequestPaymentMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IRequestPaymentMessage);

            /** RequestPaymentMessage noteMessage. */
            public noteMessage?: (proto.IMessage|null);

            /** RequestPaymentMessage currencyCodeIso4217. */
            public currencyCodeIso4217: string;

            /** RequestPaymentMessage amount1000. */
            public amount1000: (number|Long);

            /** RequestPaymentMessage requestFrom. */
            public requestFrom: string;

            /** RequestPaymentMessage expiryTimestamp. */
            public expiryTimestamp: (number|Long);

            /** RequestPaymentMessage amount. */
            public amount?: (proto.IMoney|null);

            /** RequestPaymentMessage background. */
            public background?: (proto.IPaymentBackground|null);

            /**
             * Crea una nueva instancia RequestPaymentMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns RequestPaymentMessage instance
             */
            public static create(properties?: proto.Message.IRequestPaymentMessage): proto.Message.RequestPaymentMessage;

            /**
             * Codifica el mensaje RequestPaymentMessage. No implícitamente mensajes {@link proto.Message.RequestPaymentMessage.verify|verify}.
             * @param message RequestPaymentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IRequestPaymentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje RequestPaymentMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.RequestPaymentMessage.verify|verify}.
             * @param message RequestPaymentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IRequestPaymentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RequestPaymentMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns RequestPaymentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.RequestPaymentMessage;

            /**
             * Decodes a RequestPaymentMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns RequestPaymentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.RequestPaymentMessage;

            /**
             * Verifies a RequestPaymentMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a RequestPaymentMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns RequestPaymentMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.RequestPaymentMessage;

            /**
             * Crea un objeto simple desde RequestPaymentMessage. También convierte valores a otros tipos si se especifica.
             * @param message RequestPaymentMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.RequestPaymentMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  RequestPaymentMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un RequestPhoneNumberMessage. */
        interface IRequestPhoneNumberMessage {

            /** RequestPhoneNumberMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);
        }

        /** Representa un RequestPhoneNumberMessage. */
        class RequestPhoneNumberMessage implements IRequestPhoneNumberMessage {

            /**
             * Construya un nuevo RequestPhoneNumberMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IRequestPhoneNumberMessage);

            /** RequestPhoneNumberMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /**
             * Crea una nueva instancia RequestPhoneNumberMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns RequestPhoneNumberMessage instance
             */
            public static create(properties?: proto.Message.IRequestPhoneNumberMessage): proto.Message.RequestPhoneNumberMessage;

            /**
             * Codifica el mensaje RequestPhoneNumberMessage. No implícitamente mensajes {@link proto.Message.RequestPhoneNumberMessage.verify|verify}.
             * @param message RequestPhoneNumberMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IRequestPhoneNumberMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje RequestPhoneNumberMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.RequestPhoneNumberMessage.verify|verify}.
             * @param message RequestPhoneNumberMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IRequestPhoneNumberMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RequestPhoneNumberMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns RequestPhoneNumberMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.RequestPhoneNumberMessage;

            /**
             * Decodes a RequestPhoneNumberMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns RequestPhoneNumberMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.RequestPhoneNumberMessage;

            /**
             * Verifies a RequestPhoneNumberMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a RequestPhoneNumberMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns RequestPhoneNumberMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.RequestPhoneNumberMessage;

            /**
             * Crea un objeto simple desde RequestPhoneNumberMessage. También convierte valores a otros tipos si se especifica.
             * @param message RequestPhoneNumberMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.RequestPhoneNumberMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  RequestPhoneNumberMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ScheduledCallCreationMessage. */
        interface IScheduledCallCreationMessage {

            /** ScheduledCallCreationMessage scheduledTimestampMs */
            scheduledTimestampMs?: (number|Long|null);

            /** ScheduledCallCreationMessage callType */
            callType?: (proto.Message.ScheduledCallCreationMessage.CallType|null);

            /** ScheduledCallCreationMessage title */
            title?: (string|null);
        }

        /** Representa un ScheduledCallCreationMessage. */
        class ScheduledCallCreationMessage implements IScheduledCallCreationMessage {

            /**
             * Construya un nuevo ScheduledCallCreationMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IScheduledCallCreationMessage);

            /** ScheduledCallCreationMessage scheduledTimestampMs. */
            public scheduledTimestampMs: (number|Long);

            /** ScheduledCallCreationMessage callType. */
            public callType: proto.Message.ScheduledCallCreationMessage.CallType;

            /** ScheduledCallCreationMessage title. */
            public title: string;

            /**
             * Crea una nueva instancia ScheduledCallCreationMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ScheduledCallCreationMessage instance
             */
            public static create(properties?: proto.Message.IScheduledCallCreationMessage): proto.Message.ScheduledCallCreationMessage;

            /**
             * Codifica el mensaje ScheduledCallCreationMessage. No implícitamente mensajes {@link proto.Message.ScheduledCallCreationMessage.verify|verify}.
             * @param message ScheduledCallCreationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IScheduledCallCreationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ScheduledCallCreationMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ScheduledCallCreationMessage.verify|verify}.
             * @param message ScheduledCallCreationMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IScheduledCallCreationMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduledCallCreationMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ScheduledCallCreationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ScheduledCallCreationMessage;

            /**
             * Decodes a ScheduledCallCreationMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ScheduledCallCreationMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ScheduledCallCreationMessage;

            /**
             * Verifies a ScheduledCallCreationMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ScheduledCallCreationMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ScheduledCallCreationMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ScheduledCallCreationMessage;

            /**
             * Crea un objeto simple desde ScheduledCallCreationMessage. También convierte valores a otros tipos si se especifica.
             * @param message ScheduledCallCreationMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ScheduledCallCreationMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ScheduledCallCreationMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ScheduledCallCreationMessage {

            /** CallType enum. */
            enum CallType {
                UNKNOWN = 0,
                VOICE = 1,
                VIDEO = 2
            }
        }

        /** Propiedades de un ScheduledCallEditMessage. */
        interface IScheduledCallEditMessage {

            /** ScheduledCallEditMessage key */
            key?: (proto.IMessageKey|null);

            /** ScheduledCallEditMessage editType */
            editType?: (proto.Message.ScheduledCallEditMessage.EditType|null);
        }

        /** Representa un ScheduledCallEditMessage. */
        class ScheduledCallEditMessage implements IScheduledCallEditMessage {

            /**
             * Construya un nuevo ScheduledCallEditMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IScheduledCallEditMessage);

            /** ScheduledCallEditMessage key. */
            public key?: (proto.IMessageKey|null);

            /** ScheduledCallEditMessage editType. */
            public editType: proto.Message.ScheduledCallEditMessage.EditType;

            /**
             * Crea una nueva instancia ScheduledCallEditMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ScheduledCallEditMessage instance
             */
            public static create(properties?: proto.Message.IScheduledCallEditMessage): proto.Message.ScheduledCallEditMessage;

            /**
             * Codifica el mensaje ScheduledCallEditMessage. No implícitamente mensajes {@link proto.Message.ScheduledCallEditMessage.verify|verify}.
             * @param message ScheduledCallEditMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IScheduledCallEditMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ScheduledCallEditMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.ScheduledCallEditMessage.verify|verify}.
             * @param message ScheduledCallEditMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IScheduledCallEditMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduledCallEditMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ScheduledCallEditMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.ScheduledCallEditMessage;

            /**
             * Decodes a ScheduledCallEditMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ScheduledCallEditMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.ScheduledCallEditMessage;

            /**
             * Verifies a ScheduledCallEditMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ScheduledCallEditMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ScheduledCallEditMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.ScheduledCallEditMessage;

            /**
             * Crea un objeto simple desde ScheduledCallEditMessage. También convierte valores a otros tipos si se especifica.
             * @param message ScheduledCallEditMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.ScheduledCallEditMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ScheduledCallEditMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ScheduledCallEditMessage {

            /** EditType enum. */
            enum EditType {
                UNKNOWN = 0,
                CANCEL = 1
            }
        }

        /** Propiedades de un SendPaymentMessage. */
        interface ISendPaymentMessage {

            /** SendPaymentMessage noteMessage */
            noteMessage?: (proto.IMessage|null);

            /** SendPaymentMessage requestMessageKey */
            requestMessageKey?: (proto.IMessageKey|null);

            /** SendPaymentMessage background */
            background?: (proto.IPaymentBackground|null);
        }

        /** Representa un SendPaymentMessage. */
        class SendPaymentMessage implements ISendPaymentMessage {

            /**
             * Construya un nuevo SendPaymentMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ISendPaymentMessage);

            /** SendPaymentMessage noteMessage. */
            public noteMessage?: (proto.IMessage|null);

            /** SendPaymentMessage requestMessageKey. */
            public requestMessageKey?: (proto.IMessageKey|null);

            /** SendPaymentMessage background. */
            public background?: (proto.IPaymentBackground|null);

            /**
             * Crea una nueva instancia SendPaymentMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SendPaymentMessage instance
             */
            public static create(properties?: proto.Message.ISendPaymentMessage): proto.Message.SendPaymentMessage;

            /**
             * Codifica el mensaje SendPaymentMessage. No implícitamente mensajes {@link proto.Message.SendPaymentMessage.verify|verify}.
             * @param message SendPaymentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ISendPaymentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SendPaymentMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.SendPaymentMessage.verify|verify}.
             * @param message SendPaymentMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ISendPaymentMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SendPaymentMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SendPaymentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.SendPaymentMessage;

            /**
             * Decodes a SendPaymentMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SendPaymentMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.SendPaymentMessage;

            /**
             * Verifies a SendPaymentMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SendPaymentMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SendPaymentMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.SendPaymentMessage;

            /**
             * Crea un objeto simple desde SendPaymentMessage. También convierte valores a otros tipos si se especifica.
             * @param message SendPaymentMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.SendPaymentMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SendPaymentMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SenderKeyDistributionMessage. */
        interface ISenderKeyDistributionMessage {

            /** SenderKeyDistributionMessage groupId */
            groupId?: (string|null);

            /** SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage */
            axolotlSenderKeyDistributionMessage?: (Uint8Array|null);
        }

        /** Representa un SenderKeyDistributionMessage. */
        class SenderKeyDistributionMessage implements ISenderKeyDistributionMessage {

            /**
             * Construya un nuevo SenderKeyDistributionMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ISenderKeyDistributionMessage);

            /** SenderKeyDistributionMessage groupId. */
            public groupId: string;

            /** SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage. */
            public axolotlSenderKeyDistributionMessage: Uint8Array;

            /**
             * Crea una nueva instancia SenderKeyDistributionMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SenderKeyDistributionMessage instance
             */
            public static create(properties?: proto.Message.ISenderKeyDistributionMessage): proto.Message.SenderKeyDistributionMessage;

            /**
             * Codifica el mensaje SenderKeyDistributionMessage. No implícitamente mensajes {@link proto.Message.SenderKeyDistributionMessage.verify|verify}.
             * @param message SenderKeyDistributionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ISenderKeyDistributionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SenderKeyDistributionMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.SenderKeyDistributionMessage.verify|verify}.
             * @param message SenderKeyDistributionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ISenderKeyDistributionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SenderKeyDistributionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.SenderKeyDistributionMessage;

            /**
             * Decodes a SenderKeyDistributionMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SenderKeyDistributionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.SenderKeyDistributionMessage;

            /**
             * Verifies a SenderKeyDistributionMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SenderKeyDistributionMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SenderKeyDistributionMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.SenderKeyDistributionMessage;

            /**
             * Crea un objeto simple desde SenderKeyDistributionMessage. También convierte valores a otros tipos si se especifica.
             * @param message SenderKeyDistributionMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.SenderKeyDistributionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SenderKeyDistributionMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un StickerMessage. */
        interface IStickerMessage {

            /** StickerMessage url */
            url?: (string|null);

            /** StickerMessage fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** StickerMessage fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** StickerMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** StickerMessage mimetype */
            mimetype?: (string|null);

            /** StickerMessage height */
            height?: (number|null);

            /** StickerMessage width */
            width?: (number|null);

            /** StickerMessage directPath */
            directPath?: (string|null);

            /** StickerMessage fileLength */
            fileLength?: (number|Long|null);

            /** StickerMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** StickerMessage firstFrameLength */
            firstFrameLength?: (number|null);

            /** StickerMessage firstFrameSidecar */
            firstFrameSidecar?: (Uint8Array|null);

            /** StickerMessage isAnimated */
            isAnimated?: (boolean|null);

            /** StickerMessage pngThumbnail */
            pngThumbnail?: (Uint8Array|null);

            /** StickerMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** StickerMessage stickerSentTs */
            stickerSentTs?: (number|Long|null);

            /** StickerMessage isAvatar */
            isAvatar?: (boolean|null);
        }

        /** Representa un StickerMessage. */
        class StickerMessage implements IStickerMessage {

            /**
             * Construya un nuevo StickerMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IStickerMessage);

            /** StickerMessage url. */
            public url: string;

            /** StickerMessage fileSha256. */
            public fileSha256: Uint8Array;

            /** StickerMessage fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** StickerMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** StickerMessage mimetype. */
            public mimetype: string;

            /** StickerMessage height. */
            public height: number;

            /** StickerMessage width. */
            public width: number;

            /** StickerMessage directPath. */
            public directPath: string;

            /** StickerMessage fileLength. */
            public fileLength: (number|Long);

            /** StickerMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** StickerMessage firstFrameLength. */
            public firstFrameLength: number;

            /** StickerMessage firstFrameSidecar. */
            public firstFrameSidecar: Uint8Array;

            /** StickerMessage isAnimated. */
            public isAnimated: boolean;

            /** StickerMessage pngThumbnail. */
            public pngThumbnail: Uint8Array;

            /** StickerMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** StickerMessage stickerSentTs. */
            public stickerSentTs: (number|Long);

            /** StickerMessage isAvatar. */
            public isAvatar: boolean;

            /**
             * Crea una nueva instancia StickerMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns StickerMessage instance
             */
            public static create(properties?: proto.Message.IStickerMessage): proto.Message.StickerMessage;

            /**
             * Codifica el mensaje StickerMessage. No implícitamente mensajes {@link proto.Message.StickerMessage.verify|verify}.
             * @param message StickerMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IStickerMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje StickerMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.StickerMessage.verify|verify}.
             * @param message StickerMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IStickerMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StickerMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns StickerMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.StickerMessage;

            /**
             * Decodes a StickerMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns StickerMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.StickerMessage;

            /**
             * Verifies a StickerMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a StickerMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns StickerMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.StickerMessage;

            /**
             * Crea un objeto simple desde StickerMessage. También convierte valores a otros tipos si se especifica.
             * @param message StickerMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.StickerMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  StickerMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un StickerSyncRMRMessage. */
        interface IStickerSyncRMRMessage {

            /** StickerSyncRMRMessage filehash */
            filehash?: (string[]|null);

            /** StickerSyncRMRMessage rmrSource */
            rmrSource?: (string|null);

            /** StickerSyncRMRMessage requestTimestamp */
            requestTimestamp?: (number|Long|null);
        }

        /** Representa un StickerSyncRMRMessage. */
        class StickerSyncRMRMessage implements IStickerSyncRMRMessage {

            /**
             * Construya un nuevo StickerSyncRMRMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IStickerSyncRMRMessage);

            /** StickerSyncRMRMessage filehash. */
            public filehash: string[];

            /** StickerSyncRMRMessage rmrSource. */
            public rmrSource: string;

            /** StickerSyncRMRMessage requestTimestamp. */
            public requestTimestamp: (number|Long);

            /**
             * Crea una nueva instancia StickerSyncRMRMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns StickerSyncRMRMessage instance
             */
            public static create(properties?: proto.Message.IStickerSyncRMRMessage): proto.Message.StickerSyncRMRMessage;

            /**
             * Codifica el mensaje StickerSyncRMRMessage. No implícitamente mensajes {@link proto.Message.StickerSyncRMRMessage.verify|verify}.
             * @param message StickerSyncRMRMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IStickerSyncRMRMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje StickerSyncRMRMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.StickerSyncRMRMessage.verify|verify}.
             * @param message StickerSyncRMRMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IStickerSyncRMRMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StickerSyncRMRMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns StickerSyncRMRMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.StickerSyncRMRMessage;

            /**
             * Decodes a StickerSyncRMRMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns StickerSyncRMRMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.StickerSyncRMRMessage;

            /**
             * Verifies a StickerSyncRMRMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a StickerSyncRMRMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns StickerSyncRMRMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.StickerSyncRMRMessage;

            /**
             * Crea un objeto simple desde StickerSyncRMRMessage. También convierte valores a otros tipos si se especifica.
             * @param message StickerSyncRMRMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.StickerSyncRMRMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  StickerSyncRMRMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un TemplateButtonReplyMessage. */
        interface ITemplateButtonReplyMessage {

            /** TemplateButtonReplyMessage selectedId */
            selectedId?: (string|null);

            /** TemplateButtonReplyMessage selectedDisplayText */
            selectedDisplayText?: (string|null);

            /** TemplateButtonReplyMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** TemplateButtonReplyMessage selectedIndex */
            selectedIndex?: (number|null);
        }

        /** Representa un TemplateButtonReplyMessage. */
        class TemplateButtonReplyMessage implements ITemplateButtonReplyMessage {

            /**
             * Construya un nuevo TemplateButtonReplyMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ITemplateButtonReplyMessage);

            /** TemplateButtonReplyMessage selectedId. */
            public selectedId: string;

            /** TemplateButtonReplyMessage selectedDisplayText. */
            public selectedDisplayText: string;

            /** TemplateButtonReplyMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** TemplateButtonReplyMessage selectedIndex. */
            public selectedIndex: number;

            /**
             * Crea una nueva instancia TemplateButtonReplyMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns TemplateButtonReplyMessage instance
             */
            public static create(properties?: proto.Message.ITemplateButtonReplyMessage): proto.Message.TemplateButtonReplyMessage;

            /**
             * Codifica el mensaje TemplateButtonReplyMessage. No implícitamente mensajes {@link proto.Message.TemplateButtonReplyMessage.verify|verify}.
             * @param message TemplateButtonReplyMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ITemplateButtonReplyMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje TemplateButtonReplyMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.TemplateButtonReplyMessage.verify|verify}.
             * @param message TemplateButtonReplyMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ITemplateButtonReplyMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TemplateButtonReplyMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns TemplateButtonReplyMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.TemplateButtonReplyMessage;

            /**
             * Decodes a TemplateButtonReplyMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns TemplateButtonReplyMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.TemplateButtonReplyMessage;

            /**
             * Verifies a TemplateButtonReplyMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a TemplateButtonReplyMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns TemplateButtonReplyMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.TemplateButtonReplyMessage;

            /**
             * Crea un objeto simple desde TemplateButtonReplyMessage. También convierte valores a otros tipos si se especifica.
             * @param message TemplateButtonReplyMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.TemplateButtonReplyMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  TemplateButtonReplyMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un TemplateMessage. */
        interface ITemplateMessage {

            /** TemplateMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** TemplateMessage hydratedTemplate */
            hydratedTemplate?: (proto.Message.TemplateMessage.IHydratedFourRowTemplate|null);

            /** TemplateMessage templateId */
            templateId?: (string|null);

            /** TemplateMessage fourRowTemplate */
            fourRowTemplate?: (proto.Message.TemplateMessage.IFourRowTemplate|null);

            /** TemplateMessage hydratedFourRowTemplate */
            hydratedFourRowTemplate?: (proto.Message.TemplateMessage.IHydratedFourRowTemplate|null);

            /** TemplateMessage interactiveMessageTemplate */
            interactiveMessageTemplate?: (proto.Message.IInteractiveMessage|null);
        }

        /** Representa un TemplateMessage. */
        class TemplateMessage implements ITemplateMessage {

            /**
             * Construya un nuevo TemplateMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.ITemplateMessage);

            /** TemplateMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** TemplateMessage hydratedTemplate. */
            public hydratedTemplate?: (proto.Message.TemplateMessage.IHydratedFourRowTemplate|null);

            /** TemplateMessage templateId. */
            public templateId: string;

            /** TemplateMessage fourRowTemplate. */
            public fourRowTemplate?: (proto.Message.TemplateMessage.IFourRowTemplate|null);

            /** TemplateMessage hydratedFourRowTemplate. */
            public hydratedFourRowTemplate?: (proto.Message.TemplateMessage.IHydratedFourRowTemplate|null);

            /** TemplateMessage interactiveMessageTemplate. */
            public interactiveMessageTemplate?: (proto.Message.IInteractiveMessage|null);

            /** TemplateMessage format. */
            public format?: ("fourRowTemplate"|"hydratedFourRowTemplate"|"interactiveMessageTemplate");

            /**
             * Crea una nueva instancia TemplateMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns TemplateMessage instance
             */
            public static create(properties?: proto.Message.ITemplateMessage): proto.Message.TemplateMessage;

            /**
             * Codifica el mensaje TemplateMessage. No implícitamente mensajes {@link proto.Message.TemplateMessage.verify|verify}.
             * @param message TemplateMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.ITemplateMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje TemplateMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.TemplateMessage.verify|verify}.
             * @param message TemplateMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.ITemplateMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TemplateMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns TemplateMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.TemplateMessage;

            /**
             * Decodes a TemplateMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns TemplateMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.TemplateMessage;

            /**
             * Verifies a TemplateMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a TemplateMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns TemplateMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.TemplateMessage;

            /**
             * Crea un objeto simple desde TemplateMessage. También convierte valores a otros tipos si se especifica.
             * @param message TemplateMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.TemplateMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  TemplateMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace TemplateMessage {

            /** Propiedades de un FourRowTemplate. */
            interface IFourRowTemplate {

                /** FourRowTemplate content */
                content?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate footer */
                footer?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate buttons */
                buttons?: (proto.ITemplateButton[]|null);

                /** FourRowTemplate documentMessage */
                documentMessage?: (proto.Message.IDocumentMessage|null);

                /** FourRowTemplate highlyStructuredMessage */
                highlyStructuredMessage?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate imageMessage */
                imageMessage?: (proto.Message.IImageMessage|null);

                /** FourRowTemplate videoMessage */
                videoMessage?: (proto.Message.IVideoMessage|null);

                /** FourRowTemplate locationMessage */
                locationMessage?: (proto.Message.ILocationMessage|null);
            }

            /** Representa un FourRowTemplate. */
            class FourRowTemplate implements IFourRowTemplate {

                /**
                 * Construya un nuevo FourRowTemplate.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.TemplateMessage.IFourRowTemplate);

                /** FourRowTemplate content. */
                public content?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate footer. */
                public footer?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate buttons. */
                public buttons: proto.ITemplateButton[];

                /** FourRowTemplate documentMessage. */
                public documentMessage?: (proto.Message.IDocumentMessage|null);

                /** FourRowTemplate highlyStructuredMessage. */
                public highlyStructuredMessage?: (proto.Message.IHighlyStructuredMessage|null);

                /** FourRowTemplate imageMessage. */
                public imageMessage?: (proto.Message.IImageMessage|null);

                /** FourRowTemplate videoMessage. */
                public videoMessage?: (proto.Message.IVideoMessage|null);

                /** FourRowTemplate locationMessage. */
                public locationMessage?: (proto.Message.ILocationMessage|null);

                /** FourRowTemplate title. */
                public title?: ("documentMessage"|"highlyStructuredMessage"|"imageMessage"|"videoMessage"|"locationMessage");

                /**
                 * Crea una nueva instancia FourRowTemplate utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns FourRowTemplate instance
                 */
                public static create(properties?: proto.Message.TemplateMessage.IFourRowTemplate): proto.Message.TemplateMessage.FourRowTemplate;

                /**
                 * Codifica el mensaje FourRowTemplate. No implícitamente mensajes {@link proto.Message.TemplateMessage.FourRowTemplate.verify|verify}.
                 * @param message FourRowTemplate mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.TemplateMessage.IFourRowTemplate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje FourRowTemplate message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.TemplateMessage.FourRowTemplate.verify|verify}.
                 * @param message FourRowTemplate mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.TemplateMessage.IFourRowTemplate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FourRowTemplate message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns FourRowTemplate
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.TemplateMessage.FourRowTemplate;

                /**
                 * Decodes a FourRowTemplate message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns FourRowTemplate
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.TemplateMessage.FourRowTemplate;

                /**
                 * Verifies a FourRowTemplate message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FourRowTemplate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns FourRowTemplate
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.TemplateMessage.FourRowTemplate;

                /**
                 * Crea un objeto simple desde FourRowTemplate. También convierte valores a otros tipos si se especifica.
                 * @param message FourRowTemplate
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.TemplateMessage.FourRowTemplate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  FourRowTemplate a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un HydratedFourRowTemplate. */
            interface IHydratedFourRowTemplate {

                /** HydratedFourRowTemplate hydratedContentText */
                hydratedContentText?: (string|null);

                /** HydratedFourRowTemplate hydratedFooterText */
                hydratedFooterText?: (string|null);

                /** HydratedFourRowTemplate hydratedButtons */
                hydratedButtons?: (proto.IHydratedTemplateButton[]|null);

                /** HydratedFourRowTemplate templateId */
                templateId?: (string|null);

                /** HydratedFourRowTemplate documentMessage */
                documentMessage?: (proto.Message.IDocumentMessage|null);

                /** HydratedFourRowTemplate hydratedTitleText */
                hydratedTitleText?: (string|null);

                /** HydratedFourRowTemplate imageMessage */
                imageMessage?: (proto.Message.IImageMessage|null);

                /** HydratedFourRowTemplate videoMessage */
                videoMessage?: (proto.Message.IVideoMessage|null);

                /** HydratedFourRowTemplate locationMessage */
                locationMessage?: (proto.Message.ILocationMessage|null);
            }

            /** Representa un HydratedFourRowTemplate. */
            class HydratedFourRowTemplate implements IHydratedFourRowTemplate {

                /**
                 * Construya un nuevo HydratedFourRowTemplate.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.Message.TemplateMessage.IHydratedFourRowTemplate);

                /** HydratedFourRowTemplate hydratedContentText. */
                public hydratedContentText: string;

                /** HydratedFourRowTemplate hydratedFooterText. */
                public hydratedFooterText: string;

                /** HydratedFourRowTemplate hydratedButtons. */
                public hydratedButtons: proto.IHydratedTemplateButton[];

                /** HydratedFourRowTemplate templateId. */
                public templateId: string;

                /** HydratedFourRowTemplate documentMessage. */
                public documentMessage?: (proto.Message.IDocumentMessage|null);

                /** HydratedFourRowTemplate hydratedTitleText. */
                public hydratedTitleText?: (string|null);

                /** HydratedFourRowTemplate imageMessage. */
                public imageMessage?: (proto.Message.IImageMessage|null);

                /** HydratedFourRowTemplate videoMessage. */
                public videoMessage?: (proto.Message.IVideoMessage|null);

                /** HydratedFourRowTemplate locationMessage. */
                public locationMessage?: (proto.Message.ILocationMessage|null);

                /** HydratedFourRowTemplate title. */
                public title?: ("documentMessage"|"hydratedTitleText"|"imageMessage"|"videoMessage"|"locationMessage");

                /**
                 * Crea una nueva instancia HydratedFourRowTemplate utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns HydratedFourRowTemplate instance
                 */
                public static create(properties?: proto.Message.TemplateMessage.IHydratedFourRowTemplate): proto.Message.TemplateMessage.HydratedFourRowTemplate;

                /**
                 * Codifica el mensaje HydratedFourRowTemplate. No implícitamente mensajes {@link proto.Message.TemplateMessage.HydratedFourRowTemplate.verify|verify}.
                 * @param message HydratedFourRowTemplate mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.Message.TemplateMessage.IHydratedFourRowTemplate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje HydratedFourRowTemplate message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.TemplateMessage.HydratedFourRowTemplate.verify|verify}.
                 * @param message HydratedFourRowTemplate mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.Message.TemplateMessage.IHydratedFourRowTemplate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HydratedFourRowTemplate message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns HydratedFourRowTemplate
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.TemplateMessage.HydratedFourRowTemplate;

                /**
                 * Decodes a HydratedFourRowTemplate message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns HydratedFourRowTemplate
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.TemplateMessage.HydratedFourRowTemplate;

                /**
                 * Verifies a HydratedFourRowTemplate message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a HydratedFourRowTemplate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns HydratedFourRowTemplate
                 */
                public static fromObject(object: { [k: string]: any }): proto.Message.TemplateMessage.HydratedFourRowTemplate;

                /**
                 * Crea un objeto simple desde HydratedFourRowTemplate. También convierte valores a otros tipos si se especifica.
                 * @param message HydratedFourRowTemplate
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.Message.TemplateMessage.HydratedFourRowTemplate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  HydratedFourRowTemplate a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un VideoMessage. */
        interface IVideoMessage {

            /** VideoMessage url */
            url?: (string|null);

            /** VideoMessage mimetype */
            mimetype?: (string|null);

            /** VideoMessage fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** VideoMessage fileLength */
            fileLength?: (number|Long|null);

            /** VideoMessage seconds */
            seconds?: (number|null);

            /** VideoMessage mediaKey */
            mediaKey?: (Uint8Array|null);

            /** VideoMessage caption */
            caption?: (string|null);

            /** VideoMessage gifPlayback */
            gifPlayback?: (boolean|null);

            /** VideoMessage height */
            height?: (number|null);

            /** VideoMessage width */
            width?: (number|null);

            /** VideoMessage fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** VideoMessage interactiveAnnotations */
            interactiveAnnotations?: (proto.IInteractiveAnnotation[]|null);

            /** VideoMessage directPath */
            directPath?: (string|null);

            /** VideoMessage mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** VideoMessage jpegThumbnail */
            jpegThumbnail?: (Uint8Array|null);

            /** VideoMessage contextInfo */
            contextInfo?: (proto.IContextInfo|null);

            /** VideoMessage streamingSidecar */
            streamingSidecar?: (Uint8Array|null);

            /** VideoMessage gifAttribution */
            gifAttribution?: (proto.Message.VideoMessage.Attribution|null);

            /** VideoMessage viewOnce */
            viewOnce?: (boolean|null);

            /** VideoMessage thumbnailDirectPath */
            thumbnailDirectPath?: (string|null);

            /** VideoMessage thumbnailSha256 */
            thumbnailSha256?: (Uint8Array|null);

            /** VideoMessage thumbnailEncSha256 */
            thumbnailEncSha256?: (Uint8Array|null);

            /** VideoMessage staticUrl */
            staticUrl?: (string|null);
        }

        /** Representa un VideoMessage. */
        class VideoMessage implements IVideoMessage {

            /**
             * Construya un nuevo VideoMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.Message.IVideoMessage);

            /** VideoMessage url. */
            public url: string;

            /** VideoMessage mimetype. */
            public mimetype: string;

            /** VideoMessage fileSha256. */
            public fileSha256: Uint8Array;

            /** VideoMessage fileLength. */
            public fileLength: (number|Long);

            /** VideoMessage seconds. */
            public seconds: number;

            /** VideoMessage mediaKey. */
            public mediaKey: Uint8Array;

            /** VideoMessage caption. */
            public caption: string;

            /** VideoMessage gifPlayback. */
            public gifPlayback: boolean;

            /** VideoMessage height. */
            public height: number;

            /** VideoMessage width. */
            public width: number;

            /** VideoMessage fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** VideoMessage interactiveAnnotations. */
            public interactiveAnnotations: proto.IInteractiveAnnotation[];

            /** VideoMessage directPath. */
            public directPath: string;

            /** VideoMessage mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** VideoMessage jpegThumbnail. */
            public jpegThumbnail: Uint8Array;

            /** VideoMessage contextInfo. */
            public contextInfo?: (proto.IContextInfo|null);

            /** VideoMessage streamingSidecar. */
            public streamingSidecar: Uint8Array;

            /** VideoMessage gifAttribution. */
            public gifAttribution: proto.Message.VideoMessage.Attribution;

            /** VideoMessage viewOnce. */
            public viewOnce: boolean;

            /** VideoMessage thumbnailDirectPath. */
            public thumbnailDirectPath: string;

            /** VideoMessage thumbnailSha256. */
            public thumbnailSha256: Uint8Array;

            /** VideoMessage thumbnailEncSha256. */
            public thumbnailEncSha256: Uint8Array;

            /** VideoMessage staticUrl. */
            public staticUrl: string;

            /**
             * Crea una nueva instancia VideoMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns VideoMessage instance
             */
            public static create(properties?: proto.Message.IVideoMessage): proto.Message.VideoMessage;

            /**
             * Codifica el mensaje VideoMessage. No implícitamente mensajes {@link proto.Message.VideoMessage.verify|verify}.
             * @param message VideoMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.Message.IVideoMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje VideoMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.Message.VideoMessage.verify|verify}.
             * @param message VideoMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.Message.IVideoMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a VideoMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns VideoMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Message.VideoMessage;

            /**
             * Decodes a VideoMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns VideoMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Message.VideoMessage;

            /**
             * Verifies a VideoMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a VideoMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns VideoMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.Message.VideoMessage;

            /**
             * Crea un objeto simple desde VideoMessage. También convierte valores a otros tipos si se especifica.
             * @param message VideoMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.Message.VideoMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  VideoMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace VideoMessage {

            /** Attribution enum. */
            enum Attribution {
                NONE = 0,
                GIPHY = 1,
                TENOR = 2
            }
        }
    }

    /** Propiedades de un MessageContextInfo. */
    interface IMessageContextInfo {

        /** MessageContextInfo deviceListMetadata */
        deviceListMetadata?: (proto.IDeviceListMetadata|null);

        /** MessageContextInfo deviceListMetadataVersion */
        deviceListMetadataVersion?: (number|null);

        /** MessageContextInfo messageSecret */
        messageSecret?: (Uint8Array|null);

        /** MessageContextInfo paddingBytes */
        paddingBytes?: (Uint8Array|null);
    }

    /** Representa un MessageContextInfo. */
    class MessageContextInfo implements IMessageContextInfo {

        /**
         * Construya un nuevo MessageContextInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMessageContextInfo);

        /** MessageContextInfo deviceListMetadata. */
        public deviceListMetadata?: (proto.IDeviceListMetadata|null);

        /** MessageContextInfo deviceListMetadataVersion. */
        public deviceListMetadataVersion: number;

        /** MessageContextInfo messageSecret. */
        public messageSecret: Uint8Array;

        /** MessageContextInfo paddingBytes. */
        public paddingBytes: Uint8Array;

        /**
         * Crea una nueva instancia MessageContextInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MessageContextInfo instance
         */
        public static create(properties?: proto.IMessageContextInfo): proto.MessageContextInfo;

        /**
         * Codifica el mensaje MessageContextInfo. No implícitamente mensajes {@link proto.MessageContextInfo.verify|verify}.
         * @param message MessageContextInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMessageContextInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MessageContextInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.MessageContextInfo.verify|verify}.
         * @param message MessageContextInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMessageContextInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MessageContextInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MessageContextInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MessageContextInfo;

        /**
         * Decodes a MessageContextInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MessageContextInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MessageContextInfo;

        /**
         * Verifies a MessageContextInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MessageContextInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MessageContextInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.MessageContextInfo;

        /**
         * Crea un objeto simple desde MessageContextInfo. También convierte valores a otros tipos si se especifica.
         * @param message MessageContextInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MessageContextInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MessageContextInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un MessageKey. */
    interface IMessageKey {

        /** MessageKey remoteJid */
        remoteJid?: (string|null);

        /** MessageKey fromMe */
        fromMe?: (boolean|null);

        /** MessageKey id */
        id?: (string|null);

        /** MessageKey participant */
        participant?: (string|null);
    }

    /** Representa un MessageKey. */
    class MessageKey implements IMessageKey {

        /**
         * Construya un nuevo MessageKey.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMessageKey);

        /** MessageKey remoteJid. */
        public remoteJid: string;

        /** MessageKey fromMe. */
        public fromMe: boolean;

        /** MessageKey id. */
        public id: string;

        /** MessageKey participant. */
        public participant: string;

        /**
         * Crea una nueva instancia MessageKey utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MessageKey instance
         */
        public static create(properties?: proto.IMessageKey): proto.MessageKey;

        /**
         * Codifica el mensaje MessageKey. No implícitamente mensajes {@link proto.MessageKey.verify|verify}.
         * @param message MessageKey mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MessageKey message, delimitado por longitud. No implícitamente mensajes {@link proto.MessageKey.verify|verify}.
         * @param message MessageKey mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MessageKey message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MessageKey
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MessageKey;

        /**
         * Decodes a MessageKey message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MessageKey
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MessageKey;

        /**
         * Verifies a MessageKey message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MessageKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MessageKey
         */
        public static fromObject(object: { [k: string]: any }): proto.MessageKey;

        /**
         * Crea un objeto simple desde MessageKey. También convierte valores a otros tipos si se especifica.
         * @param message MessageKey
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MessageKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MessageKey a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un Money. */
    interface IMoney {

        /** Money value */
        value?: (number|Long|null);

        /** Money offset */
        offset?: (number|null);

        /** Money currencyCode */
        currencyCode?: (string|null);
    }

    /** Representa un Money. */
    class Money implements IMoney {

        /**
         * Construya un nuevo Money.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMoney);

        /** Money value. */
        public value: (number|Long);

        /** Money offset. */
        public offset: number;

        /** Money currencyCode. */
        public currencyCode: string;

        /**
         * Crea una nueva instancia Money utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Money instance
         */
        public static create(properties?: proto.IMoney): proto.Money;

        /**
         * Codifica el mensaje Money. No implícitamente mensajes {@link proto.Money.verify|verify}.
         * @param message Money mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMoney, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Money message, delimitado por longitud. No implícitamente mensajes {@link proto.Money.verify|verify}.
         * @param message Money mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMoney, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Money message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Money
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Money;

        /**
         * Decodes a Money message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Money
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Money;

        /**
         * Verifies a Money message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Money message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Money
         */
        public static fromObject(object: { [k: string]: any }): proto.Money;

        /**
         * Crea un objeto simple desde Money. También convierte valores a otros tipos si se especifica.
         * @param message Money
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Money, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Money a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un MsgOpaqueData. */
    interface IMsgOpaqueData {

        /** MsgOpaqueData body */
        body?: (string|null);

        /** MsgOpaqueData caption */
        caption?: (string|null);

        /** MsgOpaqueData lng */
        lng?: (number|null);

        /** MsgOpaqueData isLive */
        isLive?: (boolean|null);

        /** MsgOpaqueData lat */
        lat?: (number|null);

        /** MsgOpaqueData paymentAmount1000 */
        paymentAmount1000?: (number|null);

        /** MsgOpaqueData paymentNoteMsgBody */
        paymentNoteMsgBody?: (string|null);

        /** MsgOpaqueData canonicalUrl */
        canonicalUrl?: (string|null);

        /** MsgOpaqueData matchedText */
        matchedText?: (string|null);

        /** MsgOpaqueData title */
        title?: (string|null);

        /** MsgOpaqueData description */
        description?: (string|null);

        /** MsgOpaqueData futureproofBuffer */
        futureproofBuffer?: (Uint8Array|null);

        /** MsgOpaqueData clientUrl */
        clientUrl?: (string|null);

        /** MsgOpaqueData loc */
        loc?: (string|null);

        /** MsgOpaqueData pollName */
        pollName?: (string|null);

        /** MsgOpaqueData pollOptions */
        pollOptions?: (proto.MsgOpaqueData.IPollOption[]|null);

        /** MsgOpaqueData pollSelectableOptionsCount */
        pollSelectableOptionsCount?: (number|null);

        /** MsgOpaqueData messageSecret */
        messageSecret?: (Uint8Array|null);

        /** MsgOpaqueData originalSelfAuthor */
        originalSelfAuthor?: (string|null);

        /** MsgOpaqueData senderTimestampMs */
        senderTimestampMs?: (number|Long|null);

        /** MsgOpaqueData pollUpdateParentKey */
        pollUpdateParentKey?: (string|null);

        /** MsgOpaqueData encPollVote */
        encPollVote?: (proto.IPollEncValue|null);

        /** MsgOpaqueData isSentCagPollCreation */
        isSentCagPollCreation?: (boolean|null);

        /** MsgOpaqueData encReactionTargetMessageKey */
        encReactionTargetMessageKey?: (string|null);

        /** MsgOpaqueData encReactionEncPayload */
        encReactionEncPayload?: (Uint8Array|null);

        /** MsgOpaqueData encReactionEncIv */
        encReactionEncIv?: (Uint8Array|null);
    }

    /** Representa un MsgOpaqueData. */
    class MsgOpaqueData implements IMsgOpaqueData {

        /**
         * Construya un nuevo MsgOpaqueData.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMsgOpaqueData);

        /** MsgOpaqueData body. */
        public body: string;

        /** MsgOpaqueData caption. */
        public caption: string;

        /** MsgOpaqueData lng. */
        public lng: number;

        /** MsgOpaqueData isLive. */
        public isLive: boolean;

        /** MsgOpaqueData lat. */
        public lat: number;

        /** MsgOpaqueData paymentAmount1000. */
        public paymentAmount1000: number;

        /** MsgOpaqueData paymentNoteMsgBody. */
        public paymentNoteMsgBody: string;

        /** MsgOpaqueData canonicalUrl. */
        public canonicalUrl: string;

        /** MsgOpaqueData matchedText. */
        public matchedText: string;

        /** MsgOpaqueData title. */
        public title: string;

        /** MsgOpaqueData description. */
        public description: string;

        /** MsgOpaqueData futureproofBuffer. */
        public futureproofBuffer: Uint8Array;

        /** MsgOpaqueData clientUrl. */
        public clientUrl: string;

        /** MsgOpaqueData loc. */
        public loc: string;

        /** MsgOpaqueData pollName. */
        public pollName: string;

        /** MsgOpaqueData pollOptions. */
        public pollOptions: proto.MsgOpaqueData.IPollOption[];

        /** MsgOpaqueData pollSelectableOptionsCount. */
        public pollSelectableOptionsCount: number;

        /** MsgOpaqueData messageSecret. */
        public messageSecret: Uint8Array;

        /** MsgOpaqueData originalSelfAuthor. */
        public originalSelfAuthor: string;

        /** MsgOpaqueData senderTimestampMs. */
        public senderTimestampMs: (number|Long);

        /** MsgOpaqueData pollUpdateParentKey. */
        public pollUpdateParentKey: string;

        /** MsgOpaqueData encPollVote. */
        public encPollVote?: (proto.IPollEncValue|null);

        /** MsgOpaqueData isSentCagPollCreation. */
        public isSentCagPollCreation: boolean;

        /** MsgOpaqueData encReactionTargetMessageKey. */
        public encReactionTargetMessageKey: string;

        /** MsgOpaqueData encReactionEncPayload. */
        public encReactionEncPayload: Uint8Array;

        /** MsgOpaqueData encReactionEncIv. */
        public encReactionEncIv: Uint8Array;

        /**
         * Crea una nueva instancia MsgOpaqueData utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MsgOpaqueData instance
         */
        public static create(properties?: proto.IMsgOpaqueData): proto.MsgOpaqueData;

        /**
         * Codifica el mensaje MsgOpaqueData. No implícitamente mensajes {@link proto.MsgOpaqueData.verify|verify}.
         * @param message MsgOpaqueData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMsgOpaqueData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MsgOpaqueData message, delimitado por longitud. No implícitamente mensajes {@link proto.MsgOpaqueData.verify|verify}.
         * @param message MsgOpaqueData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMsgOpaqueData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MsgOpaqueData message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MsgOpaqueData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MsgOpaqueData;

        /**
         * Decodes a MsgOpaqueData message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MsgOpaqueData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MsgOpaqueData;

        /**
         * Verifies a MsgOpaqueData message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MsgOpaqueData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MsgOpaqueData
         */
        public static fromObject(object: { [k: string]: any }): proto.MsgOpaqueData;

        /**
         * Crea un objeto simple desde MsgOpaqueData. También convierte valores a otros tipos si se especifica.
         * @param message MsgOpaqueData
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MsgOpaqueData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MsgOpaqueData a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace MsgOpaqueData {

        /** Propiedades de un PollOption. */
        interface IPollOption {

            /** PollOption name */
            name?: (string|null);
        }

        /** Representa un PollOption. */
        class PollOption implements IPollOption {

            /**
             * Construya un nuevo PollOption.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.MsgOpaqueData.IPollOption);

            /** PollOption name. */
            public name: string;

            /**
             * Crea una nueva instancia PollOption utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PollOption instance
             */
            public static create(properties?: proto.MsgOpaqueData.IPollOption): proto.MsgOpaqueData.PollOption;

            /**
             * Codifica el mensaje PollOption. No implícitamente mensajes {@link proto.MsgOpaqueData.PollOption.verify|verify}.
             * @param message PollOption mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.MsgOpaqueData.IPollOption, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PollOption message, delimitado por longitud. No implícitamente mensajes {@link proto.MsgOpaqueData.PollOption.verify|verify}.
             * @param message PollOption mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.MsgOpaqueData.IPollOption, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PollOption message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PollOption
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MsgOpaqueData.PollOption;

            /**
             * Decodes a PollOption message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PollOption
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MsgOpaqueData.PollOption;

            /**
             * Verifies a PollOption message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PollOption message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PollOption
             */
            public static fromObject(object: { [k: string]: any }): proto.MsgOpaqueData.PollOption;

            /**
             * Crea un objeto simple desde PollOption. También convierte valores a otros tipos si se especifica.
             * @param message PollOption
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.MsgOpaqueData.PollOption, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PollOption a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un MsgRowOpaqueData. */
    interface IMsgRowOpaqueData {

        /** MsgRowOpaqueData currentMsg */
        currentMsg?: (proto.IMsgOpaqueData|null);

        /** MsgRowOpaqueData quotedMsg */
        quotedMsg?: (proto.IMsgOpaqueData|null);
    }

    /** Representa un MsgRowOpaqueData. */
    class MsgRowOpaqueData implements IMsgRowOpaqueData {

        /**
         * Construya un nuevo MsgRowOpaqueData.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IMsgRowOpaqueData);

        /** MsgRowOpaqueData currentMsg. */
        public currentMsg?: (proto.IMsgOpaqueData|null);

        /** MsgRowOpaqueData quotedMsg. */
        public quotedMsg?: (proto.IMsgOpaqueData|null);

        /**
         * Crea una nueva instancia MsgRowOpaqueData utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns MsgRowOpaqueData instance
         */
        public static create(properties?: proto.IMsgRowOpaqueData): proto.MsgRowOpaqueData;

        /**
         * Codifica el mensaje MsgRowOpaqueData. No implícitamente mensajes {@link proto.MsgRowOpaqueData.verify|verify}.
         * @param message MsgRowOpaqueData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IMsgRowOpaqueData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje MsgRowOpaqueData message, delimitado por longitud. No implícitamente mensajes {@link proto.MsgRowOpaqueData.verify|verify}.
         * @param message MsgRowOpaqueData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IMsgRowOpaqueData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a MsgRowOpaqueData message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns MsgRowOpaqueData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.MsgRowOpaqueData;

        /**
         * Decodes a MsgRowOpaqueData message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns MsgRowOpaqueData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.MsgRowOpaqueData;

        /**
         * Verifies a MsgRowOpaqueData message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a MsgRowOpaqueData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns MsgRowOpaqueData
         */
        public static fromObject(object: { [k: string]: any }): proto.MsgRowOpaqueData;

        /**
         * Crea un objeto simple desde MsgRowOpaqueData. También convierte valores a otros tipos si se especifica.
         * @param message MsgRowOpaqueData
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.MsgRowOpaqueData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  MsgRowOpaqueData a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un NoiseCertificate. */
    interface INoiseCertificate {

        /** NoiseCertificate details */
        details?: (Uint8Array|null);

        /** NoiseCertificate signature */
        signature?: (Uint8Array|null);
    }

    /** Representa un NoiseCertificate. */
    class NoiseCertificate implements INoiseCertificate {

        /**
         * Construya un nuevo NoiseCertificate.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.INoiseCertificate);

        /** NoiseCertificate details. */
        public details: Uint8Array;

        /** NoiseCertificate signature. */
        public signature: Uint8Array;

        /**
         * Crea una nueva instancia NoiseCertificate utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns NoiseCertificate instance
         */
        public static create(properties?: proto.INoiseCertificate): proto.NoiseCertificate;

        /**
         * Codifica el mensaje NoiseCertificate. No implícitamente mensajes {@link proto.NoiseCertificate.verify|verify}.
         * @param message NoiseCertificate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.INoiseCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje NoiseCertificate message, delimitado por longitud. No implícitamente mensajes {@link proto.NoiseCertificate.verify|verify}.
         * @param message NoiseCertificate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.INoiseCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a NoiseCertificate message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns NoiseCertificate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NoiseCertificate;

        /**
         * Decodes a NoiseCertificate message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns NoiseCertificate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NoiseCertificate;

        /**
         * Verifies a NoiseCertificate message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a NoiseCertificate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns NoiseCertificate
         */
        public static fromObject(object: { [k: string]: any }): proto.NoiseCertificate;

        /**
         * Crea un objeto simple desde NoiseCertificate. También convierte valores a otros tipos si se especifica.
         * @param message NoiseCertificate
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.NoiseCertificate, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  NoiseCertificate a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace NoiseCertificate {

        /** Propiedades de un Details. */
        interface IDetails {

            /** Details serial */
            serial?: (number|null);

            /** Details issuer */
            issuer?: (string|null);

            /** Details expires */
            expires?: (number|Long|null);

            /** Details subject */
            subject?: (string|null);

            /** Details key */
            key?: (Uint8Array|null);
        }

        /** Representa un Details. */
        class Details implements IDetails {

            /**
             * Construya un nuevo Details.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.NoiseCertificate.IDetails);

            /** Details serial. */
            public serial: number;

            /** Details issuer. */
            public issuer: string;

            /** Details expires. */
            public expires: (number|Long);

            /** Details subject. */
            public subject: string;

            /** Details key. */
            public key: Uint8Array;

            /**
             * Crea una nueva instancia Details utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns Details instance
             */
            public static create(properties?: proto.NoiseCertificate.IDetails): proto.NoiseCertificate.Details;

            /**
             * Codifica el mensaje Details. No implícitamente mensajes {@link proto.NoiseCertificate.Details.verify|verify}.
             * @param message Details mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.NoiseCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje Details message, delimitado por longitud. No implícitamente mensajes {@link proto.NoiseCertificate.Details.verify|verify}.
             * @param message Details mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.NoiseCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Details message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns Details
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NoiseCertificate.Details;

            /**
             * Decodes a Details message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns Details
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NoiseCertificate.Details;

            /**
             * Verifies a Details message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Details message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns Details
             */
            public static fromObject(object: { [k: string]: any }): proto.NoiseCertificate.Details;

            /**
             * Crea un objeto simple desde Details. También convierte valores a otros tipos si se especifica.
             * @param message Details
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.NoiseCertificate.Details, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  Details a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un NotificationMessageInfo. */
    interface INotificationMessageInfo {

        /** NotificationMessageInfo key */
        key?: (proto.IMessageKey|null);

        /** NotificationMessageInfo message */
        message?: (proto.IMessage|null);

        /** NotificationMessageInfo messageTimestamp */
        messageTimestamp?: (number|Long|null);

        /** NotificationMessageInfo participant */
        participant?: (string|null);
    }

    /** Representa un NotificationMessageInfo. */
    class NotificationMessageInfo implements INotificationMessageInfo {

        /**
         * Construya un nuevo NotificationMessageInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.INotificationMessageInfo);

        /** NotificationMessageInfo key. */
        public key?: (proto.IMessageKey|null);

        /** NotificationMessageInfo message. */
        public message?: (proto.IMessage|null);

        /** NotificationMessageInfo messageTimestamp. */
        public messageTimestamp: (number|Long);

        /** NotificationMessageInfo participant. */
        public participant: string;

        /**
         * Crea una nueva instancia NotificationMessageInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns NotificationMessageInfo instance
         */
        public static create(properties?: proto.INotificationMessageInfo): proto.NotificationMessageInfo;

        /**
         * Codifica el mensaje NotificationMessageInfo. No implícitamente mensajes {@link proto.NotificationMessageInfo.verify|verify}.
         * @param message NotificationMessageInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.INotificationMessageInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje NotificationMessageInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.NotificationMessageInfo.verify|verify}.
         * @param message NotificationMessageInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.INotificationMessageInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a NotificationMessageInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns NotificationMessageInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NotificationMessageInfo;

        /**
         * Decodes a NotificationMessageInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns NotificationMessageInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NotificationMessageInfo;

        /**
         * Verifies a NotificationMessageInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a NotificationMessageInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns NotificationMessageInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.NotificationMessageInfo;

        /**
         * Crea un objeto simple desde NotificationMessageInfo. También convierte valores a otros tipos si se especifica.
         * @param message NotificationMessageInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.NotificationMessageInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  NotificationMessageInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PastParticipant. */
    interface IPastParticipant {

        /** PastParticipant userJid */
        userJid?: (string|null);

        /** PastParticipant leaveReason */
        leaveReason?: (proto.PastParticipant.LeaveReason|null);

        /** PastParticipant leaveTs */
        leaveTs?: (number|Long|null);
    }

    /** Representa un PastParticipant. */
    class PastParticipant implements IPastParticipant {

        /**
         * Construya un nuevo PastParticipant.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPastParticipant);

        /** PastParticipant userJid. */
        public userJid: string;

        /** PastParticipant leaveReason. */
        public leaveReason: proto.PastParticipant.LeaveReason;

        /** PastParticipant leaveTs. */
        public leaveTs: (number|Long);

        /**
         * Crea una nueva instancia PastParticipant utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PastParticipant instance
         */
        public static create(properties?: proto.IPastParticipant): proto.PastParticipant;

        /**
         * Codifica el mensaje PastParticipant. No implícitamente mensajes {@link proto.PastParticipant.verify|verify}.
         * @param message PastParticipant mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPastParticipant, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PastParticipant message, delimitado por longitud. No implícitamente mensajes {@link proto.PastParticipant.verify|verify}.
         * @param message PastParticipant mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPastParticipant, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PastParticipant message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PastParticipant
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PastParticipant;

        /**
         * Decodes a PastParticipant message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PastParticipant
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PastParticipant;

        /**
         * Verifies a PastParticipant message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PastParticipant message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PastParticipant
         */
        public static fromObject(object: { [k: string]: any }): proto.PastParticipant;

        /**
         * Crea un objeto simple desde PastParticipant. También convierte valores a otros tipos si se especifica.
         * @param message PastParticipant
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PastParticipant, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PastParticipant a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace PastParticipant {

        /** LeaveReason enum. */
        enum LeaveReason {
            LEFT = 0,
            REMOVED = 1
        }
    }

    /** Propiedades de un PastParticipants. */
    interface IPastParticipants {

        /** PastParticipants groupJid */
        groupJid?: (string|null);

        /** PastParticipants pastParticipants */
        pastParticipants?: (proto.IPastParticipant[]|null);
    }

    /** Representa un PastParticipants. */
    class PastParticipants implements IPastParticipants {

        /**
         * Construya un nuevo PastParticipants.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPastParticipants);

        /** PastParticipants groupJid. */
        public groupJid: string;

        /** PastParticipants pastParticipants. */
        public pastParticipants: proto.IPastParticipant[];

        /**
         * Crea una nueva instancia PastParticipants utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PastParticipants instance
         */
        public static create(properties?: proto.IPastParticipants): proto.PastParticipants;

        /**
         * Codifica el mensaje PastParticipants. No implícitamente mensajes {@link proto.PastParticipants.verify|verify}.
         * @param message PastParticipants mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPastParticipants, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PastParticipants message, delimitado por longitud. No implícitamente mensajes {@link proto.PastParticipants.verify|verify}.
         * @param message PastParticipants mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPastParticipants, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PastParticipants message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PastParticipants
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PastParticipants;

        /**
         * Decodes a PastParticipants message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PastParticipants
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PastParticipants;

        /**
         * Verifies a PastParticipants message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PastParticipants message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PastParticipants
         */
        public static fromObject(object: { [k: string]: any }): proto.PastParticipants;

        /**
         * Crea un objeto simple desde PastParticipants. También convierte valores a otros tipos si se especifica.
         * @param message PastParticipants
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PastParticipants, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PastParticipants a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PaymentBackground. */
    interface IPaymentBackground {

        /** PaymentBackground id */
        id?: (string|null);

        /** PaymentBackground fileLength */
        fileLength?: (number|Long|null);

        /** PaymentBackground width */
        width?: (number|null);

        /** PaymentBackground height */
        height?: (number|null);

        /** PaymentBackground mimetype */
        mimetype?: (string|null);

        /** PaymentBackground placeholderArgb */
        placeholderArgb?: (number|null);

        /** PaymentBackground textArgb */
        textArgb?: (number|null);

        /** PaymentBackground subtextArgb */
        subtextArgb?: (number|null);

        /** PaymentBackground mediaData */
        mediaData?: (proto.PaymentBackground.IMediaData|null);

        /** PaymentBackground type */
        type?: (proto.PaymentBackground.Type|null);
    }

    /** Representa un PaymentBackground. */
    class PaymentBackground implements IPaymentBackground {

        /**
         * Construya un nuevo PaymentBackground.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPaymentBackground);

        /** PaymentBackground id. */
        public id: string;

        /** PaymentBackground fileLength. */
        public fileLength: (number|Long);

        /** PaymentBackground width. */
        public width: number;

        /** PaymentBackground height. */
        public height: number;

        /** PaymentBackground mimetype. */
        public mimetype: string;

        /** PaymentBackground placeholderArgb. */
        public placeholderArgb: number;

        /** PaymentBackground textArgb. */
        public textArgb: number;

        /** PaymentBackground subtextArgb. */
        public subtextArgb: number;

        /** PaymentBackground mediaData. */
        public mediaData?: (proto.PaymentBackground.IMediaData|null);

        /** PaymentBackground type. */
        public type: proto.PaymentBackground.Type;

        /**
         * Crea una nueva instancia PaymentBackground utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PaymentBackground instance
         */
        public static create(properties?: proto.IPaymentBackground): proto.PaymentBackground;

        /**
         * Codifica el mensaje PaymentBackground. No implícitamente mensajes {@link proto.PaymentBackground.verify|verify}.
         * @param message PaymentBackground mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPaymentBackground, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PaymentBackground message, delimitado por longitud. No implícitamente mensajes {@link proto.PaymentBackground.verify|verify}.
         * @param message PaymentBackground mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPaymentBackground, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PaymentBackground message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PaymentBackground
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PaymentBackground;

        /**
         * Decodes a PaymentBackground message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PaymentBackground
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PaymentBackground;

        /**
         * Verifies a PaymentBackground message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PaymentBackground message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PaymentBackground
         */
        public static fromObject(object: { [k: string]: any }): proto.PaymentBackground;

        /**
         * Crea un objeto simple desde PaymentBackground. También convierte valores a otros tipos si se especifica.
         * @param message PaymentBackground
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PaymentBackground, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PaymentBackground a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace PaymentBackground {

        /** Propiedades de un MediaData. */
        interface IMediaData {

            /** MediaData mediaKey */
            mediaKey?: (Uint8Array|null);

            /** MediaData mediaKeyTimestamp */
            mediaKeyTimestamp?: (number|Long|null);

            /** MediaData fileSha256 */
            fileSha256?: (Uint8Array|null);

            /** MediaData fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** MediaData directPath */
            directPath?: (string|null);
        }

        /** Representa un MediaData. */
        class MediaData implements IMediaData {

            /**
             * Construya un nuevo MediaData.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.PaymentBackground.IMediaData);

            /** MediaData mediaKey. */
            public mediaKey: Uint8Array;

            /** MediaData mediaKeyTimestamp. */
            public mediaKeyTimestamp: (number|Long);

            /** MediaData fileSha256. */
            public fileSha256: Uint8Array;

            /** MediaData fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** MediaData directPath. */
            public directPath: string;

            /**
             * Crea una nueva instancia MediaData utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns MediaData instance
             */
            public static create(properties?: proto.PaymentBackground.IMediaData): proto.PaymentBackground.MediaData;

            /**
             * Codifica el mensaje MediaData. No implícitamente mensajes {@link proto.PaymentBackground.MediaData.verify|verify}.
             * @param message MediaData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.PaymentBackground.IMediaData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje MediaData message, delimitado por longitud. No implícitamente mensajes {@link proto.PaymentBackground.MediaData.verify|verify}.
             * @param message MediaData mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.PaymentBackground.IMediaData, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MediaData message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns MediaData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PaymentBackground.MediaData;

            /**
             * Decodes a MediaData message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns MediaData
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PaymentBackground.MediaData;

            /**
             * Verifies a MediaData message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a MediaData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns MediaData
             */
            public static fromObject(object: { [k: string]: any }): proto.PaymentBackground.MediaData;

            /**
             * Crea un objeto simple desde MediaData. También convierte valores a otros tipos si se especifica.
             * @param message MediaData
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.PaymentBackground.MediaData, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  MediaData a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Type enum. */
        enum Type {
            UNKNOWN = 0,
            DEFAULT = 1
        }
    }

    /** Propiedades de un PaymentInfo. */
    interface IPaymentInfo {

        /** PaymentInfo currencyDeprecated */
        currencyDeprecated?: (proto.PaymentInfo.Currency|null);

        /** PaymentInfo amount1000 */
        amount1000?: (number|Long|null);

        /** PaymentInfo receiverJid */
        receiverJid?: (string|null);

        /** PaymentInfo status */
        status?: (proto.PaymentInfo.Status|null);

        /** PaymentInfo transactionTimestamp */
        transactionTimestamp?: (number|Long|null);

        /** PaymentInfo requestMessageKey */
        requestMessageKey?: (proto.IMessageKey|null);

        /** PaymentInfo expiryTimestamp */
        expiryTimestamp?: (number|Long|null);

        /** PaymentInfo futureproofed */
        futureproofed?: (boolean|null);

        /** PaymentInfo currency */
        currency?: (string|null);

        /** PaymentInfo txnStatus */
        txnStatus?: (proto.PaymentInfo.TxnStatus|null);

        /** PaymentInfo useNoviFiatFormat */
        useNoviFiatFormat?: (boolean|null);

        /** PaymentInfo primaryAmount */
        primaryAmount?: (proto.IMoney|null);

        /** PaymentInfo exchangeAmount */
        exchangeAmount?: (proto.IMoney|null);
    }

    /** Representa un PaymentInfo. */
    class PaymentInfo implements IPaymentInfo {

        /**
         * Construya un nuevo PaymentInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPaymentInfo);

        /** PaymentInfo currencyDeprecated. */
        public currencyDeprecated: proto.PaymentInfo.Currency;

        /** PaymentInfo amount1000. */
        public amount1000: (number|Long);

        /** PaymentInfo receiverJid. */
        public receiverJid: string;

        /** PaymentInfo status. */
        public status: proto.PaymentInfo.Status;

        /** PaymentInfo transactionTimestamp. */
        public transactionTimestamp: (number|Long);

        /** PaymentInfo requestMessageKey. */
        public requestMessageKey?: (proto.IMessageKey|null);

        /** PaymentInfo expiryTimestamp. */
        public expiryTimestamp: (number|Long);

        /** PaymentInfo futureproofed. */
        public futureproofed: boolean;

        /** PaymentInfo currency. */
        public currency: string;

        /** PaymentInfo txnStatus. */
        public txnStatus: proto.PaymentInfo.TxnStatus;

        /** PaymentInfo useNoviFiatFormat. */
        public useNoviFiatFormat: boolean;

        /** PaymentInfo primaryAmount. */
        public primaryAmount?: (proto.IMoney|null);

        /** PaymentInfo exchangeAmount. */
        public exchangeAmount?: (proto.IMoney|null);

        /**
         * Crea una nueva instancia PaymentInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PaymentInfo instance
         */
        public static create(properties?: proto.IPaymentInfo): proto.PaymentInfo;

        /**
         * Codifica el mensaje PaymentInfo. No implícitamente mensajes {@link proto.PaymentInfo.verify|verify}.
         * @param message PaymentInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPaymentInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PaymentInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.PaymentInfo.verify|verify}.
         * @param message PaymentInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPaymentInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PaymentInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PaymentInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PaymentInfo;

        /**
         * Decodes a PaymentInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PaymentInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PaymentInfo;

        /**
         * Verifies a PaymentInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PaymentInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PaymentInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.PaymentInfo;

        /**
         * Crea un objeto simple desde PaymentInfo. También convierte valores a otros tipos si se especifica.
         * @param message PaymentInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PaymentInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PaymentInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace PaymentInfo {

        /** Currency enum. */
        enum Currency {
            UNKNOWN_CURRENCY = 0,
            INR = 1
        }

        /** Status enum. */
        enum Status {
            UNKNOWN_STATUS = 0,
            PROCESSING = 1,
            SENT = 2,
            NEED_TO_ACCEPT = 3,
            COMPLETE = 4,
            COULD_NOT_COMPLETE = 5,
            REFUNDED = 6,
            EXPIRED = 7,
            REJECTED = 8,
            CANCELLED = 9,
            WAITING_FOR_PAYER = 10,
            WAITING = 11
        }

        /** TxnStatus enum. */
        enum TxnStatus {
            UNKNOWN = 0,
            PENDING_SETUP = 1,
            PENDING_RECEIVER_SETUP = 2,
            INIT = 3,
            SUCCESS = 4,
            COMPLETED = 5,
            FAILED = 6,
            FAILED_RISK = 7,
            FAILED_PROCESSING = 8,
            FAILED_RECEIVER_PROCESSING = 9,
            FAILED_DA = 10,
            FAILED_DA_FINAL = 11,
            REFUNDED_TXN = 12,
            REFUND_FAILED = 13,
            REFUND_FAILED_PROCESSING = 14,
            REFUND_FAILED_DA = 15,
            EXPIRED_TXN = 16,
            AUTH_CANCELED = 17,
            AUTH_CANCEL_FAILED_PROCESSING = 18,
            AUTH_CANCEL_FAILED = 19,
            COLLECT_INIT = 20,
            COLLECT_SUCCESS = 21,
            COLLECT_FAILED = 22,
            COLLECT_FAILED_RISK = 23,
            COLLECT_REJECTED = 24,
            COLLECT_EXPIRED = 25,
            COLLECT_CANCELED = 26,
            COLLECT_CANCELLING = 27,
            IN_REVIEW = 28,
            REVERSAL_SUCCESS = 29,
            REVERSAL_PENDING = 30,
            REFUND_PENDING = 31
        }
    }

    /** Propiedades de un PhotoChange. */
    interface IPhotoChange {

        /** PhotoChange oldPhoto */
        oldPhoto?: (Uint8Array|null);

        /** PhotoChange newPhoto */
        newPhoto?: (Uint8Array|null);

        /** PhotoChange newPhotoId */
        newPhotoId?: (number|null);
    }

    /** Representa un PhotoChange. */
    class PhotoChange implements IPhotoChange {

        /**
         * Construya un nuevo PhotoChange.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPhotoChange);

        /** PhotoChange oldPhoto. */
        public oldPhoto: Uint8Array;

        /** PhotoChange newPhoto. */
        public newPhoto: Uint8Array;

        /** PhotoChange newPhotoId. */
        public newPhotoId: number;

        /**
         * Crea una nueva instancia PhotoChange utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PhotoChange instance
         */
        public static create(properties?: proto.IPhotoChange): proto.PhotoChange;

        /**
         * Codifica el mensaje PhotoChange. No implícitamente mensajes {@link proto.PhotoChange.verify|verify}.
         * @param message PhotoChange mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPhotoChange, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PhotoChange message, delimitado por longitud. No implícitamente mensajes {@link proto.PhotoChange.verify|verify}.
         * @param message PhotoChange mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPhotoChange, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PhotoChange message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PhotoChange
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PhotoChange;

        /**
         * Decodes a PhotoChange message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PhotoChange
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PhotoChange;

        /**
         * Verifies a PhotoChange message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PhotoChange message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PhotoChange
         */
        public static fromObject(object: { [k: string]: any }): proto.PhotoChange;

        /**
         * Crea un objeto simple desde PhotoChange. También convierte valores a otros tipos si se especifica.
         * @param message PhotoChange
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PhotoChange, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PhotoChange a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un Point. */
    interface IPoint {

        /** Point xDeprecated */
        xDeprecated?: (number|null);

        /** Point yDeprecated */
        yDeprecated?: (number|null);

        /** Point x */
        x?: (number|null);

        /** Point y */
        y?: (number|null);
    }

    /** Representa un Point. */
    class Point implements IPoint {

        /**
         * Construya un nuevo Point.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPoint);

        /** Point xDeprecated. */
        public xDeprecated: number;

        /** Point yDeprecated. */
        public yDeprecated: number;

        /** Point x. */
        public x: number;

        /** Point y. */
        public y: number;

        /**
         * Crea una nueva instancia Point utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Point instance
         */
        public static create(properties?: proto.IPoint): proto.Point;

        /**
         * Codifica el mensaje Point. No implícitamente mensajes {@link proto.Point.verify|verify}.
         * @param message Point mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPoint, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Point message, delimitado por longitud. No implícitamente mensajes {@link proto.Point.verify|verify}.
         * @param message Point mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPoint, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Point message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Point
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Point;

        /**
         * Decodes a Point message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Point
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Point;

        /**
         * Verifies a Point message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Point message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Point
         */
        public static fromObject(object: { [k: string]: any }): proto.Point;

        /**
         * Crea un objeto simple desde Point. También convierte valores a otros tipos si se especifica.
         * @param message Point
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Point, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Point a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PollAdditionalMetadata. */
    interface IPollAdditionalMetadata {

        /** PollAdditionalMetadata pollInvalidated */
        pollInvalidated?: (boolean|null);
    }

    /** Representa un PollAdditionalMetadata. */
    class PollAdditionalMetadata implements IPollAdditionalMetadata {

        /**
         * Construya un nuevo PollAdditionalMetadata.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPollAdditionalMetadata);

        /** PollAdditionalMetadata pollInvalidated. */
        public pollInvalidated: boolean;

        /**
         * Crea una nueva instancia PollAdditionalMetadata utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PollAdditionalMetadata instance
         */
        public static create(properties?: proto.IPollAdditionalMetadata): proto.PollAdditionalMetadata;

        /**
         * Codifica el mensaje PollAdditionalMetadata. No implícitamente mensajes {@link proto.PollAdditionalMetadata.verify|verify}.
         * @param message PollAdditionalMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPollAdditionalMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PollAdditionalMetadata message, delimitado por longitud. No implícitamente mensajes {@link proto.PollAdditionalMetadata.verify|verify}.
         * @param message PollAdditionalMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPollAdditionalMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PollAdditionalMetadata message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PollAdditionalMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PollAdditionalMetadata;

        /**
         * Decodes a PollAdditionalMetadata message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PollAdditionalMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PollAdditionalMetadata;

        /**
         * Verifies a PollAdditionalMetadata message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PollAdditionalMetadata message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PollAdditionalMetadata
         */
        public static fromObject(object: { [k: string]: any }): proto.PollAdditionalMetadata;

        /**
         * Crea un objeto simple desde PollAdditionalMetadata. También convierte valores a otros tipos si se especifica.
         * @param message PollAdditionalMetadata
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PollAdditionalMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PollAdditionalMetadata a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PollEncValue. */
    interface IPollEncValue {

        /** PollEncValue encPayload */
        encPayload?: (Uint8Array|null);

        /** PollEncValue encIv */
        encIv?: (Uint8Array|null);
    }

    /** Representa un PollEncValue. */
    class PollEncValue implements IPollEncValue {

        /**
         * Construya un nuevo PollEncValue.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPollEncValue);

        /** PollEncValue encPayload. */
        public encPayload: Uint8Array;

        /** PollEncValue encIv. */
        public encIv: Uint8Array;

        /**
         * Crea una nueva instancia PollEncValue utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PollEncValue instance
         */
        public static create(properties?: proto.IPollEncValue): proto.PollEncValue;

        /**
         * Codifica el mensaje PollEncValue. No implícitamente mensajes {@link proto.PollEncValue.verify|verify}.
         * @param message PollEncValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPollEncValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PollEncValue message, delimitado por longitud. No implícitamente mensajes {@link proto.PollEncValue.verify|verify}.
         * @param message PollEncValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPollEncValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PollEncValue message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PollEncValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PollEncValue;

        /**
         * Decodes a PollEncValue message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PollEncValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PollEncValue;

        /**
         * Verifies a PollEncValue message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PollEncValue message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PollEncValue
         */
        public static fromObject(object: { [k: string]: any }): proto.PollEncValue;

        /**
         * Crea un objeto simple desde PollEncValue. También convierte valores a otros tipos si se especifica.
         * @param message PollEncValue
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PollEncValue, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PollEncValue a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PollUpdate. */
    interface IPollUpdate {

        /** PollUpdate pollUpdateMessageKey */
        pollUpdateMessageKey?: (proto.IMessageKey|null);

        /** PollUpdate vote */
        vote?: (proto.Message.IPollVoteMessage|null);

        /** PollUpdate senderTimestampMs */
        senderTimestampMs?: (number|Long|null);

        /** PollUpdate serverTimestampMs */
        serverTimestampMs?: (number|Long|null);

        /** PollUpdate unread */
        unread?: (boolean|null);
    }

    /** Representa un PollUpdate. */
    class PollUpdate implements IPollUpdate {

        /**
         * Construya un nuevo PollUpdate.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPollUpdate);

        /** PollUpdate pollUpdateMessageKey. */
        public pollUpdateMessageKey?: (proto.IMessageKey|null);

        /** PollUpdate vote. */
        public vote?: (proto.Message.IPollVoteMessage|null);

        /** PollUpdate senderTimestampMs. */
        public senderTimestampMs: (number|Long);

        /** PollUpdate serverTimestampMs. */
        public serverTimestampMs: (number|Long);

        /** PollUpdate unread. */
        public unread: boolean;

        /**
         * Crea una nueva instancia PollUpdate utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PollUpdate instance
         */
        public static create(properties?: proto.IPollUpdate): proto.PollUpdate;

        /**
         * Codifica el mensaje PollUpdate. No implícitamente mensajes {@link proto.PollUpdate.verify|verify}.
         * @param message PollUpdate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPollUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PollUpdate message, delimitado por longitud. No implícitamente mensajes {@link proto.PollUpdate.verify|verify}.
         * @param message PollUpdate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPollUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PollUpdate message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PollUpdate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PollUpdate;

        /**
         * Decodes a PollUpdate message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PollUpdate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PollUpdate;

        /**
         * Verifies a PollUpdate message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PollUpdate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PollUpdate
         */
        public static fromObject(object: { [k: string]: any }): proto.PollUpdate;

        /**
         * Crea un objeto simple desde PollUpdate. También convierte valores a otros tipos si se especifica.
         * @param message PollUpdate
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PollUpdate, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PollUpdate a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un PreKeyRecordStructure. */
    interface IPreKeyRecordStructure {

        /** PreKeyRecordStructure id */
        id?: (number|null);

        /** PreKeyRecordStructure publicKey */
        publicKey?: (Uint8Array|null);

        /** PreKeyRecordStructure privateKey */
        privateKey?: (Uint8Array|null);
    }

    /** Representa un PreKeyRecordStructure. */
    class PreKeyRecordStructure implements IPreKeyRecordStructure {

        /**
         * Construya un nuevo PreKeyRecordStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPreKeyRecordStructure);

        /** PreKeyRecordStructure id. */
        public id: number;

        /** PreKeyRecordStructure publicKey. */
        public publicKey: Uint8Array;

        /** PreKeyRecordStructure privateKey. */
        public privateKey: Uint8Array;

        /**
         * Crea una nueva instancia PreKeyRecordStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns PreKeyRecordStructure instance
         */
        public static create(properties?: proto.IPreKeyRecordStructure): proto.PreKeyRecordStructure;

        /**
         * Codifica el mensaje PreKeyRecordStructure. No implícitamente mensajes {@link proto.PreKeyRecordStructure.verify|verify}.
         * @param message PreKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPreKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje PreKeyRecordStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.PreKeyRecordStructure.verify|verify}.
         * @param message PreKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPreKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PreKeyRecordStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns PreKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.PreKeyRecordStructure;

        /**
         * Decodes a PreKeyRecordStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns PreKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.PreKeyRecordStructure;

        /**
         * Verifies a PreKeyRecordStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PreKeyRecordStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns PreKeyRecordStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.PreKeyRecordStructure;

        /**
         * Crea un objeto simple desde PreKeyRecordStructure. También convierte valores a otros tipos si se especifica.
         * @param message PreKeyRecordStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.PreKeyRecordStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  PreKeyRecordStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un Pushname. */
    interface IPushname {

        /** Pushname id */
        id?: (string|null);

        /** Pushname pushname */
        pushname?: (string|null);
    }

    /** Representa un Pushname. */
    class Pushname implements IPushname {

        /**
         * Construya un nuevo Pushname.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IPushname);

        /** Pushname id. */
        public id: string;

        /** Pushname pushname. */
        public pushname: string;

        /**
         * Crea una nueva instancia Pushname utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Pushname instance
         */
        public static create(properties?: proto.IPushname): proto.Pushname;

        /**
         * Codifica el mensaje Pushname. No implícitamente mensajes {@link proto.Pushname.verify|verify}.
         * @param message Pushname mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IPushname, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Pushname message, delimitado por longitud. No implícitamente mensajes {@link proto.Pushname.verify|verify}.
         * @param message Pushname mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IPushname, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Pushname message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Pushname
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Pushname;

        /**
         * Decodes a Pushname message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Pushname
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Pushname;

        /**
         * Verifies a Pushname message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Pushname message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Pushname
         */
        public static fromObject(object: { [k: string]: any }): proto.Pushname;

        /**
         * Crea un objeto simple desde Pushname. También convierte valores a otros tipos si se especifica.
         * @param message Pushname
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Pushname, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Pushname a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un Reaction. */
    interface IReaction {

        /** Reaction key */
        key?: (proto.IMessageKey|null);

        /** Reaction text */
        text?: (string|null);

        /** Reaction groupingKey */
        groupingKey?: (string|null);

        /** Reaction senderTimestampMs */
        senderTimestampMs?: (number|Long|null);

        /** Reaction unread */
        unread?: (boolean|null);
    }

    /** Representa un Reaction. */
    class Reaction implements IReaction {

        /**
         * Construya un nuevo Reaction.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IReaction);

        /** Reaction key. */
        public key?: (proto.IMessageKey|null);

        /** Reaction text. */
        public text: string;

        /** Reaction groupingKey. */
        public groupingKey: string;

        /** Reaction senderTimestampMs. */
        public senderTimestampMs: (number|Long);

        /** Reaction unread. */
        public unread: boolean;

        /**
         * Crea una nueva instancia Reaction utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns Reaction instance
         */
        public static create(properties?: proto.IReaction): proto.Reaction;

        /**
         * Codifica el mensaje Reaction. No implícitamente mensajes {@link proto.Reaction.verify|verify}.
         * @param message Reaction mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IReaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje Reaction message, delimitado por longitud. No implícitamente mensajes {@link proto.Reaction.verify|verify}.
         * @param message Reaction mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IReaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Reaction message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns Reaction
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Reaction;

        /**
         * Decodes a Reaction message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns Reaction
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Reaction;

        /**
         * Verifies a Reaction message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Reaction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns Reaction
         */
        public static fromObject(object: { [k: string]: any }): proto.Reaction;

        /**
         * Crea un objeto simple desde Reaction. También convierte valores a otros tipos si se especifica.
         * @param message Reaction
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.Reaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  Reaction a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un RecentEmojiWeight. */
    interface IRecentEmojiWeight {

        /** RecentEmojiWeight emoji */
        emoji?: (string|null);

        /** RecentEmojiWeight weight */
        weight?: (number|null);
    }

    /** Representa un RecentEmojiWeight. */
    class RecentEmojiWeight implements IRecentEmojiWeight {

        /**
         * Construya un nuevo RecentEmojiWeight.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IRecentEmojiWeight);

        /** RecentEmojiWeight emoji. */
        public emoji: string;

        /** RecentEmojiWeight weight. */
        public weight: number;

        /**
         * Crea una nueva instancia RecentEmojiWeight utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns RecentEmojiWeight instance
         */
        public static create(properties?: proto.IRecentEmojiWeight): proto.RecentEmojiWeight;

        /**
         * Codifica el mensaje RecentEmojiWeight. No implícitamente mensajes {@link proto.RecentEmojiWeight.verify|verify}.
         * @param message RecentEmojiWeight mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IRecentEmojiWeight, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje RecentEmojiWeight message, delimitado por longitud. No implícitamente mensajes {@link proto.RecentEmojiWeight.verify|verify}.
         * @param message RecentEmojiWeight mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IRecentEmojiWeight, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a RecentEmojiWeight message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns RecentEmojiWeight
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.RecentEmojiWeight;

        /**
         * Decodes a RecentEmojiWeight message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns RecentEmojiWeight
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.RecentEmojiWeight;

        /**
         * Verifies a RecentEmojiWeight message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a RecentEmojiWeight message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns RecentEmojiWeight
         */
        public static fromObject(object: { [k: string]: any }): proto.RecentEmojiWeight;

        /**
         * Crea un objeto simple desde RecentEmojiWeight. También convierte valores a otros tipos si se especifica.
         * @param message RecentEmojiWeight
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.RecentEmojiWeight, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  RecentEmojiWeight a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un RecordStructure. */
    interface IRecordStructure {

        /** RecordStructure currentSession */
        currentSession?: (proto.ISessionStructure|null);

        /** RecordStructure previousSessions */
        previousSessions?: (proto.ISessionStructure[]|null);
    }

    /** Representa un RecordStructure. */
    class RecordStructure implements IRecordStructure {

        /**
         * Construya un nuevo RecordStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IRecordStructure);

        /** RecordStructure currentSession. */
        public currentSession?: (proto.ISessionStructure|null);

        /** RecordStructure previousSessions. */
        public previousSessions: proto.ISessionStructure[];

        /**
         * Crea una nueva instancia RecordStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns RecordStructure instance
         */
        public static create(properties?: proto.IRecordStructure): proto.RecordStructure;

        /**
         * Codifica el mensaje RecordStructure. No implícitamente mensajes {@link proto.RecordStructure.verify|verify}.
         * @param message RecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje RecordStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.RecordStructure.verify|verify}.
         * @param message RecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a RecordStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns RecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.RecordStructure;

        /**
         * Decodes a RecordStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns RecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.RecordStructure;

        /**
         * Verifies a RecordStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a RecordStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns RecordStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.RecordStructure;

        /**
         * Crea un objeto simple desde RecordStructure. También convierte valores a otros tipos si se especifica.
         * @param message RecordStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.RecordStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  RecordStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SenderKeyRecordStructure. */
    interface ISenderKeyRecordStructure {

        /** SenderKeyRecordStructure senderKeyStates */
        senderKeyStates?: (proto.ISenderKeyStateStructure[]|null);
    }

    /** Representa un SenderKeyRecordStructure. */
    class SenderKeyRecordStructure implements ISenderKeyRecordStructure {

        /**
         * Construya un nuevo SenderKeyRecordStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISenderKeyRecordStructure);

        /** SenderKeyRecordStructure senderKeyStates. */
        public senderKeyStates: proto.ISenderKeyStateStructure[];

        /**
         * Crea una nueva instancia SenderKeyRecordStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SenderKeyRecordStructure instance
         */
        public static create(properties?: proto.ISenderKeyRecordStructure): proto.SenderKeyRecordStructure;

        /**
         * Codifica el mensaje SenderKeyRecordStructure. No implícitamente mensajes {@link proto.SenderKeyRecordStructure.verify|verify}.
         * @param message SenderKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISenderKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SenderKeyRecordStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.SenderKeyRecordStructure.verify|verify}.
         * @param message SenderKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISenderKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SenderKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SenderKeyRecordStructure;

        /**
         * Decodes a SenderKeyRecordStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SenderKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SenderKeyRecordStructure;

        /**
         * Verifies a SenderKeyRecordStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SenderKeyRecordStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SenderKeyRecordStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.SenderKeyRecordStructure;

        /**
         * Crea un objeto simple desde SenderKeyRecordStructure. También convierte valores a otros tipos si se especifica.
         * @param message SenderKeyRecordStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SenderKeyRecordStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SenderKeyRecordStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SenderKeyStateStructure. */
    interface ISenderKeyStateStructure {

        /** SenderKeyStateStructure senderKeyId */
        senderKeyId?: (number|null);

        /** SenderKeyStateStructure senderChainKey */
        senderChainKey?: (proto.SenderKeyStateStructure.ISenderChainKey|null);

        /** SenderKeyStateStructure senderSigningKey */
        senderSigningKey?: (proto.SenderKeyStateStructure.ISenderSigningKey|null);

        /** SenderKeyStateStructure senderMessageKeys */
        senderMessageKeys?: (proto.SenderKeyStateStructure.ISenderMessageKey[]|null);
    }

    /** Representa un SenderKeyStateStructure. */
    class SenderKeyStateStructure implements ISenderKeyStateStructure {

        /**
         * Construya un nuevo SenderKeyStateStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISenderKeyStateStructure);

        /** SenderKeyStateStructure senderKeyId. */
        public senderKeyId: number;

        /** SenderKeyStateStructure senderChainKey. */
        public senderChainKey?: (proto.SenderKeyStateStructure.ISenderChainKey|null);

        /** SenderKeyStateStructure senderSigningKey. */
        public senderSigningKey?: (proto.SenderKeyStateStructure.ISenderSigningKey|null);

        /** SenderKeyStateStructure senderMessageKeys. */
        public senderMessageKeys: proto.SenderKeyStateStructure.ISenderMessageKey[];

        /**
         * Crea una nueva instancia SenderKeyStateStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SenderKeyStateStructure instance
         */
        public static create(properties?: proto.ISenderKeyStateStructure): proto.SenderKeyStateStructure;

        /**
         * Codifica el mensaje SenderKeyStateStructure. No implícitamente mensajes {@link proto.SenderKeyStateStructure.verify|verify}.
         * @param message SenderKeyStateStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISenderKeyStateStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SenderKeyStateStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.SenderKeyStateStructure.verify|verify}.
         * @param message SenderKeyStateStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISenderKeyStateStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SenderKeyStateStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SenderKeyStateStructure;

        /**
         * Decodes a SenderKeyStateStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SenderKeyStateStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SenderKeyStateStructure;

        /**
         * Verifies a SenderKeyStateStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SenderKeyStateStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SenderKeyStateStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.SenderKeyStateStructure;

        /**
         * Crea un objeto simple desde SenderKeyStateStructure. También convierte valores a otros tipos si se especifica.
         * @param message SenderKeyStateStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SenderKeyStateStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SenderKeyStateStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace SenderKeyStateStructure {

        /** Propiedades de un SenderChainKey. */
        interface ISenderChainKey {

            /** SenderChainKey iteration */
            iteration?: (number|null);

            /** SenderChainKey seed */
            seed?: (Uint8Array|null);
        }

        /** Representa un SenderChainKey. */
        class SenderChainKey implements ISenderChainKey {

            /**
             * Construya un nuevo SenderChainKey.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SenderKeyStateStructure.ISenderChainKey);

            /** SenderChainKey iteration. */
            public iteration: number;

            /** SenderChainKey seed. */
            public seed: Uint8Array;

            /**
             * Crea una nueva instancia SenderChainKey utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SenderChainKey instance
             */
            public static create(properties?: proto.SenderKeyStateStructure.ISenderChainKey): proto.SenderKeyStateStructure.SenderChainKey;

            /**
             * Codifica el mensaje SenderChainKey. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderChainKey.verify|verify}.
             * @param message SenderChainKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SenderKeyStateStructure.ISenderChainKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SenderChainKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderChainKey.verify|verify}.
             * @param message SenderChainKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SenderKeyStateStructure.ISenderChainKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SenderChainKey message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SenderChainKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SenderKeyStateStructure.SenderChainKey;

            /**
             * Decodes a SenderChainKey message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SenderChainKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SenderKeyStateStructure.SenderChainKey;

            /**
             * Verifies a SenderChainKey message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SenderChainKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SenderChainKey
             */
            public static fromObject(object: { [k: string]: any }): proto.SenderKeyStateStructure.SenderChainKey;

            /**
             * Crea un objeto simple desde SenderChainKey. También convierte valores a otros tipos si se especifica.
             * @param message SenderChainKey
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SenderKeyStateStructure.SenderChainKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SenderChainKey a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SenderMessageKey. */
        interface ISenderMessageKey {

            /** SenderMessageKey iteration */
            iteration?: (number|null);

            /** SenderMessageKey seed */
            seed?: (Uint8Array|null);
        }

        /** Representa un SenderMessageKey. */
        class SenderMessageKey implements ISenderMessageKey {

            /**
             * Construya un nuevo SenderMessageKey.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SenderKeyStateStructure.ISenderMessageKey);

            /** SenderMessageKey iteration. */
            public iteration: number;

            /** SenderMessageKey seed. */
            public seed: Uint8Array;

            /**
             * Crea una nueva instancia SenderMessageKey utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SenderMessageKey instance
             */
            public static create(properties?: proto.SenderKeyStateStructure.ISenderMessageKey): proto.SenderKeyStateStructure.SenderMessageKey;

            /**
             * Codifica el mensaje SenderMessageKey. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderMessageKey.verify|verify}.
             * @param message SenderMessageKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SenderKeyStateStructure.ISenderMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SenderMessageKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderMessageKey.verify|verify}.
             * @param message SenderMessageKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SenderKeyStateStructure.ISenderMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SenderMessageKey message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SenderMessageKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SenderKeyStateStructure.SenderMessageKey;

            /**
             * Decodes a SenderMessageKey message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SenderMessageKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SenderKeyStateStructure.SenderMessageKey;

            /**
             * Verifies a SenderMessageKey message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SenderMessageKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SenderMessageKey
             */
            public static fromObject(object: { [k: string]: any }): proto.SenderKeyStateStructure.SenderMessageKey;

            /**
             * Crea un objeto simple desde SenderMessageKey. También convierte valores a otros tipos si se especifica.
             * @param message SenderMessageKey
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SenderKeyStateStructure.SenderMessageKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SenderMessageKey a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SenderSigningKey. */
        interface ISenderSigningKey {

            /** SenderSigningKey public */
            "public"?: (Uint8Array|null);

            /** SenderSigningKey private */
            "private"?: (Uint8Array|null);
        }

        /** Representa un SenderSigningKey. */
        class SenderSigningKey implements ISenderSigningKey {

            /**
             * Construya un nuevo SenderSigningKey.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SenderKeyStateStructure.ISenderSigningKey);

            /** SenderSigningKey public. */
            public public: Uint8Array;

            /** SenderSigningKey private. */
            public private: Uint8Array;

            /**
             * Crea una nueva instancia SenderSigningKey utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SenderSigningKey instance
             */
            public static create(properties?: proto.SenderKeyStateStructure.ISenderSigningKey): proto.SenderKeyStateStructure.SenderSigningKey;

            /**
             * Codifica el mensaje SenderSigningKey. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderSigningKey.verify|verify}.
             * @param message SenderSigningKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SenderKeyStateStructure.ISenderSigningKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SenderSigningKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SenderKeyStateStructure.SenderSigningKey.verify|verify}.
             * @param message SenderSigningKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SenderKeyStateStructure.ISenderSigningKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SenderSigningKey message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SenderSigningKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SenderKeyStateStructure.SenderSigningKey;

            /**
             * Decodes a SenderSigningKey message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SenderSigningKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SenderKeyStateStructure.SenderSigningKey;

            /**
             * Verifies a SenderSigningKey message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SenderSigningKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SenderSigningKey
             */
            public static fromObject(object: { [k: string]: any }): proto.SenderKeyStateStructure.SenderSigningKey;

            /**
             * Crea un objeto simple desde SenderSigningKey. También convierte valores a otros tipos si se especifica.
             * @param message SenderSigningKey
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SenderKeyStateStructure.SenderSigningKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SenderSigningKey a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un ServerErrorReceipt. */
    interface IServerErrorReceipt {

        /** ServerErrorReceipt stanzaId */
        stanzaId?: (string|null);
    }

    /** Representa un ServerErrorReceipt. */
    class ServerErrorReceipt implements IServerErrorReceipt {

        /**
         * Construya un nuevo ServerErrorReceipt.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IServerErrorReceipt);

        /** ServerErrorReceipt stanzaId. */
        public stanzaId: string;

        /**
         * Crea una nueva instancia ServerErrorReceipt utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns ServerErrorReceipt instance
         */
        public static create(properties?: proto.IServerErrorReceipt): proto.ServerErrorReceipt;

        /**
         * Codifica el mensaje ServerErrorReceipt. No implícitamente mensajes {@link proto.ServerErrorReceipt.verify|verify}.
         * @param message ServerErrorReceipt mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IServerErrorReceipt, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje ServerErrorReceipt message, delimitado por longitud. No implícitamente mensajes {@link proto.ServerErrorReceipt.verify|verify}.
         * @param message ServerErrorReceipt mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IServerErrorReceipt, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ServerErrorReceipt message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns ServerErrorReceipt
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ServerErrorReceipt;

        /**
         * Decodes a ServerErrorReceipt message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns ServerErrorReceipt
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ServerErrorReceipt;

        /**
         * Verifies a ServerErrorReceipt message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ServerErrorReceipt message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns ServerErrorReceipt
         */
        public static fromObject(object: { [k: string]: any }): proto.ServerErrorReceipt;

        /**
         * Crea un objeto simple desde ServerErrorReceipt. También convierte valores a otros tipos si se especifica.
         * @param message ServerErrorReceipt
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.ServerErrorReceipt, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  ServerErrorReceipt a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SessionStructure. */
    interface ISessionStructure {

        /** SessionStructure sessionVersion */
        sessionVersion?: (number|null);

        /** SessionStructure localIdentityPublic */
        localIdentityPublic?: (Uint8Array|null);

        /** SessionStructure remoteIdentityPublic */
        remoteIdentityPublic?: (Uint8Array|null);

        /** SessionStructure rootKey */
        rootKey?: (Uint8Array|null);

        /** SessionStructure previousCounter */
        previousCounter?: (number|null);

        /** SessionStructure senderChain */
        senderChain?: (proto.SessionStructure.IChain|null);

        /** SessionStructure receiverChains */
        receiverChains?: (proto.SessionStructure.IChain[]|null);

        /** SessionStructure pendingKeyExchange */
        pendingKeyExchange?: (proto.SessionStructure.IPendingKeyExchange|null);

        /** SessionStructure pendingPreKey */
        pendingPreKey?: (proto.SessionStructure.IPendingPreKey|null);

        /** SessionStructure remoteRegistrationId */
        remoteRegistrationId?: (number|null);

        /** SessionStructure localRegistrationId */
        localRegistrationId?: (number|null);

        /** SessionStructure needsRefresh */
        needsRefresh?: (boolean|null);

        /** SessionStructure aliceBaseKey */
        aliceBaseKey?: (Uint8Array|null);
    }

    /** Representa un SessionStructure. */
    class SessionStructure implements ISessionStructure {

        /**
         * Construya un nuevo SessionStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISessionStructure);

        /** SessionStructure sessionVersion. */
        public sessionVersion: number;

        /** SessionStructure localIdentityPublic. */
        public localIdentityPublic: Uint8Array;

        /** SessionStructure remoteIdentityPublic. */
        public remoteIdentityPublic: Uint8Array;

        /** SessionStructure rootKey. */
        public rootKey: Uint8Array;

        /** SessionStructure previousCounter. */
        public previousCounter: number;

        /** SessionStructure senderChain. */
        public senderChain?: (proto.SessionStructure.IChain|null);

        /** SessionStructure receiverChains. */
        public receiverChains: proto.SessionStructure.IChain[];

        /** SessionStructure pendingKeyExchange. */
        public pendingKeyExchange?: (proto.SessionStructure.IPendingKeyExchange|null);

        /** SessionStructure pendingPreKey. */
        public pendingPreKey?: (proto.SessionStructure.IPendingPreKey|null);

        /** SessionStructure remoteRegistrationId. */
        public remoteRegistrationId: number;

        /** SessionStructure localRegistrationId. */
        public localRegistrationId: number;

        /** SessionStructure needsRefresh. */
        public needsRefresh: boolean;

        /** SessionStructure aliceBaseKey. */
        public aliceBaseKey: Uint8Array;

        /**
         * Crea una nueva instancia SessionStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SessionStructure instance
         */
        public static create(properties?: proto.ISessionStructure): proto.SessionStructure;

        /**
         * Codifica el mensaje SessionStructure. No implícitamente mensajes {@link proto.SessionStructure.verify|verify}.
         * @param message SessionStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISessionStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SessionStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.verify|verify}.
         * @param message SessionStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISessionStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SessionStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SessionStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure;

        /**
         * Decodes a SessionStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SessionStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure;

        /**
         * Verifies a SessionStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SessionStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SessionStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.SessionStructure;

        /**
         * Crea un objeto simple desde SessionStructure. También convierte valores a otros tipos si se especifica.
         * @param message SessionStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SessionStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SessionStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace SessionStructure {

        /** Propiedades de un Chain. */
        interface IChain {

            /** Chain senderRatchetKey */
            senderRatchetKey?: (Uint8Array|null);

            /** Chain senderRatchetKeyPrivate */
            senderRatchetKeyPrivate?: (Uint8Array|null);

            /** Chain chainKey */
            chainKey?: (proto.SessionStructure.Chain.IChainKey|null);

            /** Chain messageKeys */
            messageKeys?: (proto.SessionStructure.Chain.IMessageKey[]|null);
        }

        /** Representa un Chain. */
        class Chain implements IChain {

            /**
             * Construya un nuevo Chain.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SessionStructure.IChain);

            /** Chain senderRatchetKey. */
            public senderRatchetKey: Uint8Array;

            /** Chain senderRatchetKeyPrivate. */
            public senderRatchetKeyPrivate: Uint8Array;

            /** Chain chainKey. */
            public chainKey?: (proto.SessionStructure.Chain.IChainKey|null);

            /** Chain messageKeys. */
            public messageKeys: proto.SessionStructure.Chain.IMessageKey[];

            /**
             * Crea una nueva instancia Chain utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns Chain instance
             */
            public static create(properties?: proto.SessionStructure.IChain): proto.SessionStructure.Chain;

            /**
             * Codifica el mensaje Chain. No implícitamente mensajes {@link proto.SessionStructure.Chain.verify|verify}.
             * @param message Chain mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SessionStructure.IChain, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje Chain message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.Chain.verify|verify}.
             * @param message Chain mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SessionStructure.IChain, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Chain message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns Chain
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure.Chain;

            /**
             * Decodes a Chain message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns Chain
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure.Chain;

            /**
             * Verifies a Chain message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Chain message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns Chain
             */
            public static fromObject(object: { [k: string]: any }): proto.SessionStructure.Chain;

            /**
             * Crea un objeto simple desde Chain. También convierte valores a otros tipos si se especifica.
             * @param message Chain
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SessionStructure.Chain, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  Chain a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Chain {

            /** Propiedades de un ChainKey. */
            interface IChainKey {

                /** ChainKey index */
                index?: (number|null);

                /** ChainKey key */
                key?: (Uint8Array|null);
            }

            /** Representa un ChainKey. */
            class ChainKey implements IChainKey {

                /**
                 * Construya un nuevo ChainKey.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.SessionStructure.Chain.IChainKey);

                /** ChainKey index. */
                public index: number;

                /** ChainKey key. */
                public key: Uint8Array;

                /**
                 * Crea una nueva instancia ChainKey utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns ChainKey instance
                 */
                public static create(properties?: proto.SessionStructure.Chain.IChainKey): proto.SessionStructure.Chain.ChainKey;

                /**
                 * Codifica el mensaje ChainKey. No implícitamente mensajes {@link proto.SessionStructure.Chain.ChainKey.verify|verify}.
                 * @param message ChainKey mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.SessionStructure.Chain.IChainKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje ChainKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.Chain.ChainKey.verify|verify}.
                 * @param message ChainKey mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.SessionStructure.Chain.IChainKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ChainKey message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns ChainKey
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure.Chain.ChainKey;

                /**
                 * Decodes a ChainKey message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns ChainKey
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure.Chain.ChainKey;

                /**
                 * Verifies a ChainKey message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ChainKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns ChainKey
                 */
                public static fromObject(object: { [k: string]: any }): proto.SessionStructure.Chain.ChainKey;

                /**
                 * Crea un objeto simple desde ChainKey. También convierte valores a otros tipos si se especifica.
                 * @param message ChainKey
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.SessionStructure.Chain.ChainKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  ChainKey a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Propiedades de un MessageKey. */
            interface IMessageKey {

                /** MessageKey index */
                index?: (number|null);

                /** MessageKey cipherKey */
                cipherKey?: (Uint8Array|null);

                /** MessageKey macKey */
                macKey?: (Uint8Array|null);

                /** MessageKey iv */
                iv?: (Uint8Array|null);
            }

            /** Representa un MessageKey. */
            class MessageKey implements IMessageKey {

                /**
                 * Construya un nuevo MessageKey.
                 * @param [properties] para establecer propiedades
                 */
                constructor(properties?: proto.SessionStructure.Chain.IMessageKey);

                /** MessageKey index. */
                public index: number;

                /** MessageKey cipherKey. */
                public cipherKey: Uint8Array;

                /** MessageKey macKey. */
                public macKey: Uint8Array;

                /** MessageKey iv. */
                public iv: Uint8Array;

                /**
                 * Crea una nueva instancia MessageKey utilizando las propiedades especificadas.
                 * @param [properties] para establecer propiedades
                 * @returns MessageKey instance
                 */
                public static create(properties?: proto.SessionStructure.Chain.IMessageKey): proto.SessionStructure.Chain.MessageKey;

                /**
                 * Codifica el mensaje MessageKey. No implícitamente mensajes {@link proto.SessionStructure.Chain.MessageKey.verify|verify}.
                 * @param message MessageKey mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encode(message: proto.SessionStructure.Chain.IMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Codifica el mensaje MessageKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.Chain.MessageKey.verify|verify}.
                 * @param message MessageKey mensaje o objeto simple para codificar
                 * @param [writer] Writer para codificar a
                 * @returns Writer
                 */
                public static encodeDelimited(message: proto.SessionStructure.Chain.IMessageKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageKey message from the specified reader or buffer.
                 * @param reader Reader o búfer para decodificar desde
                 * @param [length] Longitud del mensaje si se conoce de antemano
                 * @returns MessageKey
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure.Chain.MessageKey;

                /**
                 * Decodes a MessageKey message desde el especifico lector o búfer, longitud delimitada.
                 * @param reader Reader o búfer para decodificar desde
                 * @returns MessageKey
                 * @throws {Error} Si la carga útil no es un lector o un búfer válido
                 * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure.Chain.MessageKey;

                /**
                 * Verifies a MessageKey message.
                 * @param message Objeto simple para verificar
                 * @returns `null` Si es válido, de lo contrario la razón por la que no es
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
                 * @param object Objeto simple
                 * @returns MessageKey
                 */
                public static fromObject(object: { [k: string]: any }): proto.SessionStructure.Chain.MessageKey;

                /**
                 * Crea un objeto simple desde MessageKey. También convierte valores a otros tipos si se especifica.
                 * @param message MessageKey
                 * @param [options] Opciones de conversión
                 * @returns Objeto simple
                 */
                public static toObject(message: proto.SessionStructure.Chain.MessageKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Convierte este  MessageKey a JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /** Propiedades de un PendingKeyExchange. */
        interface IPendingKeyExchange {

            /** PendingKeyExchange sequence */
            sequence?: (number|null);

            /** PendingKeyExchange localBaseKey */
            localBaseKey?: (Uint8Array|null);

            /** PendingKeyExchange localBaseKeyPrivate */
            localBaseKeyPrivate?: (Uint8Array|null);

            /** PendingKeyExchange localRatchetKey */
            localRatchetKey?: (Uint8Array|null);

            /** PendingKeyExchange localRatchetKeyPrivate */
            localRatchetKeyPrivate?: (Uint8Array|null);

            /** PendingKeyExchange localIdentityKey */
            localIdentityKey?: (Uint8Array|null);

            /** PendingKeyExchange localIdentityKeyPrivate */
            localIdentityKeyPrivate?: (Uint8Array|null);
        }

        /** Representa un PendingKeyExchange. */
        class PendingKeyExchange implements IPendingKeyExchange {

            /**
             * Construya un nuevo PendingKeyExchange.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SessionStructure.IPendingKeyExchange);

            /** PendingKeyExchange sequence. */
            public sequence: number;

            /** PendingKeyExchange localBaseKey. */
            public localBaseKey: Uint8Array;

            /** PendingKeyExchange localBaseKeyPrivate. */
            public localBaseKeyPrivate: Uint8Array;

            /** PendingKeyExchange localRatchetKey. */
            public localRatchetKey: Uint8Array;

            /** PendingKeyExchange localRatchetKeyPrivate. */
            public localRatchetKeyPrivate: Uint8Array;

            /** PendingKeyExchange localIdentityKey. */
            public localIdentityKey: Uint8Array;

            /** PendingKeyExchange localIdentityKeyPrivate. */
            public localIdentityKeyPrivate: Uint8Array;

            /**
             * Crea una nueva instancia PendingKeyExchange utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PendingKeyExchange instance
             */
            public static create(properties?: proto.SessionStructure.IPendingKeyExchange): proto.SessionStructure.PendingKeyExchange;

            /**
             * Codifica el mensaje PendingKeyExchange. No implícitamente mensajes {@link proto.SessionStructure.PendingKeyExchange.verify|verify}.
             * @param message PendingKeyExchange mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SessionStructure.IPendingKeyExchange, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PendingKeyExchange message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.PendingKeyExchange.verify|verify}.
             * @param message PendingKeyExchange mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SessionStructure.IPendingKeyExchange, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PendingKeyExchange message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PendingKeyExchange
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure.PendingKeyExchange;

            /**
             * Decodes a PendingKeyExchange message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PendingKeyExchange
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure.PendingKeyExchange;

            /**
             * Verifies a PendingKeyExchange message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PendingKeyExchange message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PendingKeyExchange
             */
            public static fromObject(object: { [k: string]: any }): proto.SessionStructure.PendingKeyExchange;

            /**
             * Crea un objeto simple desde PendingKeyExchange. También convierte valores a otros tipos si se especifica.
             * @param message PendingKeyExchange
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SessionStructure.PendingKeyExchange, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PendingKeyExchange a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PendingPreKey. */
        interface IPendingPreKey {

            /** PendingPreKey preKeyId */
            preKeyId?: (number|null);

            /** PendingPreKey signedPreKeyId */
            signedPreKeyId?: (number|null);

            /** PendingPreKey baseKey */
            baseKey?: (Uint8Array|null);
        }

        /** Representa un PendingPreKey. */
        class PendingPreKey implements IPendingPreKey {

            /**
             * Construya un nuevo PendingPreKey.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SessionStructure.IPendingPreKey);

            /** PendingPreKey preKeyId. */
            public preKeyId: number;

            /** PendingPreKey signedPreKeyId. */
            public signedPreKeyId: number;

            /** PendingPreKey baseKey. */
            public baseKey: Uint8Array;

            /**
             * Crea una nueva instancia PendingPreKey utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PendingPreKey instance
             */
            public static create(properties?: proto.SessionStructure.IPendingPreKey): proto.SessionStructure.PendingPreKey;

            /**
             * Codifica el mensaje PendingPreKey. No implícitamente mensajes {@link proto.SessionStructure.PendingPreKey.verify|verify}.
             * @param message PendingPreKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SessionStructure.IPendingPreKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PendingPreKey message, delimitado por longitud. No implícitamente mensajes {@link proto.SessionStructure.PendingPreKey.verify|verify}.
             * @param message PendingPreKey mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SessionStructure.IPendingPreKey, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PendingPreKey message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PendingPreKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SessionStructure.PendingPreKey;

            /**
             * Decodes a PendingPreKey message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PendingPreKey
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SessionStructure.PendingPreKey;

            /**
             * Verifies a PendingPreKey message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PendingPreKey message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PendingPreKey
             */
            public static fromObject(object: { [k: string]: any }): proto.SessionStructure.PendingPreKey;

            /**
             * Crea un objeto simple desde PendingPreKey. También convierte valores a otros tipos si se especifica.
             * @param message PendingPreKey
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SessionStructure.PendingPreKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PendingPreKey a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un SignedPreKeyRecordStructure. */
    interface ISignedPreKeyRecordStructure {

        /** SignedPreKeyRecordStructure id */
        id?: (number|null);

        /** SignedPreKeyRecordStructure publicKey */
        publicKey?: (Uint8Array|null);

        /** SignedPreKeyRecordStructure privateKey */
        privateKey?: (Uint8Array|null);

        /** SignedPreKeyRecordStructure signature */
        signature?: (Uint8Array|null);

        /** SignedPreKeyRecordStructure timestamp */
        timestamp?: (number|Long|null);
    }

    /** Representa un SignedPreKeyRecordStructure. */
    class SignedPreKeyRecordStructure implements ISignedPreKeyRecordStructure {

        /**
         * Construya un nuevo SignedPreKeyRecordStructure.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISignedPreKeyRecordStructure);

        /** SignedPreKeyRecordStructure id. */
        public id: number;

        /** SignedPreKeyRecordStructure publicKey. */
        public publicKey: Uint8Array;

        /** SignedPreKeyRecordStructure privateKey. */
        public privateKey: Uint8Array;

        /** SignedPreKeyRecordStructure signature. */
        public signature: Uint8Array;

        /** SignedPreKeyRecordStructure timestamp. */
        public timestamp: (number|Long);

        /**
         * Crea una nueva instancia SignedPreKeyRecordStructure utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SignedPreKeyRecordStructure instance
         */
        public static create(properties?: proto.ISignedPreKeyRecordStructure): proto.SignedPreKeyRecordStructure;

        /**
         * Codifica el mensaje SignedPreKeyRecordStructure. No implícitamente mensajes {@link proto.SignedPreKeyRecordStructure.verify|verify}.
         * @param message SignedPreKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISignedPreKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SignedPreKeyRecordStructure message, delimitado por longitud. No implícitamente mensajes {@link proto.SignedPreKeyRecordStructure.verify|verify}.
         * @param message SignedPreKeyRecordStructure mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignedPreKeyRecordStructure, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SignedPreKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SignedPreKeyRecordStructure;

        /**
         * Decodes a SignedPreKeyRecordStructure message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SignedPreKeyRecordStructure
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SignedPreKeyRecordStructure;

        /**
         * Verifies a SignedPreKeyRecordStructure message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SignedPreKeyRecordStructure message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SignedPreKeyRecordStructure
         */
        public static fromObject(object: { [k: string]: any }): proto.SignedPreKeyRecordStructure;

        /**
         * Crea un objeto simple desde SignedPreKeyRecordStructure. También convierte valores a otros tipos si se especifica.
         * @param message SignedPreKeyRecordStructure
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SignedPreKeyRecordStructure, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SignedPreKeyRecordStructure a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un StatusPSA. */
    interface IStatusPSA {

        /** StatusPSA campaignId */
        campaignId: (number|Long);

        /** StatusPSA campaignExpirationTimestamp */
        campaignExpirationTimestamp?: (number|Long|null);
    }

    /** Representa un StatusPSA. */
    class StatusPSA implements IStatusPSA {

        /**
         * Construya un nuevo StatusPSA.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IStatusPSA);

        /** StatusPSA campaignId. */
        public campaignId: (number|Long);

        /** StatusPSA campaignExpirationTimestamp. */
        public campaignExpirationTimestamp: (number|Long);

        /**
         * Crea una nueva instancia StatusPSA utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns StatusPSA instance
         */
        public static create(properties?: proto.IStatusPSA): proto.StatusPSA;

        /**
         * Codifica el mensaje StatusPSA. No implícitamente mensajes {@link proto.StatusPSA.verify|verify}.
         * @param message StatusPSA mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IStatusPSA, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje StatusPSA message, delimitado por longitud. No implícitamente mensajes {@link proto.StatusPSA.verify|verify}.
         * @param message StatusPSA mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IStatusPSA, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a StatusPSA message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns StatusPSA
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.StatusPSA;

        /**
         * Decodes a StatusPSA message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns StatusPSA
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.StatusPSA;

        /**
         * Verifies a StatusPSA message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a StatusPSA message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns StatusPSA
         */
        public static fromObject(object: { [k: string]: any }): proto.StatusPSA;

        /**
         * Crea un objeto simple desde StatusPSA. También convierte valores a otros tipos si se especifica.
         * @param message StatusPSA
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.StatusPSA, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  StatusPSA a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un StickerMetadata. */
    interface IStickerMetadata {

        /** StickerMetadata url */
        url?: (string|null);

        /** StickerMetadata fileSha256 */
        fileSha256?: (Uint8Array|null);

        /** StickerMetadata fileEncSha256 */
        fileEncSha256?: (Uint8Array|null);

        /** StickerMetadata mediaKey */
        mediaKey?: (Uint8Array|null);

        /** StickerMetadata mimetype */
        mimetype?: (string|null);

        /** StickerMetadata height */
        height?: (number|null);

        /** StickerMetadata width */
        width?: (number|null);

        /** StickerMetadata directPath */
        directPath?: (string|null);

        /** StickerMetadata fileLength */
        fileLength?: (number|Long|null);

        /** StickerMetadata weight */
        weight?: (number|null);

        /** StickerMetadata lastStickerSentTs */
        lastStickerSentTs?: (number|Long|null);
    }

    /** Representa un StickerMetadata. */
    class StickerMetadata implements IStickerMetadata {

        /**
         * Construya un nuevo StickerMetadata.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IStickerMetadata);

        /** StickerMetadata url. */
        public url: string;

        /** StickerMetadata fileSha256. */
        public fileSha256: Uint8Array;

        /** StickerMetadata fileEncSha256. */
        public fileEncSha256: Uint8Array;

        /** StickerMetadata mediaKey. */
        public mediaKey: Uint8Array;

        /** StickerMetadata mimetype. */
        public mimetype: string;

        /** StickerMetadata height. */
        public height: number;

        /** StickerMetadata width. */
        public width: number;

        /** StickerMetadata directPath. */
        public directPath: string;

        /** StickerMetadata fileLength. */
        public fileLength: (number|Long);

        /** StickerMetadata weight. */
        public weight: number;

        /** StickerMetadata lastStickerSentTs. */
        public lastStickerSentTs: (number|Long);

        /**
         * Crea una nueva instancia StickerMetadata utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns StickerMetadata instance
         */
        public static create(properties?: proto.IStickerMetadata): proto.StickerMetadata;

        /**
         * Codifica el mensaje StickerMetadata. No implícitamente mensajes {@link proto.StickerMetadata.verify|verify}.
         * @param message StickerMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IStickerMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje StickerMetadata message, delimitado por longitud. No implícitamente mensajes {@link proto.StickerMetadata.verify|verify}.
         * @param message StickerMetadata mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IStickerMetadata, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a StickerMetadata message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns StickerMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.StickerMetadata;

        /**
         * Decodes a StickerMetadata message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns StickerMetadata
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.StickerMetadata;

        /**
         * Verifies a StickerMetadata message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a StickerMetadata message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns StickerMetadata
         */
        public static fromObject(object: { [k: string]: any }): proto.StickerMetadata;

        /**
         * Crea un objeto simple desde StickerMetadata. También convierte valores a otros tipos si se especifica.
         * @param message StickerMetadata
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.StickerMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  StickerMetadata a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncActionData. */
    interface ISyncActionData {

        /** SyncActionData index */
        index?: (Uint8Array|null);

        /** SyncActionData value */
        value?: (proto.ISyncActionValue|null);

        /** SyncActionData padding */
        padding?: (Uint8Array|null);

        /** SyncActionData version */
        version?: (number|null);
    }

    /** Representa un SyncActionData. */
    class SyncActionData implements ISyncActionData {

        /**
         * Construya un nuevo SyncActionData.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncActionData);

        /** SyncActionData index. */
        public index: Uint8Array;

        /** SyncActionData value. */
        public value?: (proto.ISyncActionValue|null);

        /** SyncActionData padding. */
        public padding: Uint8Array;

        /** SyncActionData version. */
        public version: number;

        /**
         * Crea una nueva instancia SyncActionData utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncActionData instance
         */
        public static create(properties?: proto.ISyncActionData): proto.SyncActionData;

        /**
         * Codifica el mensaje SyncActionData. No implícitamente mensajes {@link proto.SyncActionData.verify|verify}.
         * @param message SyncActionData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncActionData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncActionData message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionData.verify|verify}.
         * @param message SyncActionData mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncActionData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncActionData message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncActionData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionData;

        /**
         * Decodes a SyncActionData message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncActionData
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionData;

        /**
         * Verifies a SyncActionData message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncActionData message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncActionData
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncActionData;

        /**
         * Crea un objeto simple desde SyncActionData. También convierte valores a otros tipos si se especifica.
         * @param message SyncActionData
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncActionData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncActionData a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncActionValue. */
    interface ISyncActionValue {

        /** SyncActionValue timestamp */
        timestamp?: (number|Long|null);

        /** SyncActionValue starAction */
        starAction?: (proto.SyncActionValue.IStarAction|null);

        /** SyncActionValue contactAction */
        contactAction?: (proto.SyncActionValue.IContactAction|null);

        /** SyncActionValue muteAction */
        muteAction?: (proto.SyncActionValue.IMuteAction|null);

        /** SyncActionValue pinAction */
        pinAction?: (proto.SyncActionValue.IPinAction|null);

        /** SyncActionValue securityNotificationSetting */
        securityNotificationSetting?: (proto.SyncActionValue.ISecurityNotificationSetting|null);

        /** SyncActionValue pushNameSetting */
        pushNameSetting?: (proto.SyncActionValue.IPushNameSetting|null);

        /** SyncActionValue quickReplyAction */
        quickReplyAction?: (proto.SyncActionValue.IQuickReplyAction|null);

        /** SyncActionValue recentEmojiWeightsAction */
        recentEmojiWeightsAction?: (proto.SyncActionValue.IRecentEmojiWeightsAction|null);

        /** SyncActionValue labelEditAction */
        labelEditAction?: (proto.SyncActionValue.ILabelEditAction|null);

        /** SyncActionValue labelAssociationAction */
        labelAssociationAction?: (proto.SyncActionValue.ILabelAssociationAction|null);

        /** SyncActionValue localeSetting */
        localeSetting?: (proto.SyncActionValue.ILocaleSetting|null);

        /** SyncActionValue archiveChatAction */
        archiveChatAction?: (proto.SyncActionValue.IArchiveChatAction|null);

        /** SyncActionValue deleteMessageForMeAction */
        deleteMessageForMeAction?: (proto.SyncActionValue.IDeleteMessageForMeAction|null);

        /** SyncActionValue keyExpiration */
        keyExpiration?: (proto.SyncActionValue.IKeyExpiration|null);

        /** SyncActionValue markChatAsReadAction */
        markChatAsReadAction?: (proto.SyncActionValue.IMarkChatAsReadAction|null);

        /** SyncActionValue clearChatAction */
        clearChatAction?: (proto.SyncActionValue.IClearChatAction|null);

        /** SyncActionValue deleteChatAction */
        deleteChatAction?: (proto.SyncActionValue.IDeleteChatAction|null);

        /** SyncActionValue unarchiveChatsSetting */
        unarchiveChatsSetting?: (proto.SyncActionValue.IUnarchiveChatsSetting|null);

        /** SyncActionValue primaryFeature */
        primaryFeature?: (proto.SyncActionValue.IPrimaryFeature|null);

        /** SyncActionValue androidUnsupportedActions */
        androidUnsupportedActions?: (proto.SyncActionValue.IAndroidUnsupportedActions|null);

        /** SyncActionValue agentAction */
        agentAction?: (proto.SyncActionValue.IAgentAction|null);

        /** SyncActionValue subscriptionAction */
        subscriptionAction?: (proto.SyncActionValue.ISubscriptionAction|null);

        /** SyncActionValue userStatusMuteAction */
        userStatusMuteAction?: (proto.SyncActionValue.IUserStatusMuteAction|null);

        /** SyncActionValue timeFormatAction */
        timeFormatAction?: (proto.SyncActionValue.ITimeFormatAction|null);

        /** SyncActionValue nuxAction */
        nuxAction?: (proto.SyncActionValue.INuxAction|null);

        /** SyncActionValue primaryVersionAction */
        primaryVersionAction?: (proto.SyncActionValue.IPrimaryVersionAction|null);

        /** SyncActionValue stickerAction */
        stickerAction?: (proto.SyncActionValue.IStickerAction|null);

        /** SyncActionValue removeRecentStickerAction */
        removeRecentStickerAction?: (proto.SyncActionValue.IRemoveRecentStickerAction|null);

        /** SyncActionValue chatAssignment */
        chatAssignment?: (proto.SyncActionValue.IChatAssignmentAction|null);

        /** SyncActionValue chatAssignmentOpenedStatus */
        chatAssignmentOpenedStatus?: (proto.SyncActionValue.IChatAssignmentOpenedStatusAction|null);

        /** SyncActionValue pnForLidChatAction */
        pnForLidChatAction?: (proto.SyncActionValue.IPnForLidChatAction|null);
    }

    /** Representa un SyncActionValue. */
    class SyncActionValue implements ISyncActionValue {

        /**
         * Construya un nuevo SyncActionValue.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncActionValue);

        /** SyncActionValue timestamp. */
        public timestamp: (number|Long);

        /** SyncActionValue starAction. */
        public starAction?: (proto.SyncActionValue.IStarAction|null);

        /** SyncActionValue contactAction. */
        public contactAction?: (proto.SyncActionValue.IContactAction|null);

        /** SyncActionValue muteAction. */
        public muteAction?: (proto.SyncActionValue.IMuteAction|null);

        /** SyncActionValue pinAction. */
        public pinAction?: (proto.SyncActionValue.IPinAction|null);

        /** SyncActionValue securityNotificationSetting. */
        public securityNotificationSetting?: (proto.SyncActionValue.ISecurityNotificationSetting|null);

        /** SyncActionValue pushNameSetting. */
        public pushNameSetting?: (proto.SyncActionValue.IPushNameSetting|null);

        /** SyncActionValue quickReplyAction. */
        public quickReplyAction?: (proto.SyncActionValue.IQuickReplyAction|null);

        /** SyncActionValue recentEmojiWeightsAction. */
        public recentEmojiWeightsAction?: (proto.SyncActionValue.IRecentEmojiWeightsAction|null);

        /** SyncActionValue labelEditAction. */
        public labelEditAction?: (proto.SyncActionValue.ILabelEditAction|null);

        /** SyncActionValue labelAssociationAction. */
        public labelAssociationAction?: (proto.SyncActionValue.ILabelAssociationAction|null);

        /** SyncActionValue localeSetting. */
        public localeSetting?: (proto.SyncActionValue.ILocaleSetting|null);

        /** SyncActionValue archiveChatAction. */
        public archiveChatAction?: (proto.SyncActionValue.IArchiveChatAction|null);

        /** SyncActionValue deleteMessageForMeAction. */
        public deleteMessageForMeAction?: (proto.SyncActionValue.IDeleteMessageForMeAction|null);

        /** SyncActionValue keyExpiration. */
        public keyExpiration?: (proto.SyncActionValue.IKeyExpiration|null);

        /** SyncActionValue markChatAsReadAction. */
        public markChatAsReadAction?: (proto.SyncActionValue.IMarkChatAsReadAction|null);

        /** SyncActionValue clearChatAction. */
        public clearChatAction?: (proto.SyncActionValue.IClearChatAction|null);

        /** SyncActionValue deleteChatAction. */
        public deleteChatAction?: (proto.SyncActionValue.IDeleteChatAction|null);

        /** SyncActionValue unarchiveChatsSetting. */
        public unarchiveChatsSetting?: (proto.SyncActionValue.IUnarchiveChatsSetting|null);

        /** SyncActionValue primaryFeature. */
        public primaryFeature?: (proto.SyncActionValue.IPrimaryFeature|null);

        /** SyncActionValue androidUnsupportedActions. */
        public androidUnsupportedActions?: (proto.SyncActionValue.IAndroidUnsupportedActions|null);

        /** SyncActionValue agentAction. */
        public agentAction?: (proto.SyncActionValue.IAgentAction|null);

        /** SyncActionValue subscriptionAction. */
        public subscriptionAction?: (proto.SyncActionValue.ISubscriptionAction|null);

        /** SyncActionValue userStatusMuteAction. */
        public userStatusMuteAction?: (proto.SyncActionValue.IUserStatusMuteAction|null);

        /** SyncActionValue timeFormatAction. */
        public timeFormatAction?: (proto.SyncActionValue.ITimeFormatAction|null);

        /** SyncActionValue nuxAction. */
        public nuxAction?: (proto.SyncActionValue.INuxAction|null);

        /** SyncActionValue primaryVersionAction. */
        public primaryVersionAction?: (proto.SyncActionValue.IPrimaryVersionAction|null);

        /** SyncActionValue stickerAction. */
        public stickerAction?: (proto.SyncActionValue.IStickerAction|null);

        /** SyncActionValue removeRecentStickerAction. */
        public removeRecentStickerAction?: (proto.SyncActionValue.IRemoveRecentStickerAction|null);

        /** SyncActionValue chatAssignment. */
        public chatAssignment?: (proto.SyncActionValue.IChatAssignmentAction|null);

        /** SyncActionValue chatAssignmentOpenedStatus. */
        public chatAssignmentOpenedStatus?: (proto.SyncActionValue.IChatAssignmentOpenedStatusAction|null);

        /** SyncActionValue pnForLidChatAction. */
        public pnForLidChatAction?: (proto.SyncActionValue.IPnForLidChatAction|null);

        /**
         * Crea una nueva instancia SyncActionValue utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncActionValue instance
         */
        public static create(properties?: proto.ISyncActionValue): proto.SyncActionValue;

        /**
         * Codifica el mensaje SyncActionValue. No implícitamente mensajes {@link proto.SyncActionValue.verify|verify}.
         * @param message SyncActionValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncActionValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncActionValue message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.verify|verify}.
         * @param message SyncActionValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncActionValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncActionValue message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncActionValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue;

        /**
         * Decodes a SyncActionValue message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncActionValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue;

        /**
         * Verifies a SyncActionValue message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncActionValue message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncActionValue
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncActionValue;

        /**
         * Crea un objeto simple desde SyncActionValue. También convierte valores a otros tipos si se especifica.
         * @param message SyncActionValue
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncActionValue, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncActionValue a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace SyncActionValue {

        /** Propiedades de unn AgentAction. */
        interface IAgentAction {

            /** AgentAction name */
            name?: (string|null);

            /** AgentAction deviceID */
            deviceID?: (number|null);

            /** AgentAction isDeleted */
            isDeleted?: (boolean|null);
        }

        /** Representa unn AgentAction. */
        class AgentAction implements IAgentAction {

            /**
             * Construya un nuevo AgentAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IAgentAction);

            /** AgentAction name. */
            public name: string;

            /** AgentAction deviceID. */
            public deviceID: number;

            /** AgentAction isDeleted. */
            public isDeleted: boolean;

            /**
             * Crea una nueva instancia AgentAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AgentAction instance
             */
            public static create(properties?: proto.SyncActionValue.IAgentAction): proto.SyncActionValue.AgentAction;

            /**
             * Codifica el mensaje AgentAction. No implícitamente mensajes {@link proto.SyncActionValue.AgentAction.verify|verify}.
             * @param message AgentAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IAgentAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AgentAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.AgentAction.verify|verify}.
             * @param message AgentAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IAgentAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AgentAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AgentAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.AgentAction;

            /**
             * Decodes an AgentAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AgentAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.AgentAction;

            /**
             * Verifies an AgentAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AgentAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AgentAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.AgentAction;

            /**
             * Crea un objeto simple desden AgentAction. También convierte valores a otros tipos si se especifica.
             * @param message AgentAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.AgentAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AgentAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn AndroidUnsupportedActions. */
        interface IAndroidUnsupportedActions {

            /** AndroidUnsupportedActions allowed */
            allowed?: (boolean|null);
        }

        /** Representa unn AndroidUnsupportedActions. */
        class AndroidUnsupportedActions implements IAndroidUnsupportedActions {

            /**
             * Construya un nuevo AndroidUnsupportedActions.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IAndroidUnsupportedActions);

            /** AndroidUnsupportedActions allowed. */
            public allowed: boolean;

            /**
             * Crea una nueva instancia AndroidUnsupportedActions utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns AndroidUnsupportedActions instance
             */
            public static create(properties?: proto.SyncActionValue.IAndroidUnsupportedActions): proto.SyncActionValue.AndroidUnsupportedActions;

            /**
             * Codifica el mensaje AndroidUnsupportedActions. No implícitamente mensajes {@link proto.SyncActionValue.AndroidUnsupportedActions.verify|verify}.
             * @param message AndroidUnsupportedActions mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IAndroidUnsupportedActions, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje AndroidUnsupportedActions message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.AndroidUnsupportedActions.verify|verify}.
             * @param message AndroidUnsupportedActions mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IAndroidUnsupportedActions, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AndroidUnsupportedActions message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns AndroidUnsupportedActions
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.AndroidUnsupportedActions;

            /**
             * Decodes an AndroidUnsupportedActions message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns AndroidUnsupportedActions
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.AndroidUnsupportedActions;

            /**
             * Verifies an AndroidUnsupportedActions message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an AndroidUnsupportedActions message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns AndroidUnsupportedActions
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.AndroidUnsupportedActions;

            /**
             * Crea un objeto simple desden AndroidUnsupportedActions. También convierte valores a otros tipos si se especifica.
             * @param message AndroidUnsupportedActions
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.AndroidUnsupportedActions, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  AndroidUnsupportedActions a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn ArchiveChatAction. */
        interface IArchiveChatAction {

            /** ArchiveChatAction archived */
            archived?: (boolean|null);

            /** ArchiveChatAction messageRange */
            messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);
        }

        /** Representa unn ArchiveChatAction. */
        class ArchiveChatAction implements IArchiveChatAction {

            /**
             * Construya un nuevo ArchiveChatAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IArchiveChatAction);

            /** ArchiveChatAction archived. */
            public archived: boolean;

            /** ArchiveChatAction messageRange. */
            public messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);

            /**
             * Crea una nueva instancia ArchiveChatAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ArchiveChatAction instance
             */
            public static create(properties?: proto.SyncActionValue.IArchiveChatAction): proto.SyncActionValue.ArchiveChatAction;

            /**
             * Codifica el mensaje ArchiveChatAction. No implícitamente mensajes {@link proto.SyncActionValue.ArchiveChatAction.verify|verify}.
             * @param message ArchiveChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IArchiveChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ArchiveChatAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.ArchiveChatAction.verify|verify}.
             * @param message ArchiveChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IArchiveChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ArchiveChatAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ArchiveChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.ArchiveChatAction;

            /**
             * Decodes an ArchiveChatAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ArchiveChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.ArchiveChatAction;

            /**
             * Verifies an ArchiveChatAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an ArchiveChatAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ArchiveChatAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.ArchiveChatAction;

            /**
             * Crea un objeto simple desden ArchiveChatAction. También convierte valores a otros tipos si se especifica.
             * @param message ArchiveChatAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.ArchiveChatAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ArchiveChatAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ChatAssignmentAction. */
        interface IChatAssignmentAction {

            /** ChatAssignmentAction deviceAgentID */
            deviceAgentID?: (string|null);
        }

        /** Representa un ChatAssignmentAction. */
        class ChatAssignmentAction implements IChatAssignmentAction {

            /**
             * Construya un nuevo ChatAssignmentAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IChatAssignmentAction);

            /** ChatAssignmentAction deviceAgentID. */
            public deviceAgentID: string;

            /**
             * Crea una nueva instancia ChatAssignmentAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ChatAssignmentAction instance
             */
            public static create(properties?: proto.SyncActionValue.IChatAssignmentAction): proto.SyncActionValue.ChatAssignmentAction;

            /**
             * Codifica el mensaje ChatAssignmentAction. No implícitamente mensajes {@link proto.SyncActionValue.ChatAssignmentAction.verify|verify}.
             * @param message ChatAssignmentAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IChatAssignmentAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ChatAssignmentAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.ChatAssignmentAction.verify|verify}.
             * @param message ChatAssignmentAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IChatAssignmentAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ChatAssignmentAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ChatAssignmentAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.ChatAssignmentAction;

            /**
             * Decodes a ChatAssignmentAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ChatAssignmentAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.ChatAssignmentAction;

            /**
             * Verifies a ChatAssignmentAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ChatAssignmentAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ChatAssignmentAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.ChatAssignmentAction;

            /**
             * Crea un objeto simple desde ChatAssignmentAction. También convierte valores a otros tipos si se especifica.
             * @param message ChatAssignmentAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.ChatAssignmentAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ChatAssignmentAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ChatAssignmentOpenedStatusAction. */
        interface IChatAssignmentOpenedStatusAction {

            /** ChatAssignmentOpenedStatusAction chatOpened */
            chatOpened?: (boolean|null);
        }

        /** Representa un ChatAssignmentOpenedStatusAction. */
        class ChatAssignmentOpenedStatusAction implements IChatAssignmentOpenedStatusAction {

            /**
             * Construya un nuevo ChatAssignmentOpenedStatusAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IChatAssignmentOpenedStatusAction);

            /** ChatAssignmentOpenedStatusAction chatOpened. */
            public chatOpened: boolean;

            /**
             * Crea una nueva instancia ChatAssignmentOpenedStatusAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ChatAssignmentOpenedStatusAction instance
             */
            public static create(properties?: proto.SyncActionValue.IChatAssignmentOpenedStatusAction): proto.SyncActionValue.ChatAssignmentOpenedStatusAction;

            /**
             * Codifica el mensaje ChatAssignmentOpenedStatusAction. No implícitamente mensajes {@link proto.SyncActionValue.ChatAssignmentOpenedStatusAction.verify|verify}.
             * @param message ChatAssignmentOpenedStatusAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IChatAssignmentOpenedStatusAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ChatAssignmentOpenedStatusAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.ChatAssignmentOpenedStatusAction.verify|verify}.
             * @param message ChatAssignmentOpenedStatusAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IChatAssignmentOpenedStatusAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ChatAssignmentOpenedStatusAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ChatAssignmentOpenedStatusAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.ChatAssignmentOpenedStatusAction;

            /**
             * Decodes a ChatAssignmentOpenedStatusAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ChatAssignmentOpenedStatusAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.ChatAssignmentOpenedStatusAction;

            /**
             * Verifies a ChatAssignmentOpenedStatusAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ChatAssignmentOpenedStatusAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ChatAssignmentOpenedStatusAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.ChatAssignmentOpenedStatusAction;

            /**
             * Crea un objeto simple desde ChatAssignmentOpenedStatusAction. También convierte valores a otros tipos si se especifica.
             * @param message ChatAssignmentOpenedStatusAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.ChatAssignmentOpenedStatusAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ChatAssignmentOpenedStatusAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ClearChatAction. */
        interface IClearChatAction {

            /** ClearChatAction messageRange */
            messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);
        }

        /** Representa un ClearChatAction. */
        class ClearChatAction implements IClearChatAction {

            /**
             * Construya un nuevo ClearChatAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IClearChatAction);

            /** ClearChatAction messageRange. */
            public messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);

            /**
             * Crea una nueva instancia ClearChatAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ClearChatAction instance
             */
            public static create(properties?: proto.SyncActionValue.IClearChatAction): proto.SyncActionValue.ClearChatAction;

            /**
             * Codifica el mensaje ClearChatAction. No implícitamente mensajes {@link proto.SyncActionValue.ClearChatAction.verify|verify}.
             * @param message ClearChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IClearChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ClearChatAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.ClearChatAction.verify|verify}.
             * @param message ClearChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IClearChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ClearChatAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ClearChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.ClearChatAction;

            /**
             * Decodes a ClearChatAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ClearChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.ClearChatAction;

            /**
             * Verifies a ClearChatAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ClearChatAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ClearChatAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.ClearChatAction;

            /**
             * Crea un objeto simple desde ClearChatAction. También convierte valores a otros tipos si se especifica.
             * @param message ClearChatAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.ClearChatAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ClearChatAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un ContactAction. */
        interface IContactAction {

            /** ContactAction fullName */
            fullName?: (string|null);

            /** ContactAction firstName */
            firstName?: (string|null);

            /** ContactAction lidJid */
            lidJid?: (string|null);
        }

        /** Representa un ContactAction. */
        class ContactAction implements IContactAction {

            /**
             * Construya un nuevo ContactAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IContactAction);

            /** ContactAction fullName. */
            public fullName: string;

            /** ContactAction firstName. */
            public firstName: string;

            /** ContactAction lidJid. */
            public lidJid: string;

            /**
             * Crea una nueva instancia ContactAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns ContactAction instance
             */
            public static create(properties?: proto.SyncActionValue.IContactAction): proto.SyncActionValue.ContactAction;

            /**
             * Codifica el mensaje ContactAction. No implícitamente mensajes {@link proto.SyncActionValue.ContactAction.verify|verify}.
             * @param message ContactAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IContactAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje ContactAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.ContactAction.verify|verify}.
             * @param message ContactAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IContactAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContactAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns ContactAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.ContactAction;

            /**
             * Decodes a ContactAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns ContactAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.ContactAction;

            /**
             * Verifies a ContactAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a ContactAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns ContactAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.ContactAction;

            /**
             * Crea un objeto simple desde ContactAction. También convierte valores a otros tipos si se especifica.
             * @param message ContactAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.ContactAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  ContactAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un DeleteChatAction. */
        interface IDeleteChatAction {

            /** DeleteChatAction messageRange */
            messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);
        }

        /** Representa un DeleteChatAction. */
        class DeleteChatAction implements IDeleteChatAction {

            /**
             * Construya un nuevo DeleteChatAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IDeleteChatAction);

            /** DeleteChatAction messageRange. */
            public messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);

            /**
             * Crea una nueva instancia DeleteChatAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DeleteChatAction instance
             */
            public static create(properties?: proto.SyncActionValue.IDeleteChatAction): proto.SyncActionValue.DeleteChatAction;

            /**
             * Codifica el mensaje DeleteChatAction. No implícitamente mensajes {@link proto.SyncActionValue.DeleteChatAction.verify|verify}.
             * @param message DeleteChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IDeleteChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DeleteChatAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.DeleteChatAction.verify|verify}.
             * @param message DeleteChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IDeleteChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DeleteChatAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DeleteChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.DeleteChatAction;

            /**
             * Decodes a DeleteChatAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DeleteChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.DeleteChatAction;

            /**
             * Verifies a DeleteChatAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DeleteChatAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DeleteChatAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.DeleteChatAction;

            /**
             * Crea un objeto simple desde DeleteChatAction. También convierte valores a otros tipos si se especifica.
             * @param message DeleteChatAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.DeleteChatAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DeleteChatAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un DeleteMessageForMeAction. */
        interface IDeleteMessageForMeAction {

            /** DeleteMessageForMeAction deleteMedia */
            deleteMedia?: (boolean|null);

            /** DeleteMessageForMeAction messageTimestamp */
            messageTimestamp?: (number|Long|null);
        }

        /** Representa un DeleteMessageForMeAction. */
        class DeleteMessageForMeAction implements IDeleteMessageForMeAction {

            /**
             * Construya un nuevo DeleteMessageForMeAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IDeleteMessageForMeAction);

            /** DeleteMessageForMeAction deleteMedia. */
            public deleteMedia: boolean;

            /** DeleteMessageForMeAction messageTimestamp. */
            public messageTimestamp: (number|Long);

            /**
             * Crea una nueva instancia DeleteMessageForMeAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns DeleteMessageForMeAction instance
             */
            public static create(properties?: proto.SyncActionValue.IDeleteMessageForMeAction): proto.SyncActionValue.DeleteMessageForMeAction;

            /**
             * Codifica el mensaje DeleteMessageForMeAction. No implícitamente mensajes {@link proto.SyncActionValue.DeleteMessageForMeAction.verify|verify}.
             * @param message DeleteMessageForMeAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IDeleteMessageForMeAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje DeleteMessageForMeAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.DeleteMessageForMeAction.verify|verify}.
             * @param message DeleteMessageForMeAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IDeleteMessageForMeAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DeleteMessageForMeAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns DeleteMessageForMeAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.DeleteMessageForMeAction;

            /**
             * Decodes a DeleteMessageForMeAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns DeleteMessageForMeAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.DeleteMessageForMeAction;

            /**
             * Verifies a DeleteMessageForMeAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a DeleteMessageForMeAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns DeleteMessageForMeAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.DeleteMessageForMeAction;

            /**
             * Crea un objeto simple desde DeleteMessageForMeAction. También convierte valores a otros tipos si se especifica.
             * @param message DeleteMessageForMeAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.DeleteMessageForMeAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  DeleteMessageForMeAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un KeyExpiration. */
        interface IKeyExpiration {

            /** KeyExpiration expiredKeyEpoch */
            expiredKeyEpoch?: (number|null);
        }

        /** Representa un KeyExpiration. */
        class KeyExpiration implements IKeyExpiration {

            /**
             * Construya un nuevo KeyExpiration.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IKeyExpiration);

            /** KeyExpiration expiredKeyEpoch. */
            public expiredKeyEpoch: number;

            /**
             * Crea una nueva instancia KeyExpiration utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns KeyExpiration instance
             */
            public static create(properties?: proto.SyncActionValue.IKeyExpiration): proto.SyncActionValue.KeyExpiration;

            /**
             * Codifica el mensaje KeyExpiration. No implícitamente mensajes {@link proto.SyncActionValue.KeyExpiration.verify|verify}.
             * @param message KeyExpiration mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IKeyExpiration, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje KeyExpiration message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.KeyExpiration.verify|verify}.
             * @param message KeyExpiration mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IKeyExpiration, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KeyExpiration message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns KeyExpiration
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.KeyExpiration;

            /**
             * Decodes a KeyExpiration message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns KeyExpiration
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.KeyExpiration;

            /**
             * Verifies a KeyExpiration message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a KeyExpiration message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns KeyExpiration
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.KeyExpiration;

            /**
             * Crea un objeto simple desde KeyExpiration. También convierte valores a otros tipos si se especifica.
             * @param message KeyExpiration
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.KeyExpiration, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  KeyExpiration a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un LabelAssociationAction. */
        interface ILabelAssociationAction {

            /** LabelAssociationAction labeled */
            labeled?: (boolean|null);
        }

        /** Representa un LabelAssociationAction. */
        class LabelAssociationAction implements ILabelAssociationAction {

            /**
             * Construya un nuevo LabelAssociationAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ILabelAssociationAction);

            /** LabelAssociationAction labeled. */
            public labeled: boolean;

            /**
             * Crea una nueva instancia LabelAssociationAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns LabelAssociationAction instance
             */
            public static create(properties?: proto.SyncActionValue.ILabelAssociationAction): proto.SyncActionValue.LabelAssociationAction;

            /**
             * Codifica el mensaje LabelAssociationAction. No implícitamente mensajes {@link proto.SyncActionValue.LabelAssociationAction.verify|verify}.
             * @param message LabelAssociationAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ILabelAssociationAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje LabelAssociationAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.LabelAssociationAction.verify|verify}.
             * @param message LabelAssociationAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ILabelAssociationAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LabelAssociationAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns LabelAssociationAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.LabelAssociationAction;

            /**
             * Decodes a LabelAssociationAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns LabelAssociationAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.LabelAssociationAction;

            /**
             * Verifies a LabelAssociationAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a LabelAssociationAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns LabelAssociationAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.LabelAssociationAction;

            /**
             * Crea un objeto simple desde LabelAssociationAction. También convierte valores a otros tipos si se especifica.
             * @param message LabelAssociationAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.LabelAssociationAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  LabelAssociationAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un LabelEditAction. */
        interface ILabelEditAction {

            /** LabelEditAction name */
            name?: (string|null);

            /** LabelEditAction color */
            color?: (number|null);

            /** LabelEditAction predefinedId */
            predefinedId?: (number|null);

            /** LabelEditAction deleted */
            deleted?: (boolean|null);
        }

        /** Representa un LabelEditAction. */
        class LabelEditAction implements ILabelEditAction {

            /**
             * Construya un nuevo LabelEditAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ILabelEditAction);

            /** LabelEditAction name. */
            public name: string;

            /** LabelEditAction color. */
            public color: number;

            /** LabelEditAction predefinedId. */
            public predefinedId: number;

            /** LabelEditAction deleted. */
            public deleted: boolean;

            /**
             * Crea una nueva instancia LabelEditAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns LabelEditAction instance
             */
            public static create(properties?: proto.SyncActionValue.ILabelEditAction): proto.SyncActionValue.LabelEditAction;

            /**
             * Codifica el mensaje LabelEditAction. No implícitamente mensajes {@link proto.SyncActionValue.LabelEditAction.verify|verify}.
             * @param message LabelEditAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ILabelEditAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje LabelEditAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.LabelEditAction.verify|verify}.
             * @param message LabelEditAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ILabelEditAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LabelEditAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns LabelEditAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.LabelEditAction;

            /**
             * Decodes a LabelEditAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns LabelEditAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.LabelEditAction;

            /**
             * Verifies a LabelEditAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a LabelEditAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns LabelEditAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.LabelEditAction;

            /**
             * Crea un objeto simple desde LabelEditAction. También convierte valores a otros tipos si se especifica.
             * @param message LabelEditAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.LabelEditAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  LabelEditAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un LocaleSetting. */
        interface ILocaleSetting {

            /** LocaleSetting locale */
            locale?: (string|null);
        }

        /** Representa un LocaleSetting. */
        class LocaleSetting implements ILocaleSetting {

            /**
             * Construya un nuevo LocaleSetting.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ILocaleSetting);

            /** LocaleSetting locale. */
            public locale: string;

            /**
             * Crea una nueva instancia LocaleSetting utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns LocaleSetting instance
             */
            public static create(properties?: proto.SyncActionValue.ILocaleSetting): proto.SyncActionValue.LocaleSetting;

            /**
             * Codifica el mensaje LocaleSetting. No implícitamente mensajes {@link proto.SyncActionValue.LocaleSetting.verify|verify}.
             * @param message LocaleSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ILocaleSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje LocaleSetting message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.LocaleSetting.verify|verify}.
             * @param message LocaleSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ILocaleSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LocaleSetting message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns LocaleSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.LocaleSetting;

            /**
             * Decodes a LocaleSetting message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns LocaleSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.LocaleSetting;

            /**
             * Verifies a LocaleSetting message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a LocaleSetting message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns LocaleSetting
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.LocaleSetting;

            /**
             * Crea un objeto simple desde LocaleSetting. También convierte valores a otros tipos si se especifica.
             * @param message LocaleSetting
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.LocaleSetting, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  LocaleSetting a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un MarkChatAsReadAction. */
        interface IMarkChatAsReadAction {

            /** MarkChatAsReadAction read */
            read?: (boolean|null);

            /** MarkChatAsReadAction messageRange */
            messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);
        }

        /** Representa un MarkChatAsReadAction. */
        class MarkChatAsReadAction implements IMarkChatAsReadAction {

            /**
             * Construya un nuevo MarkChatAsReadAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IMarkChatAsReadAction);

            /** MarkChatAsReadAction read. */
            public read: boolean;

            /** MarkChatAsReadAction messageRange. */
            public messageRange?: (proto.SyncActionValue.ISyncActionMessageRange|null);

            /**
             * Crea una nueva instancia MarkChatAsReadAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns MarkChatAsReadAction instance
             */
            public static create(properties?: proto.SyncActionValue.IMarkChatAsReadAction): proto.SyncActionValue.MarkChatAsReadAction;

            /**
             * Codifica el mensaje MarkChatAsReadAction. No implícitamente mensajes {@link proto.SyncActionValue.MarkChatAsReadAction.verify|verify}.
             * @param message MarkChatAsReadAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IMarkChatAsReadAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje MarkChatAsReadAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.MarkChatAsReadAction.verify|verify}.
             * @param message MarkChatAsReadAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IMarkChatAsReadAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MarkChatAsReadAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns MarkChatAsReadAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.MarkChatAsReadAction;

            /**
             * Decodes a MarkChatAsReadAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns MarkChatAsReadAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.MarkChatAsReadAction;

            /**
             * Verifies a MarkChatAsReadAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a MarkChatAsReadAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns MarkChatAsReadAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.MarkChatAsReadAction;

            /**
             * Crea un objeto simple desde MarkChatAsReadAction. También convierte valores a otros tipos si se especifica.
             * @param message MarkChatAsReadAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.MarkChatAsReadAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  MarkChatAsReadAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un MuteAction. */
        interface IMuteAction {

            /** MuteAction muted */
            muted?: (boolean|null);

            /** MuteAction muteEndTimestamp */
            muteEndTimestamp?: (number|Long|null);

            /** MuteAction autoMuted */
            autoMuted?: (boolean|null);
        }

        /** Representa un MuteAction. */
        class MuteAction implements IMuteAction {

            /**
             * Construya un nuevo MuteAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IMuteAction);

            /** MuteAction muted. */
            public muted: boolean;

            /** MuteAction muteEndTimestamp. */
            public muteEndTimestamp: (number|Long);

            /** MuteAction autoMuted. */
            public autoMuted: boolean;

            /**
             * Crea una nueva instancia MuteAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns MuteAction instance
             */
            public static create(properties?: proto.SyncActionValue.IMuteAction): proto.SyncActionValue.MuteAction;

            /**
             * Codifica el mensaje MuteAction. No implícitamente mensajes {@link proto.SyncActionValue.MuteAction.verify|verify}.
             * @param message MuteAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IMuteAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje MuteAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.MuteAction.verify|verify}.
             * @param message MuteAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IMuteAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MuteAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns MuteAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.MuteAction;

            /**
             * Decodes a MuteAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns MuteAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.MuteAction;

            /**
             * Verifies a MuteAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a MuteAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns MuteAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.MuteAction;

            /**
             * Crea un objeto simple desde MuteAction. También convierte valores a otros tipos si se especifica.
             * @param message MuteAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.MuteAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  MuteAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un NuxAction. */
        interface INuxAction {

            /** NuxAction acknowledged */
            acknowledged?: (boolean|null);
        }

        /** Representa un NuxAction. */
        class NuxAction implements INuxAction {

            /**
             * Construya un nuevo NuxAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.INuxAction);

            /** NuxAction acknowledged. */
            public acknowledged: boolean;

            /**
             * Crea una nueva instancia NuxAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns NuxAction instance
             */
            public static create(properties?: proto.SyncActionValue.INuxAction): proto.SyncActionValue.NuxAction;

            /**
             * Codifica el mensaje NuxAction. No implícitamente mensajes {@link proto.SyncActionValue.NuxAction.verify|verify}.
             * @param message NuxAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.INuxAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje NuxAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.NuxAction.verify|verify}.
             * @param message NuxAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.INuxAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NuxAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns NuxAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.NuxAction;

            /**
             * Decodes a NuxAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns NuxAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.NuxAction;

            /**
             * Verifies a NuxAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a NuxAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns NuxAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.NuxAction;

            /**
             * Crea un objeto simple desde NuxAction. También convierte valores a otros tipos si se especifica.
             * @param message NuxAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.NuxAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  NuxAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PinAction. */
        interface IPinAction {

            /** PinAction pinned */
            pinned?: (boolean|null);
        }

        /** Representa un PinAction. */
        class PinAction implements IPinAction {

            /**
             * Construya un nuevo PinAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IPinAction);

            /** PinAction pinned. */
            public pinned: boolean;

            /**
             * Crea una nueva instancia PinAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PinAction instance
             */
            public static create(properties?: proto.SyncActionValue.IPinAction): proto.SyncActionValue.PinAction;

            /**
             * Codifica el mensaje PinAction. No implícitamente mensajes {@link proto.SyncActionValue.PinAction.verify|verify}.
             * @param message PinAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IPinAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PinAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.PinAction.verify|verify}.
             * @param message PinAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IPinAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PinAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PinAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.PinAction;

            /**
             * Decodes a PinAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PinAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.PinAction;

            /**
             * Verifies a PinAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PinAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PinAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.PinAction;

            /**
             * Crea un objeto simple desde PinAction. También convierte valores a otros tipos si se especifica.
             * @param message PinAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.PinAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PinAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PnForLidChatAction. */
        interface IPnForLidChatAction {

            /** PnForLidChatAction pnJid */
            pnJid?: (string|null);
        }

        /** Representa un PnForLidChatAction. */
        class PnForLidChatAction implements IPnForLidChatAction {

            /**
             * Construya un nuevo PnForLidChatAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IPnForLidChatAction);

            /** PnForLidChatAction pnJid. */
            public pnJid: string;

            /**
             * Crea una nueva instancia PnForLidChatAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PnForLidChatAction instance
             */
            public static create(properties?: proto.SyncActionValue.IPnForLidChatAction): proto.SyncActionValue.PnForLidChatAction;

            /**
             * Codifica el mensaje PnForLidChatAction. No implícitamente mensajes {@link proto.SyncActionValue.PnForLidChatAction.verify|verify}.
             * @param message PnForLidChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IPnForLidChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PnForLidChatAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.PnForLidChatAction.verify|verify}.
             * @param message PnForLidChatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IPnForLidChatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PnForLidChatAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PnForLidChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.PnForLidChatAction;

            /**
             * Decodes a PnForLidChatAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PnForLidChatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.PnForLidChatAction;

            /**
             * Verifies a PnForLidChatAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PnForLidChatAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PnForLidChatAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.PnForLidChatAction;

            /**
             * Crea un objeto simple desde PnForLidChatAction. También convierte valores a otros tipos si se especifica.
             * @param message PnForLidChatAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.PnForLidChatAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PnForLidChatAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PrimaryFeature. */
        interface IPrimaryFeature {

            /** PrimaryFeature flags */
            flags?: (string[]|null);
        }

        /** Representa un PrimaryFeature. */
        class PrimaryFeature implements IPrimaryFeature {

            /**
             * Construya un nuevo PrimaryFeature.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IPrimaryFeature);

            /** PrimaryFeature flags. */
            public flags: string[];

            /**
             * Crea una nueva instancia PrimaryFeature utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PrimaryFeature instance
             */
            public static create(properties?: proto.SyncActionValue.IPrimaryFeature): proto.SyncActionValue.PrimaryFeature;

            /**
             * Codifica el mensaje PrimaryFeature. No implícitamente mensajes {@link proto.SyncActionValue.PrimaryFeature.verify|verify}.
             * @param message PrimaryFeature mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IPrimaryFeature, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PrimaryFeature message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.PrimaryFeature.verify|verify}.
             * @param message PrimaryFeature mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IPrimaryFeature, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PrimaryFeature message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PrimaryFeature
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.PrimaryFeature;

            /**
             * Decodes a PrimaryFeature message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PrimaryFeature
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.PrimaryFeature;

            /**
             * Verifies a PrimaryFeature message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PrimaryFeature message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PrimaryFeature
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.PrimaryFeature;

            /**
             * Crea un objeto simple desde PrimaryFeature. También convierte valores a otros tipos si se especifica.
             * @param message PrimaryFeature
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.PrimaryFeature, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PrimaryFeature a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PrimaryVersionAction. */
        interface IPrimaryVersionAction {

            /** PrimaryVersionAction version */
            version?: (string|null);
        }

        /** Representa un PrimaryVersionAction. */
        class PrimaryVersionAction implements IPrimaryVersionAction {

            /**
             * Construya un nuevo PrimaryVersionAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IPrimaryVersionAction);

            /** PrimaryVersionAction version. */
            public version: string;

            /**
             * Crea una nueva instancia PrimaryVersionAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PrimaryVersionAction instance
             */
            public static create(properties?: proto.SyncActionValue.IPrimaryVersionAction): proto.SyncActionValue.PrimaryVersionAction;

            /**
             * Codifica el mensaje PrimaryVersionAction. No implícitamente mensajes {@link proto.SyncActionValue.PrimaryVersionAction.verify|verify}.
             * @param message PrimaryVersionAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IPrimaryVersionAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PrimaryVersionAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.PrimaryVersionAction.verify|verify}.
             * @param message PrimaryVersionAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IPrimaryVersionAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PrimaryVersionAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PrimaryVersionAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.PrimaryVersionAction;

            /**
             * Decodes a PrimaryVersionAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PrimaryVersionAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.PrimaryVersionAction;

            /**
             * Verifies a PrimaryVersionAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PrimaryVersionAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PrimaryVersionAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.PrimaryVersionAction;

            /**
             * Crea un objeto simple desde PrimaryVersionAction. También convierte valores a otros tipos si se especifica.
             * @param message PrimaryVersionAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.PrimaryVersionAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PrimaryVersionAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un PushNameSetting. */
        interface IPushNameSetting {

            /** PushNameSetting name */
            name?: (string|null);
        }

        /** Representa un PushNameSetting. */
        class PushNameSetting implements IPushNameSetting {

            /**
             * Construya un nuevo PushNameSetting.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IPushNameSetting);

            /** PushNameSetting name. */
            public name: string;

            /**
             * Crea una nueva instancia PushNameSetting utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns PushNameSetting instance
             */
            public static create(properties?: proto.SyncActionValue.IPushNameSetting): proto.SyncActionValue.PushNameSetting;

            /**
             * Codifica el mensaje PushNameSetting. No implícitamente mensajes {@link proto.SyncActionValue.PushNameSetting.verify|verify}.
             * @param message PushNameSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IPushNameSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje PushNameSetting message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.PushNameSetting.verify|verify}.
             * @param message PushNameSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IPushNameSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PushNameSetting message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns PushNameSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.PushNameSetting;

            /**
             * Decodes a PushNameSetting message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns PushNameSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.PushNameSetting;

            /**
             * Verifies a PushNameSetting message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a PushNameSetting message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns PushNameSetting
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.PushNameSetting;

            /**
             * Crea un objeto simple desde PushNameSetting. También convierte valores a otros tipos si se especifica.
             * @param message PushNameSetting
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.PushNameSetting, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  PushNameSetting a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un QuickReplyAction. */
        interface IQuickReplyAction {

            /** QuickReplyAction shortcut */
            shortcut?: (string|null);

            /** QuickReplyAction message */
            message?: (string|null);

            /** QuickReplyAction keywords */
            keywords?: (string[]|null);

            /** QuickReplyAction count */
            count?: (number|null);

            /** QuickReplyAction deleted */
            deleted?: (boolean|null);
        }

        /** Representa un QuickReplyAction. */
        class QuickReplyAction implements IQuickReplyAction {

            /**
             * Construya un nuevo QuickReplyAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IQuickReplyAction);

            /** QuickReplyAction shortcut. */
            public shortcut: string;

            /** QuickReplyAction message. */
            public message: string;

            /** QuickReplyAction keywords. */
            public keywords: string[];

            /** QuickReplyAction count. */
            public count: number;

            /** QuickReplyAction deleted. */
            public deleted: boolean;

            /**
             * Crea una nueva instancia QuickReplyAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns QuickReplyAction instance
             */
            public static create(properties?: proto.SyncActionValue.IQuickReplyAction): proto.SyncActionValue.QuickReplyAction;

            /**
             * Codifica el mensaje QuickReplyAction. No implícitamente mensajes {@link proto.SyncActionValue.QuickReplyAction.verify|verify}.
             * @param message QuickReplyAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IQuickReplyAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje QuickReplyAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.QuickReplyAction.verify|verify}.
             * @param message QuickReplyAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IQuickReplyAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a QuickReplyAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns QuickReplyAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.QuickReplyAction;

            /**
             * Decodes a QuickReplyAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns QuickReplyAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.QuickReplyAction;

            /**
             * Verifies a QuickReplyAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a QuickReplyAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns QuickReplyAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.QuickReplyAction;

            /**
             * Crea un objeto simple desde QuickReplyAction. También convierte valores a otros tipos si se especifica.
             * @param message QuickReplyAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.QuickReplyAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  QuickReplyAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un RecentEmojiWeightsAction. */
        interface IRecentEmojiWeightsAction {

            /** RecentEmojiWeightsAction weights */
            weights?: (proto.IRecentEmojiWeight[]|null);
        }

        /** Representa un RecentEmojiWeightsAction. */
        class RecentEmojiWeightsAction implements IRecentEmojiWeightsAction {

            /**
             * Construya un nuevo RecentEmojiWeightsAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IRecentEmojiWeightsAction);

            /** RecentEmojiWeightsAction weights. */
            public weights: proto.IRecentEmojiWeight[];

            /**
             * Crea una nueva instancia RecentEmojiWeightsAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns RecentEmojiWeightsAction instance
             */
            public static create(properties?: proto.SyncActionValue.IRecentEmojiWeightsAction): proto.SyncActionValue.RecentEmojiWeightsAction;

            /**
             * Codifica el mensaje RecentEmojiWeightsAction. No implícitamente mensajes {@link proto.SyncActionValue.RecentEmojiWeightsAction.verify|verify}.
             * @param message RecentEmojiWeightsAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IRecentEmojiWeightsAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje RecentEmojiWeightsAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.RecentEmojiWeightsAction.verify|verify}.
             * @param message RecentEmojiWeightsAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IRecentEmojiWeightsAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RecentEmojiWeightsAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns RecentEmojiWeightsAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.RecentEmojiWeightsAction;

            /**
             * Decodes a RecentEmojiWeightsAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns RecentEmojiWeightsAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.RecentEmojiWeightsAction;

            /**
             * Verifies a RecentEmojiWeightsAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a RecentEmojiWeightsAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns RecentEmojiWeightsAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.RecentEmojiWeightsAction;

            /**
             * Crea un objeto simple desde RecentEmojiWeightsAction. También convierte valores a otros tipos si se especifica.
             * @param message RecentEmojiWeightsAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.RecentEmojiWeightsAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  RecentEmojiWeightsAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un RemoveRecentStickerAction. */
        interface IRemoveRecentStickerAction {

            /** RemoveRecentStickerAction lastStickerSentTs */
            lastStickerSentTs?: (number|Long|null);
        }

        /** Representa un RemoveRecentStickerAction. */
        class RemoveRecentStickerAction implements IRemoveRecentStickerAction {

            /**
             * Construya un nuevo RemoveRecentStickerAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IRemoveRecentStickerAction);

            /** RemoveRecentStickerAction lastStickerSentTs. */
            public lastStickerSentTs: (number|Long);

            /**
             * Crea una nueva instancia RemoveRecentStickerAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns RemoveRecentStickerAction instance
             */
            public static create(properties?: proto.SyncActionValue.IRemoveRecentStickerAction): proto.SyncActionValue.RemoveRecentStickerAction;

            /**
             * Codifica el mensaje RemoveRecentStickerAction. No implícitamente mensajes {@link proto.SyncActionValue.RemoveRecentStickerAction.verify|verify}.
             * @param message RemoveRecentStickerAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IRemoveRecentStickerAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje RemoveRecentStickerAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.RemoveRecentStickerAction.verify|verify}.
             * @param message RemoveRecentStickerAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IRemoveRecentStickerAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RemoveRecentStickerAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns RemoveRecentStickerAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.RemoveRecentStickerAction;

            /**
             * Decodes a RemoveRecentStickerAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns RemoveRecentStickerAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.RemoveRecentStickerAction;

            /**
             * Verifies a RemoveRecentStickerAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a RemoveRecentStickerAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns RemoveRecentStickerAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.RemoveRecentStickerAction;

            /**
             * Crea un objeto simple desde RemoveRecentStickerAction. También convierte valores a otros tipos si se especifica.
             * @param message RemoveRecentStickerAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.RemoveRecentStickerAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  RemoveRecentStickerAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SecurityNotificationSetting. */
        interface ISecurityNotificationSetting {

            /** SecurityNotificationSetting showNotification */
            showNotification?: (boolean|null);
        }

        /** Representa un SecurityNotificationSetting. */
        class SecurityNotificationSetting implements ISecurityNotificationSetting {

            /**
             * Construya un nuevo SecurityNotificationSetting.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ISecurityNotificationSetting);

            /** SecurityNotificationSetting showNotification. */
            public showNotification: boolean;

            /**
             * Crea una nueva instancia SecurityNotificationSetting utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SecurityNotificationSetting instance
             */
            public static create(properties?: proto.SyncActionValue.ISecurityNotificationSetting): proto.SyncActionValue.SecurityNotificationSetting;

            /**
             * Codifica el mensaje SecurityNotificationSetting. No implícitamente mensajes {@link proto.SyncActionValue.SecurityNotificationSetting.verify|verify}.
             * @param message SecurityNotificationSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ISecurityNotificationSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SecurityNotificationSetting message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.SecurityNotificationSetting.verify|verify}.
             * @param message SecurityNotificationSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ISecurityNotificationSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SecurityNotificationSetting message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SecurityNotificationSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.SecurityNotificationSetting;

            /**
             * Decodes a SecurityNotificationSetting message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SecurityNotificationSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.SecurityNotificationSetting;

            /**
             * Verifies a SecurityNotificationSetting message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SecurityNotificationSetting message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SecurityNotificationSetting
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.SecurityNotificationSetting;

            /**
             * Crea un objeto simple desde SecurityNotificationSetting. También convierte valores a otros tipos si se especifica.
             * @param message SecurityNotificationSetting
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.SecurityNotificationSetting, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SecurityNotificationSetting a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un StarAction. */
        interface IStarAction {

            /** StarAction starred */
            starred?: (boolean|null);
        }

        /** Representa un StarAction. */
        class StarAction implements IStarAction {

            /**
             * Construya un nuevo StarAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IStarAction);

            /** StarAction starred. */
            public starred: boolean;

            /**
             * Crea una nueva instancia StarAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns StarAction instance
             */
            public static create(properties?: proto.SyncActionValue.IStarAction): proto.SyncActionValue.StarAction;

            /**
             * Codifica el mensaje StarAction. No implícitamente mensajes {@link proto.SyncActionValue.StarAction.verify|verify}.
             * @param message StarAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IStarAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje StarAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.StarAction.verify|verify}.
             * @param message StarAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IStarAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StarAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns StarAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.StarAction;

            /**
             * Decodes a StarAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns StarAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.StarAction;

            /**
             * Verifies a StarAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a StarAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns StarAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.StarAction;

            /**
             * Crea un objeto simple desde StarAction. También convierte valores a otros tipos si se especifica.
             * @param message StarAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.StarAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  StarAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un StickerAction. */
        interface IStickerAction {

            /** StickerAction url */
            url?: (string|null);

            /** StickerAction fileEncSha256 */
            fileEncSha256?: (Uint8Array|null);

            /** StickerAction mediaKey */
            mediaKey?: (Uint8Array|null);

            /** StickerAction mimetype */
            mimetype?: (string|null);

            /** StickerAction height */
            height?: (number|null);

            /** StickerAction width */
            width?: (number|null);

            /** StickerAction directPath */
            directPath?: (string|null);

            /** StickerAction fileLength */
            fileLength?: (number|Long|null);

            /** StickerAction isFavorite */
            isFavorite?: (boolean|null);

            /** StickerAction deviceIdHint */
            deviceIdHint?: (number|null);
        }

        /** Representa un StickerAction. */
        class StickerAction implements IStickerAction {

            /**
             * Construya un nuevo StickerAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IStickerAction);

            /** StickerAction url. */
            public url: string;

            /** StickerAction fileEncSha256. */
            public fileEncSha256: Uint8Array;

            /** StickerAction mediaKey. */
            public mediaKey: Uint8Array;

            /** StickerAction mimetype. */
            public mimetype: string;

            /** StickerAction height. */
            public height: number;

            /** StickerAction width. */
            public width: number;

            /** StickerAction directPath. */
            public directPath: string;

            /** StickerAction fileLength. */
            public fileLength: (number|Long);

            /** StickerAction isFavorite. */
            public isFavorite: boolean;

            /** StickerAction deviceIdHint. */
            public deviceIdHint: number;

            /**
             * Crea una nueva instancia StickerAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns StickerAction instance
             */
            public static create(properties?: proto.SyncActionValue.IStickerAction): proto.SyncActionValue.StickerAction;

            /**
             * Codifica el mensaje StickerAction. No implícitamente mensajes {@link proto.SyncActionValue.StickerAction.verify|verify}.
             * @param message StickerAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IStickerAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje StickerAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.StickerAction.verify|verify}.
             * @param message StickerAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IStickerAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StickerAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns StickerAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.StickerAction;

            /**
             * Decodes a StickerAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns StickerAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.StickerAction;

            /**
             * Verifies a StickerAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a StickerAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns StickerAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.StickerAction;

            /**
             * Crea un objeto simple desde StickerAction. También convierte valores a otros tipos si se especifica.
             * @param message StickerAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.StickerAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  StickerAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SubscriptionAction. */
        interface ISubscriptionAction {

            /** SubscriptionAction isDeactivated */
            isDeactivated?: (boolean|null);

            /** SubscriptionAction isAutoRenewing */
            isAutoRenewing?: (boolean|null);

            /** SubscriptionAction expirationDate */
            expirationDate?: (number|Long|null);
        }

        /** Representa un SubscriptionAction. */
        class SubscriptionAction implements ISubscriptionAction {

            /**
             * Construya un nuevo SubscriptionAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ISubscriptionAction);

            /** SubscriptionAction isDeactivated. */
            public isDeactivated: boolean;

            /** SubscriptionAction isAutoRenewing. */
            public isAutoRenewing: boolean;

            /** SubscriptionAction expirationDate. */
            public expirationDate: (number|Long);

            /**
             * Crea una nueva instancia SubscriptionAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SubscriptionAction instance
             */
            public static create(properties?: proto.SyncActionValue.ISubscriptionAction): proto.SyncActionValue.SubscriptionAction;

            /**
             * Codifica el mensaje SubscriptionAction. No implícitamente mensajes {@link proto.SyncActionValue.SubscriptionAction.verify|verify}.
             * @param message SubscriptionAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ISubscriptionAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SubscriptionAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.SubscriptionAction.verify|verify}.
             * @param message SubscriptionAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ISubscriptionAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SubscriptionAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SubscriptionAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.SubscriptionAction;

            /**
             * Decodes a SubscriptionAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SubscriptionAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.SubscriptionAction;

            /**
             * Verifies a SubscriptionAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SubscriptionAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SubscriptionAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.SubscriptionAction;

            /**
             * Crea un objeto simple desde SubscriptionAction. También convierte valores a otros tipos si se especifica.
             * @param message SubscriptionAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.SubscriptionAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SubscriptionAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SyncActionMessage. */
        interface ISyncActionMessage {

            /** SyncActionMessage key */
            key?: (proto.IMessageKey|null);

            /** SyncActionMessage timestamp */
            timestamp?: (number|Long|null);
        }

        /** Representa un SyncActionMessage. */
        class SyncActionMessage implements ISyncActionMessage {

            /**
             * Construya un nuevo SyncActionMessage.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ISyncActionMessage);

            /** SyncActionMessage key. */
            public key?: (proto.IMessageKey|null);

            /** SyncActionMessage timestamp. */
            public timestamp: (number|Long);

            /**
             * Crea una nueva instancia SyncActionMessage utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SyncActionMessage instance
             */
            public static create(properties?: proto.SyncActionValue.ISyncActionMessage): proto.SyncActionValue.SyncActionMessage;

            /**
             * Codifica el mensaje SyncActionMessage. No implícitamente mensajes {@link proto.SyncActionValue.SyncActionMessage.verify|verify}.
             * @param message SyncActionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ISyncActionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SyncActionMessage message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.SyncActionMessage.verify|verify}.
             * @param message SyncActionMessage mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ISyncActionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SyncActionMessage message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SyncActionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.SyncActionMessage;

            /**
             * Decodes a SyncActionMessage message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SyncActionMessage
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.SyncActionMessage;

            /**
             * Verifies a SyncActionMessage message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SyncActionMessage message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SyncActionMessage
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.SyncActionMessage;

            /**
             * Crea un objeto simple desde SyncActionMessage. También convierte valores a otros tipos si se especifica.
             * @param message SyncActionMessage
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.SyncActionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SyncActionMessage a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un SyncActionMessageRange. */
        interface ISyncActionMessageRange {

            /** SyncActionMessageRange lastMessageTimestamp */
            lastMessageTimestamp?: (number|Long|null);

            /** SyncActionMessageRange lastSystemMessageTimestamp */
            lastSystemMessageTimestamp?: (number|Long|null);

            /** SyncActionMessageRange messages */
            messages?: (proto.SyncActionValue.ISyncActionMessage[]|null);
        }

        /** Representa un SyncActionMessageRange. */
        class SyncActionMessageRange implements ISyncActionMessageRange {

            /**
             * Construya un nuevo SyncActionMessageRange.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ISyncActionMessageRange);

            /** SyncActionMessageRange lastMessageTimestamp. */
            public lastMessageTimestamp: (number|Long);

            /** SyncActionMessageRange lastSystemMessageTimestamp. */
            public lastSystemMessageTimestamp: (number|Long);

            /** SyncActionMessageRange messages. */
            public messages: proto.SyncActionValue.ISyncActionMessage[];

            /**
             * Crea una nueva instancia SyncActionMessageRange utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns SyncActionMessageRange instance
             */
            public static create(properties?: proto.SyncActionValue.ISyncActionMessageRange): proto.SyncActionValue.SyncActionMessageRange;

            /**
             * Codifica el mensaje SyncActionMessageRange. No implícitamente mensajes {@link proto.SyncActionValue.SyncActionMessageRange.verify|verify}.
             * @param message SyncActionMessageRange mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ISyncActionMessageRange, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje SyncActionMessageRange message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.SyncActionMessageRange.verify|verify}.
             * @param message SyncActionMessageRange mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ISyncActionMessageRange, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SyncActionMessageRange message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns SyncActionMessageRange
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.SyncActionMessageRange;

            /**
             * Decodes a SyncActionMessageRange message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns SyncActionMessageRange
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.SyncActionMessageRange;

            /**
             * Verifies a SyncActionMessageRange message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a SyncActionMessageRange message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns SyncActionMessageRange
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.SyncActionMessageRange;

            /**
             * Crea un objeto simple desde SyncActionMessageRange. También convierte valores a otros tipos si se especifica.
             * @param message SyncActionMessageRange
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.SyncActionMessageRange, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  SyncActionMessageRange a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un TimeFormatAction. */
        interface ITimeFormatAction {

            /** TimeFormatAction isTwentyFourHourFormatEnabled */
            isTwentyFourHourFormatEnabled?: (boolean|null);
        }

        /** Representa un TimeFormatAction. */
        class TimeFormatAction implements ITimeFormatAction {

            /**
             * Construya un nuevo TimeFormatAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.ITimeFormatAction);

            /** TimeFormatAction isTwentyFourHourFormatEnabled. */
            public isTwentyFourHourFormatEnabled: boolean;

            /**
             * Crea una nueva instancia TimeFormatAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns TimeFormatAction instance
             */
            public static create(properties?: proto.SyncActionValue.ITimeFormatAction): proto.SyncActionValue.TimeFormatAction;

            /**
             * Codifica el mensaje TimeFormatAction. No implícitamente mensajes {@link proto.SyncActionValue.TimeFormatAction.verify|verify}.
             * @param message TimeFormatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.ITimeFormatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje TimeFormatAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.TimeFormatAction.verify|verify}.
             * @param message TimeFormatAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.ITimeFormatAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TimeFormatAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns TimeFormatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.TimeFormatAction;

            /**
             * Decodes a TimeFormatAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns TimeFormatAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.TimeFormatAction;

            /**
             * Verifies a TimeFormatAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a TimeFormatAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns TimeFormatAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.TimeFormatAction;

            /**
             * Crea un objeto simple desde TimeFormatAction. También convierte valores a otros tipos si se especifica.
             * @param message TimeFormatAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.TimeFormatAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  TimeFormatAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de unn UnarchiveChatsSetting. */
        interface IUnarchiveChatsSetting {

            /** UnarchiveChatsSetting unarchiveChats */
            unarchiveChats?: (boolean|null);
        }

        /** Representa unn UnarchiveChatsSetting. */
        class UnarchiveChatsSetting implements IUnarchiveChatsSetting {

            /**
             * Construya un nuevo UnarchiveChatsSetting.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IUnarchiveChatsSetting);

            /** UnarchiveChatsSetting unarchiveChats. */
            public unarchiveChats: boolean;

            /**
             * Crea una nueva instancia UnarchiveChatsSetting utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns UnarchiveChatsSetting instance
             */
            public static create(properties?: proto.SyncActionValue.IUnarchiveChatsSetting): proto.SyncActionValue.UnarchiveChatsSetting;

            /**
             * Codifica el mensaje UnarchiveChatsSetting. No implícitamente mensajes {@link proto.SyncActionValue.UnarchiveChatsSetting.verify|verify}.
             * @param message UnarchiveChatsSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IUnarchiveChatsSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje UnarchiveChatsSetting message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.UnarchiveChatsSetting.verify|verify}.
             * @param message UnarchiveChatsSetting mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IUnarchiveChatsSetting, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UnarchiveChatsSetting message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns UnarchiveChatsSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.UnarchiveChatsSetting;

            /**
             * Decodes an UnarchiveChatsSetting message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns UnarchiveChatsSetting
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.UnarchiveChatsSetting;

            /**
             * Verifies an UnarchiveChatsSetting message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates an UnarchiveChatsSetting message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns UnarchiveChatsSetting
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.UnarchiveChatsSetting;

            /**
             * Crea un objeto simple desden UnarchiveChatsSetting. También convierte valores a otros tipos si se especifica.
             * @param message UnarchiveChatsSetting
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.UnarchiveChatsSetting, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  UnarchiveChatsSetting a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un UserStatusMuteAction. */
        interface IUserStatusMuteAction {

            /** UserStatusMuteAction muted */
            muted?: (boolean|null);
        }

        /** Representa un UserStatusMuteAction. */
        class UserStatusMuteAction implements IUserStatusMuteAction {

            /**
             * Construya un nuevo UserStatusMuteAction.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.SyncActionValue.IUserStatusMuteAction);

            /** UserStatusMuteAction muted. */
            public muted: boolean;

            /**
             * Crea una nueva instancia UserStatusMuteAction utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns UserStatusMuteAction instance
             */
            public static create(properties?: proto.SyncActionValue.IUserStatusMuteAction): proto.SyncActionValue.UserStatusMuteAction;

            /**
             * Codifica el mensaje UserStatusMuteAction. No implícitamente mensajes {@link proto.SyncActionValue.UserStatusMuteAction.verify|verify}.
             * @param message UserStatusMuteAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.SyncActionValue.IUserStatusMuteAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje UserStatusMuteAction message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncActionValue.UserStatusMuteAction.verify|verify}.
             * @param message UserStatusMuteAction mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.SyncActionValue.IUserStatusMuteAction, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a UserStatusMuteAction message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns UserStatusMuteAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncActionValue.UserStatusMuteAction;

            /**
             * Decodes a UserStatusMuteAction message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns UserStatusMuteAction
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncActionValue.UserStatusMuteAction;

            /**
             * Verifies a UserStatusMuteAction message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a UserStatusMuteAction message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns UserStatusMuteAction
             */
            public static fromObject(object: { [k: string]: any }): proto.SyncActionValue.UserStatusMuteAction;

            /**
             * Crea un objeto simple desde UserStatusMuteAction. También convierte valores a otros tipos si se especifica.
             * @param message UserStatusMuteAction
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.SyncActionValue.UserStatusMuteAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  UserStatusMuteAction a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un SyncdIndex. */
    interface ISyncdIndex {

        /** SyncdIndex blob */
        blob?: (Uint8Array|null);
    }

    /** Representa un SyncdIndex. */
    class SyncdIndex implements ISyncdIndex {

        /**
         * Construya un nuevo SyncdIndex.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdIndex);

        /** SyncdIndex blob. */
        public blob: Uint8Array;

        /**
         * Crea una nueva instancia SyncdIndex utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdIndex instance
         */
        public static create(properties?: proto.ISyncdIndex): proto.SyncdIndex;

        /**
         * Codifica el mensaje SyncdIndex. No implícitamente mensajes {@link proto.SyncdIndex.verify|verify}.
         * @param message SyncdIndex mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdIndex, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdIndex message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdIndex.verify|verify}.
         * @param message SyncdIndex mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdIndex, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdIndex message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdIndex
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdIndex;

        /**
         * Decodes a SyncdIndex message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdIndex
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdIndex;

        /**
         * Verifies a SyncdIndex message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdIndex message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdIndex
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdIndex;

        /**
         * Crea un objeto simple desde SyncdIndex. También convierte valores a otros tipos si se especifica.
         * @param message SyncdIndex
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdIndex, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdIndex a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdMutation. */
    interface ISyncdMutation {

        /** SyncdMutation operation */
        operation?: (proto.SyncdMutation.SyncdOperation|null);

        /** SyncdMutation record */
        record?: (proto.ISyncdRecord|null);
    }

    /** Representa un SyncdMutation. */
    class SyncdMutation implements ISyncdMutation {

        /**
         * Construya un nuevo SyncdMutation.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdMutation);

        /** SyncdMutation operation. */
        public operation: proto.SyncdMutation.SyncdOperation;

        /** SyncdMutation record. */
        public record?: (proto.ISyncdRecord|null);

        /**
         * Crea una nueva instancia SyncdMutation utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdMutation instance
         */
        public static create(properties?: proto.ISyncdMutation): proto.SyncdMutation;

        /**
         * Codifica el mensaje SyncdMutation. No implícitamente mensajes {@link proto.SyncdMutation.verify|verify}.
         * @param message SyncdMutation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdMutation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdMutation message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdMutation.verify|verify}.
         * @param message SyncdMutation mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdMutation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdMutation message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdMutation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdMutation;

        /**
         * Decodes a SyncdMutation message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdMutation
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdMutation;

        /**
         * Verifies a SyncdMutation message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdMutation message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdMutation
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdMutation;

        /**
         * Crea un objeto simple desde SyncdMutation. También convierte valores a otros tipos si se especifica.
         * @param message SyncdMutation
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdMutation, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdMutation a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace SyncdMutation {

        /** SyncdOperation enum. */
        enum SyncdOperation {
            SET = 0,
            REMOVE = 1
        }
    }

    /** Propiedades de un SyncdMutations. */
    interface ISyncdMutations {

        /** SyncdMutations mutations */
        mutations?: (proto.ISyncdMutation[]|null);
    }

    /** Representa un SyncdMutations. */
    class SyncdMutations implements ISyncdMutations {

        /**
         * Construya un nuevo SyncdMutations.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdMutations);

        /** SyncdMutations mutations. */
        public mutations: proto.ISyncdMutation[];

        /**
         * Crea una nueva instancia SyncdMutations utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdMutations instance
         */
        public static create(properties?: proto.ISyncdMutations): proto.SyncdMutations;

        /**
         * Codifica el mensaje SyncdMutations. No implícitamente mensajes {@link proto.SyncdMutations.verify|verify}.
         * @param message SyncdMutations mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdMutations, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdMutations message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdMutations.verify|verify}.
         * @param message SyncdMutations mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdMutations, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdMutations message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdMutations
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdMutations;

        /**
         * Decodes a SyncdMutations message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdMutations
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdMutations;

        /**
         * Verifies a SyncdMutations message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdMutations message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdMutations
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdMutations;

        /**
         * Crea un objeto simple desde SyncdMutations. También convierte valores a otros tipos si se especifica.
         * @param message SyncdMutations
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdMutations, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdMutations a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdPatch. */
    interface ISyncdPatch {

        /** SyncdPatch version */
        version?: (proto.ISyncdVersion|null);

        /** SyncdPatch mutations */
        mutations?: (proto.ISyncdMutation[]|null);

        /** SyncdPatch externalMutations */
        externalMutations?: (proto.IExternalBlobReference|null);

        /** SyncdPatch snapshotMac */
        snapshotMac?: (Uint8Array|null);

        /** SyncdPatch patchMac */
        patchMac?: (Uint8Array|null);

        /** SyncdPatch keyId */
        keyId?: (proto.IKeyId|null);

        /** SyncdPatch exitCode */
        exitCode?: (proto.IExitCode|null);

        /** SyncdPatch deviceIndex */
        deviceIndex?: (number|null);
    }

    /** Representa un SyncdPatch. */
    class SyncdPatch implements ISyncdPatch {

        /**
         * Construya un nuevo SyncdPatch.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdPatch);

        /** SyncdPatch version. */
        public version?: (proto.ISyncdVersion|null);

        /** SyncdPatch mutations. */
        public mutations: proto.ISyncdMutation[];

        /** SyncdPatch externalMutations. */
        public externalMutations?: (proto.IExternalBlobReference|null);

        /** SyncdPatch snapshotMac. */
        public snapshotMac: Uint8Array;

        /** SyncdPatch patchMac. */
        public patchMac: Uint8Array;

        /** SyncdPatch keyId. */
        public keyId?: (proto.IKeyId|null);

        /** SyncdPatch exitCode. */
        public exitCode?: (proto.IExitCode|null);

        /** SyncdPatch deviceIndex. */
        public deviceIndex: number;

        /**
         * Crea una nueva instancia SyncdPatch utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdPatch instance
         */
        public static create(properties?: proto.ISyncdPatch): proto.SyncdPatch;

        /**
         * Codifica el mensaje SyncdPatch. No implícitamente mensajes {@link proto.SyncdPatch.verify|verify}.
         * @param message SyncdPatch mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdPatch, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdPatch message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdPatch.verify|verify}.
         * @param message SyncdPatch mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdPatch, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdPatch message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdPatch
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdPatch;

        /**
         * Decodes a SyncdPatch message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdPatch
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdPatch;

        /**
         * Verifies a SyncdPatch message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdPatch message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdPatch
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdPatch;

        /**
         * Crea un objeto simple desde SyncdPatch. También convierte valores a otros tipos si se especifica.
         * @param message SyncdPatch
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdPatch, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdPatch a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdRecord. */
    interface ISyncdRecord {

        /** SyncdRecord index */
        index?: (proto.ISyncdIndex|null);

        /** SyncdRecord value */
        value?: (proto.ISyncdValue|null);

        /** SyncdRecord keyId */
        keyId?: (proto.IKeyId|null);
    }

    /** Representa un SyncdRecord. */
    class SyncdRecord implements ISyncdRecord {

        /**
         * Construya un nuevo SyncdRecord.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdRecord);

        /** SyncdRecord index. */
        public index?: (proto.ISyncdIndex|null);

        /** SyncdRecord value. */
        public value?: (proto.ISyncdValue|null);

        /** SyncdRecord keyId. */
        public keyId?: (proto.IKeyId|null);

        /**
         * Crea una nueva instancia SyncdRecord utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdRecord instance
         */
        public static create(properties?: proto.ISyncdRecord): proto.SyncdRecord;

        /**
         * Codifica el mensaje SyncdRecord. No implícitamente mensajes {@link proto.SyncdRecord.verify|verify}.
         * @param message SyncdRecord mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdRecord, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdRecord message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdRecord.verify|verify}.
         * @param message SyncdRecord mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdRecord, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdRecord message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdRecord
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdRecord;

        /**
         * Decodes a SyncdRecord message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdRecord
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdRecord;

        /**
         * Verifies a SyncdRecord message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdRecord message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdRecord
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdRecord;

        /**
         * Crea un objeto simple desde SyncdRecord. También convierte valores a otros tipos si se especifica.
         * @param message SyncdRecord
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdRecord, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdRecord a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdSnapshot. */
    interface ISyncdSnapshot {

        /** SyncdSnapshot version */
        version?: (proto.ISyncdVersion|null);

        /** SyncdSnapshot records */
        records?: (proto.ISyncdRecord[]|null);

        /** SyncdSnapshot mac */
        mac?: (Uint8Array|null);

        /** SyncdSnapshot keyId */
        keyId?: (proto.IKeyId|null);
    }

    /** Representa un SyncdSnapshot. */
    class SyncdSnapshot implements ISyncdSnapshot {

        /**
         * Construya un nuevo SyncdSnapshot.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdSnapshot);

        /** SyncdSnapshot version. */
        public version?: (proto.ISyncdVersion|null);

        /** SyncdSnapshot records. */
        public records: proto.ISyncdRecord[];

        /** SyncdSnapshot mac. */
        public mac: Uint8Array;

        /** SyncdSnapshot keyId. */
        public keyId?: (proto.IKeyId|null);

        /**
         * Crea una nueva instancia SyncdSnapshot utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdSnapshot instance
         */
        public static create(properties?: proto.ISyncdSnapshot): proto.SyncdSnapshot;

        /**
         * Codifica el mensaje SyncdSnapshot. No implícitamente mensajes {@link proto.SyncdSnapshot.verify|verify}.
         * @param message SyncdSnapshot mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdSnapshot message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdSnapshot.verify|verify}.
         * @param message SyncdSnapshot mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdSnapshot, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdSnapshot message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdSnapshot
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdSnapshot;

        /**
         * Decodes a SyncdSnapshot message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdSnapshot
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdSnapshot;

        /**
         * Verifies a SyncdSnapshot message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdSnapshot message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdSnapshot
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdSnapshot;

        /**
         * Crea un objeto simple desde SyncdSnapshot. También convierte valores a otros tipos si se especifica.
         * @param message SyncdSnapshot
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdSnapshot, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdSnapshot a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdValue. */
    interface ISyncdValue {

        /** SyncdValue blob */
        blob?: (Uint8Array|null);
    }

    /** Representa un SyncdValue. */
    class SyncdValue implements ISyncdValue {

        /**
         * Construya un nuevo SyncdValue.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdValue);

        /** SyncdValue blob. */
        public blob: Uint8Array;

        /**
         * Crea una nueva instancia SyncdValue utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdValue instance
         */
        public static create(properties?: proto.ISyncdValue): proto.SyncdValue;

        /**
         * Codifica el mensaje SyncdValue. No implícitamente mensajes {@link proto.SyncdValue.verify|verify}.
         * @param message SyncdValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdValue message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdValue.verify|verify}.
         * @param message SyncdValue mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdValue, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdValue message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdValue;

        /**
         * Decodes a SyncdValue message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdValue
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdValue;

        /**
         * Verifies a SyncdValue message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdValue message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdValue
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdValue;

        /**
         * Crea un objeto simple desde SyncdValue. También convierte valores a otros tipos si se especifica.
         * @param message SyncdValue
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdValue, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdValue a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un SyncdVersion. */
    interface ISyncdVersion {

        /** SyncdVersion version */
        version?: (number|Long|null);
    }

    /** Representa un SyncdVersion. */
    class SyncdVersion implements ISyncdVersion {

        /**
         * Construya un nuevo SyncdVersion.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ISyncdVersion);

        /** SyncdVersion version. */
        public version: (number|Long);

        /**
         * Crea una nueva instancia SyncdVersion utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns SyncdVersion instance
         */
        public static create(properties?: proto.ISyncdVersion): proto.SyncdVersion;

        /**
         * Codifica el mensaje SyncdVersion. No implícitamente mensajes {@link proto.SyncdVersion.verify|verify}.
         * @param message SyncdVersion mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ISyncdVersion, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje SyncdVersion message, delimitado por longitud. No implícitamente mensajes {@link proto.SyncdVersion.verify|verify}.
         * @param message SyncdVersion mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISyncdVersion, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SyncdVersion message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns SyncdVersion
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SyncdVersion;

        /**
         * Decodes a SyncdVersion message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns SyncdVersion
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SyncdVersion;

        /**
         * Verifies a SyncdVersion message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SyncdVersion message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns SyncdVersion
         */
        public static fromObject(object: { [k: string]: any }): proto.SyncdVersion;

        /**
         * Crea un objeto simple desde SyncdVersion. También convierte valores a otros tipos si se especifica.
         * @param message SyncdVersion
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.SyncdVersion, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  SyncdVersion a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un TemplateButton. */
    interface ITemplateButton {

        /** TemplateButton index */
        index?: (number|null);

        /** TemplateButton quickReplyButton */
        quickReplyButton?: (proto.TemplateButton.IQuickReplyButton|null);

        /** TemplateButton urlButton */
        urlButton?: (proto.TemplateButton.IURLButton|null);

        /** TemplateButton callButton */
        callButton?: (proto.TemplateButton.ICallButton|null);
    }

    /** Representa un TemplateButton. */
    class TemplateButton implements ITemplateButton {

        /**
         * Construya un nuevo TemplateButton.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.ITemplateButton);

        /** TemplateButton index. */
        public index: number;

        /** TemplateButton quickReplyButton. */
        public quickReplyButton?: (proto.TemplateButton.IQuickReplyButton|null);

        /** TemplateButton urlButton. */
        public urlButton?: (proto.TemplateButton.IURLButton|null);

        /** TemplateButton callButton. */
        public callButton?: (proto.TemplateButton.ICallButton|null);

        /** TemplateButton button. */
        public button?: ("quickReplyButton"|"urlButton"|"callButton");

        /**
         * Crea una nueva instancia TemplateButton utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns TemplateButton instance
         */
        public static create(properties?: proto.ITemplateButton): proto.TemplateButton;

        /**
         * Codifica el mensaje TemplateButton. No implícitamente mensajes {@link proto.TemplateButton.verify|verify}.
         * @param message TemplateButton mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.ITemplateButton, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje TemplateButton message, delimitado por longitud. No implícitamente mensajes {@link proto.TemplateButton.verify|verify}.
         * @param message TemplateButton mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITemplateButton, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TemplateButton message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns TemplateButton
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TemplateButton;

        /**
         * Decodes a TemplateButton message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns TemplateButton
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TemplateButton;

        /**
         * Verifies a TemplateButton message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TemplateButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns TemplateButton
         */
        public static fromObject(object: { [k: string]: any }): proto.TemplateButton;

        /**
         * Crea un objeto simple desde TemplateButton. También convierte valores a otros tipos si se especifica.
         * @param message TemplateButton
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.TemplateButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  TemplateButton a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace TemplateButton {

        /** Propiedades de un CallButton. */
        interface ICallButton {

            /** CallButton displayText */
            displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** CallButton phoneNumber */
            phoneNumber?: (proto.Message.IHighlyStructuredMessage|null);
        }

        /** Representa un CallButton. */
        class CallButton implements ICallButton {

            /**
             * Construya un nuevo CallButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.TemplateButton.ICallButton);

            /** CallButton displayText. */
            public displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** CallButton phoneNumber. */
            public phoneNumber?: (proto.Message.IHighlyStructuredMessage|null);

            /**
             * Crea una nueva instancia CallButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns CallButton instance
             */
            public static create(properties?: proto.TemplateButton.ICallButton): proto.TemplateButton.CallButton;

            /**
             * Codifica el mensaje CallButton. No implícitamente mensajes {@link proto.TemplateButton.CallButton.verify|verify}.
             * @param message CallButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.TemplateButton.ICallButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje CallButton message, delimitado por longitud. No implícitamente mensajes {@link proto.TemplateButton.CallButton.verify|verify}.
             * @param message CallButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.TemplateButton.ICallButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CallButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns CallButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TemplateButton.CallButton;

            /**
             * Decodes a CallButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns CallButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TemplateButton.CallButton;

            /**
             * Verifies a CallButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a CallButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns CallButton
             */
            public static fromObject(object: { [k: string]: any }): proto.TemplateButton.CallButton;

            /**
             * Crea un objeto simple desde CallButton. También convierte valores a otros tipos si se especifica.
             * @param message CallButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.TemplateButton.CallButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  CallButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un QuickReplyButton. */
        interface IQuickReplyButton {

            /** QuickReplyButton displayText */
            displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** QuickReplyButton id */
            id?: (string|null);
        }

        /** Representa un QuickReplyButton. */
        class QuickReplyButton implements IQuickReplyButton {

            /**
             * Construya un nuevo QuickReplyButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.TemplateButton.IQuickReplyButton);

            /** QuickReplyButton displayText. */
            public displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** QuickReplyButton id. */
            public id: string;

            /**
             * Crea una nueva instancia QuickReplyButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns QuickReplyButton instance
             */
            public static create(properties?: proto.TemplateButton.IQuickReplyButton): proto.TemplateButton.QuickReplyButton;

            /**
             * Codifica el mensaje QuickReplyButton. No implícitamente mensajes {@link proto.TemplateButton.QuickReplyButton.verify|verify}.
             * @param message QuickReplyButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.TemplateButton.IQuickReplyButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje QuickReplyButton message, delimitado por longitud. No implícitamente mensajes {@link proto.TemplateButton.QuickReplyButton.verify|verify}.
             * @param message QuickReplyButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.TemplateButton.IQuickReplyButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a QuickReplyButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns QuickReplyButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TemplateButton.QuickReplyButton;

            /**
             * Decodes a QuickReplyButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns QuickReplyButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TemplateButton.QuickReplyButton;

            /**
             * Verifies a QuickReplyButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a QuickReplyButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns QuickReplyButton
             */
            public static fromObject(object: { [k: string]: any }): proto.TemplateButton.QuickReplyButton;

            /**
             * Crea un objeto simple desde QuickReplyButton. También convierte valores a otros tipos si se especifica.
             * @param message QuickReplyButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.TemplateButton.QuickReplyButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  QuickReplyButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Propiedades de un URLButton. */
        interface IURLButton {

            /** URLButton displayText */
            displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** URLButton url */
            url?: (proto.Message.IHighlyStructuredMessage|null);
        }

        /** Representa un URLButton. */
        class URLButton implements IURLButton {

            /**
             * Construya un nuevo URLButton.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.TemplateButton.IURLButton);

            /** URLButton displayText. */
            public displayText?: (proto.Message.IHighlyStructuredMessage|null);

            /** URLButton url. */
            public url?: (proto.Message.IHighlyStructuredMessage|null);

            /**
             * Crea una nueva instancia URLButton utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns URLButton instance
             */
            public static create(properties?: proto.TemplateButton.IURLButton): proto.TemplateButton.URLButton;

            /**
             * Codifica el mensaje URLButton. No implícitamente mensajes {@link proto.TemplateButton.URLButton.verify|verify}.
             * @param message URLButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.TemplateButton.IURLButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje URLButton message, delimitado por longitud. No implícitamente mensajes {@link proto.TemplateButton.URLButton.verify|verify}.
             * @param message URLButton mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.TemplateButton.IURLButton, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a URLButton message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns URLButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TemplateButton.URLButton;

            /**
             * Decodes a URLButton message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns URLButton
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TemplateButton.URLButton;

            /**
             * Verifies a URLButton message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a URLButton message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns URLButton
             */
            public static fromObject(object: { [k: string]: any }): proto.TemplateButton.URLButton;

            /**
             * Crea un objeto simple desde URLButton. También convierte valores a otros tipos si se especifica.
             * @param message URLButton
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.TemplateButton.URLButton, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  URLButton a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un UserReceipt. */
    interface IUserReceipt {

        /** UserReceipt userJid */
        userJid: string;

        /** UserReceipt receiptTimestamp */
        receiptTimestamp?: (number|Long|null);

        /** UserReceipt readTimestamp */
        readTimestamp?: (number|Long|null);

        /** UserReceipt playedTimestamp */
        playedTimestamp?: (number|Long|null);

        /** UserReceipt pendingDeviceJid */
        pendingDeviceJid?: (string[]|null);

        /** UserReceipt deliveredDeviceJid */
        deliveredDeviceJid?: (string[]|null);
    }

    /** Representa un UserReceipt. */
    class UserReceipt implements IUserReceipt {

        /**
         * Construya un nuevo UserReceipt.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IUserReceipt);

        /** UserReceipt userJid. */
        public userJid: string;

        /** UserReceipt receiptTimestamp. */
        public receiptTimestamp: (number|Long);

        /** UserReceipt readTimestamp. */
        public readTimestamp: (number|Long);

        /** UserReceipt playedTimestamp. */
        public playedTimestamp: (number|Long);

        /** UserReceipt pendingDeviceJid. */
        public pendingDeviceJid: string[];

        /** UserReceipt deliveredDeviceJid. */
        public deliveredDeviceJid: string[];

        /**
         * Crea una nueva instancia UserReceipt utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns UserReceipt instance
         */
        public static create(properties?: proto.IUserReceipt): proto.UserReceipt;

        /**
         * Codifica el mensaje UserReceipt. No implícitamente mensajes {@link proto.UserReceipt.verify|verify}.
         * @param message UserReceipt mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IUserReceipt, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje UserReceipt message, delimitado por longitud. No implícitamente mensajes {@link proto.UserReceipt.verify|verify}.
         * @param message UserReceipt mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IUserReceipt, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a UserReceipt message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns UserReceipt
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.UserReceipt;

        /**
         * Decodes a UserReceipt message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns UserReceipt
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.UserReceipt;

        /**
         * Verifies a UserReceipt message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a UserReceipt message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns UserReceipt
         */
        public static fromObject(object: { [k: string]: any }): proto.UserReceipt;

        /**
         * Crea un objeto simple desde UserReceipt. También convierte valores a otros tipos si se especifica.
         * @param message UserReceipt
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.UserReceipt, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  UserReceipt a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un VerifiedNameCertificate. */
    interface IVerifiedNameCertificate {

        /** VerifiedNameCertificate details */
        details?: (Uint8Array|null);

        /** VerifiedNameCertificate signature */
        signature?: (Uint8Array|null);

        /** VerifiedNameCertificate serverSignature */
        serverSignature?: (Uint8Array|null);
    }

    /** Representa un VerifiedNameCertificate. */
    class VerifiedNameCertificate implements IVerifiedNameCertificate {

        /**
         * Construya un nuevo VerifiedNameCertificate.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IVerifiedNameCertificate);

        /** VerifiedNameCertificate details. */
        public details: Uint8Array;

        /** VerifiedNameCertificate signature. */
        public signature: Uint8Array;

        /** VerifiedNameCertificate serverSignature. */
        public serverSignature: Uint8Array;

        /**
         * Crea una nueva instancia VerifiedNameCertificate utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns VerifiedNameCertificate instance
         */
        public static create(properties?: proto.IVerifiedNameCertificate): proto.VerifiedNameCertificate;

        /**
         * Codifica el mensaje VerifiedNameCertificate. No implícitamente mensajes {@link proto.VerifiedNameCertificate.verify|verify}.
         * @param message VerifiedNameCertificate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IVerifiedNameCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje VerifiedNameCertificate message, delimitado por longitud. No implícitamente mensajes {@link proto.VerifiedNameCertificate.verify|verify}.
         * @param message VerifiedNameCertificate mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IVerifiedNameCertificate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a VerifiedNameCertificate message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns VerifiedNameCertificate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.VerifiedNameCertificate;

        /**
         * Decodes a VerifiedNameCertificate message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns VerifiedNameCertificate
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.VerifiedNameCertificate;

        /**
         * Verifies a VerifiedNameCertificate message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a VerifiedNameCertificate message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns VerifiedNameCertificate
         */
        public static fromObject(object: { [k: string]: any }): proto.VerifiedNameCertificate;

        /**
         * Crea un objeto simple desde VerifiedNameCertificate. También convierte valores a otros tipos si se especifica.
         * @param message VerifiedNameCertificate
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.VerifiedNameCertificate, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  VerifiedNameCertificate a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace VerifiedNameCertificate {

        /** Propiedades de un Details. */
        interface IDetails {

            /** Details serial */
            serial?: (number|Long|null);

            /** Details issuer */
            issuer?: (string|null);

            /** Details verifiedName */
            verifiedName?: (string|null);

            /** Details localizedNames */
            localizedNames?: (proto.ILocalizedName[]|null);

            /** Details issueTime */
            issueTime?: (number|Long|null);
        }

        /** Representa un Details. */
        class Details implements IDetails {

            /**
             * Construya un nuevo Details.
             * @param [properties] para establecer propiedades
             */
            constructor(properties?: proto.VerifiedNameCertificate.IDetails);

            /** Details serial. */
            public serial: (number|Long);

            /** Details issuer. */
            public issuer: string;

            /** Details verifiedName. */
            public verifiedName: string;

            /** Details localizedNames. */
            public localizedNames: proto.ILocalizedName[];

            /** Details issueTime. */
            public issueTime: (number|Long);

            /**
             * Crea una nueva instancia Details utilizando las propiedades especificadas.
             * @param [properties] para establecer propiedades
             * @returns Details instance
             */
            public static create(properties?: proto.VerifiedNameCertificate.IDetails): proto.VerifiedNameCertificate.Details;

            /**
             * Codifica el mensaje Details. No implícitamente mensajes {@link proto.VerifiedNameCertificate.Details.verify|verify}.
             * @param message Details mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encode(message: proto.VerifiedNameCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Codifica el mensaje Details message, delimitado por longitud. No implícitamente mensajes {@link proto.VerifiedNameCertificate.Details.verify|verify}.
             * @param message Details mensaje o objeto simple para codificar
             * @param [writer] Writer para codificar a
             * @returns Writer
             */
            public static encodeDelimited(message: proto.VerifiedNameCertificate.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Details message from the specified reader or buffer.
             * @param reader Reader o búfer para decodificar desde
             * @param [length] Longitud del mensaje si se conoce de antemano
             * @returns Details
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.VerifiedNameCertificate.Details;

            /**
             * Decodes a Details message desde el especifico lector o búfer, longitud delimitada.
             * @param reader Reader o búfer para decodificar desde
             * @returns Details
             * @throws {Error} Si la carga útil no es un lector o un búfer válido
             * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.VerifiedNameCertificate.Details;

            /**
             * Verifies a Details message.
             * @param message Objeto simple para verificar
             * @returns `null` Si es válido, de lo contrario la razón por la que no es
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Details message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
             * @param object Objeto simple
             * @returns Details
             */
            public static fromObject(object: { [k: string]: any }): proto.VerifiedNameCertificate.Details;

            /**
             * Crea un objeto simple desde Details. También convierte valores a otros tipos si se especifica.
             * @param message Details
             * @param [options] Opciones de conversión
             * @returns Objeto simple
             */
            public static toObject(message: proto.VerifiedNameCertificate.Details, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Convierte este  Details a JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /** Propiedades de un WallpaperSettings. */
    interface IWallpaperSettings {

        /** WallpaperSettings filename */
        filename?: (string|null);

        /** WallpaperSettings opacity */
        opacity?: (number|null);
    }

    /** Representa un WallpaperSettings. */
    class WallpaperSettings implements IWallpaperSettings {

        /**
         * Construya un nuevo WallpaperSettings.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IWallpaperSettings);

        /** WallpaperSettings filename. */
        public filename: string;

        /** WallpaperSettings opacity. */
        public opacity: number;

        /**
         * Crea una nueva instancia WallpaperSettings utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns WallpaperSettings instance
         */
        public static create(properties?: proto.IWallpaperSettings): proto.WallpaperSettings;

        /**
         * Codifica el mensaje WallpaperSettings. No implícitamente mensajes {@link proto.WallpaperSettings.verify|verify}.
         * @param message WallpaperSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IWallpaperSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje WallpaperSettings message, delimitado por longitud. No implícitamente mensajes {@link proto.WallpaperSettings.verify|verify}.
         * @param message WallpaperSettings mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IWallpaperSettings, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a WallpaperSettings message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns WallpaperSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.WallpaperSettings;

        /**
         * Decodes a WallpaperSettings message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns WallpaperSettings
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.WallpaperSettings;

        /**
         * Verifies a WallpaperSettings message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a WallpaperSettings message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns WallpaperSettings
         */
        public static fromObject(object: { [k: string]: any }): proto.WallpaperSettings;

        /**
         * Crea un objeto simple desde WallpaperSettings. También convierte valores a otros tipos si se especifica.
         * @param message WallpaperSettings
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.WallpaperSettings, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  WallpaperSettings a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Propiedades de un WebFeatures. */
    interface IWebFeatures {

        /** WebFeatures labelsDisplay */
        labelsDisplay?: (proto.WebFeatures.Flag|null);

        /** WebFeatures voipIndividualOutgoing */
        voipIndividualOutgoing?: (proto.WebFeatures.Flag|null);

        /** WebFeatures groupsV3 */
        groupsV3?: (proto.WebFeatures.Flag|null);

        /** WebFeatures groupsV3Create */
        groupsV3Create?: (proto.WebFeatures.Flag|null);

        /** WebFeatures changeNumberV2 */
        changeNumberV2?: (proto.WebFeatures.Flag|null);

        /** WebFeatures queryStatusV3Thumbnail */
        queryStatusV3Thumbnail?: (proto.WebFeatures.Flag|null);

        /** WebFeatures liveLocations */
        liveLocations?: (proto.WebFeatures.Flag|null);

        /** WebFeatures queryVname */
        queryVname?: (proto.WebFeatures.Flag|null);

        /** WebFeatures voipIndividualIncoming */
        voipIndividualIncoming?: (proto.WebFeatures.Flag|null);

        /** WebFeatures quickRepliesQuery */
        quickRepliesQuery?: (proto.WebFeatures.Flag|null);

        /** WebFeatures payments */
        payments?: (proto.WebFeatures.Flag|null);

        /** WebFeatures stickerPackQuery */
        stickerPackQuery?: (proto.WebFeatures.Flag|null);

        /** WebFeatures liveLocationsFinal */
        liveLocationsFinal?: (proto.WebFeatures.Flag|null);

        /** WebFeatures labelsEdit */
        labelsEdit?: (proto.WebFeatures.Flag|null);

        /** WebFeatures mediaUpload */
        mediaUpload?: (proto.WebFeatures.Flag|null);

        /** WebFeatures mediaUploadRichQuickReplies */
        mediaUploadRichQuickReplies?: (proto.WebFeatures.Flag|null);

        /** WebFeatures vnameV2 */
        vnameV2?: (proto.WebFeatures.Flag|null);

        /** WebFeatures videoPlaybackUrl */
        videoPlaybackUrl?: (proto.WebFeatures.Flag|null);

        /** WebFeatures statusRanking */
        statusRanking?: (proto.WebFeatures.Flag|null);

        /** WebFeatures voipIndividualVideo */
        voipIndividualVideo?: (proto.WebFeatures.Flag|null);

        /** WebFeatures thirdPartyStickers */
        thirdPartyStickers?: (proto.WebFeatures.Flag|null);

        /** WebFeatures frequentlyForwardedSetting */
        frequentlyForwardedSetting?: (proto.WebFeatures.Flag|null);

        /** WebFeatures groupsV4JoinPermission */
        groupsV4JoinPermission?: (proto.WebFeatures.Flag|null);

        /** WebFeatures recentStickers */
        recentStickers?: (proto.WebFeatures.Flag|null);

        /** WebFeatures catalog */
        catalog?: (proto.WebFeatures.Flag|null);

        /** WebFeatures starredStickers */
        starredStickers?: (proto.WebFeatures.Flag|null);

        /** WebFeatures voipGroupCall */
        voipGroupCall?: (proto.WebFeatures.Flag|null);

        /** WebFeatures templateMessage */
        templateMessage?: (proto.WebFeatures.Flag|null);

        /** WebFeatures templateMessageInteractivity */
        templateMessageInteractivity?: (proto.WebFeatures.Flag|null);

        /** WebFeatures ephemeralMessages */
        ephemeralMessages?: (proto.WebFeatures.Flag|null);

        /** WebFeatures e2ENotificationSync */
        e2ENotificationSync?: (proto.WebFeatures.Flag|null);

        /** WebFeatures recentStickersV2 */
        recentStickersV2?: (proto.WebFeatures.Flag|null);

        /** WebFeatures recentStickersV3 */
        recentStickersV3?: (proto.WebFeatures.Flag|null);

        /** WebFeatures userNotice */
        userNotice?: (proto.WebFeatures.Flag|null);

        /** WebFeatures support */
        support?: (proto.WebFeatures.Flag|null);

        /** WebFeatures groupUiiCleanup */
        groupUiiCleanup?: (proto.WebFeatures.Flag|null);

        /** WebFeatures groupDogfoodingInternalOnly */
        groupDogfoodingInternalOnly?: (proto.WebFeatures.Flag|null);

        /** WebFeatures settingsSync */
        settingsSync?: (proto.WebFeatures.Flag|null);

        /** WebFeatures archiveV2 */
        archiveV2?: (proto.WebFeatures.Flag|null);

        /** WebFeatures ephemeralAllowGroupMembers */
        ephemeralAllowGroupMembers?: (proto.WebFeatures.Flag|null);

        /** WebFeatures ephemeral24HDuration */
        ephemeral24HDuration?: (proto.WebFeatures.Flag|null);

        /** WebFeatures mdForceUpgrade */
        mdForceUpgrade?: (proto.WebFeatures.Flag|null);

        /** WebFeatures disappearingMode */
        disappearingMode?: (proto.WebFeatures.Flag|null);

        /** WebFeatures externalMdOptInAvailable */
        externalMdOptInAvailable?: (proto.WebFeatures.Flag|null);

        /** WebFeatures noDeleteMessageTimeLimit */
        noDeleteMessageTimeLimit?: (proto.WebFeatures.Flag|null);
    }

    /** Representa un WebFeatures. */
    class WebFeatures implements IWebFeatures {

        /**
         * Construya un nuevo WebFeatures.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IWebFeatures);

        /** WebFeatures labelsDisplay. */
        public labelsDisplay: proto.WebFeatures.Flag;

        /** WebFeatures voipIndividualOutgoing. */
        public voipIndividualOutgoing: proto.WebFeatures.Flag;

        /** WebFeatures groupsV3. */
        public groupsV3: proto.WebFeatures.Flag;

        /** WebFeatures groupsV3Create. */
        public groupsV3Create: proto.WebFeatures.Flag;

        /** WebFeatures changeNumberV2. */
        public changeNumberV2: proto.WebFeatures.Flag;

        /** WebFeatures queryStatusV3Thumbnail. */
        public queryStatusV3Thumbnail: proto.WebFeatures.Flag;

        /** WebFeatures liveLocations. */
        public liveLocations: proto.WebFeatures.Flag;

        /** WebFeatures queryVname. */
        public queryVname: proto.WebFeatures.Flag;

        /** WebFeatures voipIndividualIncoming. */
        public voipIndividualIncoming: proto.WebFeatures.Flag;

        /** WebFeatures quickRepliesQuery. */
        public quickRepliesQuery: proto.WebFeatures.Flag;

        /** WebFeatures payments. */
        public payments: proto.WebFeatures.Flag;

        /** WebFeatures stickerPackQuery. */
        public stickerPackQuery: proto.WebFeatures.Flag;

        /** WebFeatures liveLocationsFinal. */
        public liveLocationsFinal: proto.WebFeatures.Flag;

        /** WebFeatures labelsEdit. */
        public labelsEdit: proto.WebFeatures.Flag;

        /** WebFeatures mediaUpload. */
        public mediaUpload: proto.WebFeatures.Flag;

        /** WebFeatures mediaUploadRichQuickReplies. */
        public mediaUploadRichQuickReplies: proto.WebFeatures.Flag;

        /** WebFeatures vnameV2. */
        public vnameV2: proto.WebFeatures.Flag;

        /** WebFeatures videoPlaybackUrl. */
        public videoPlaybackUrl: proto.WebFeatures.Flag;

        /** WebFeatures statusRanking. */
        public statusRanking: proto.WebFeatures.Flag;

        /** WebFeatures voipIndividualVideo. */
        public voipIndividualVideo: proto.WebFeatures.Flag;

        /** WebFeatures thirdPartyStickers. */
        public thirdPartyStickers: proto.WebFeatures.Flag;

        /** WebFeatures frequentlyForwardedSetting. */
        public frequentlyForwardedSetting: proto.WebFeatures.Flag;

        /** WebFeatures groupsV4JoinPermission. */
        public groupsV4JoinPermission: proto.WebFeatures.Flag;

        /** WebFeatures recentStickers. */
        public recentStickers: proto.WebFeatures.Flag;

        /** WebFeatures catalog. */
        public catalog: proto.WebFeatures.Flag;

        /** WebFeatures starredStickers. */
        public starredStickers: proto.WebFeatures.Flag;

        /** WebFeatures voipGroupCall. */
        public voipGroupCall: proto.WebFeatures.Flag;

        /** WebFeatures templateMessage. */
        public templateMessage: proto.WebFeatures.Flag;

        /** WebFeatures templateMessageInteractivity. */
        public templateMessageInteractivity: proto.WebFeatures.Flag;

        /** WebFeatures ephemeralMessages. */
        public ephemeralMessages: proto.WebFeatures.Flag;

        /** WebFeatures e2ENotificationSync. */
        public e2ENotificationSync: proto.WebFeatures.Flag;

        /** WebFeatures recentStickersV2. */
        public recentStickersV2: proto.WebFeatures.Flag;

        /** WebFeatures recentStickersV3. */
        public recentStickersV3: proto.WebFeatures.Flag;

        /** WebFeatures userNotice. */
        public userNotice: proto.WebFeatures.Flag;

        /** WebFeatures support. */
        public support: proto.WebFeatures.Flag;

        /** WebFeatures groupUiiCleanup. */
        public groupUiiCleanup: proto.WebFeatures.Flag;

        /** WebFeatures groupDogfoodingInternalOnly. */
        public groupDogfoodingInternalOnly: proto.WebFeatures.Flag;

        /** WebFeatures settingsSync. */
        public settingsSync: proto.WebFeatures.Flag;

        /** WebFeatures archiveV2. */
        public archiveV2: proto.WebFeatures.Flag;

        /** WebFeatures ephemeralAllowGroupMembers. */
        public ephemeralAllowGroupMembers: proto.WebFeatures.Flag;

        /** WebFeatures ephemeral24HDuration. */
        public ephemeral24HDuration: proto.WebFeatures.Flag;

        /** WebFeatures mdForceUpgrade. */
        public mdForceUpgrade: proto.WebFeatures.Flag;

        /** WebFeatures disappearingMode. */
        public disappearingMode: proto.WebFeatures.Flag;

        /** WebFeatures externalMdOptInAvailable. */
        public externalMdOptInAvailable: proto.WebFeatures.Flag;

        /** WebFeatures noDeleteMessageTimeLimit. */
        public noDeleteMessageTimeLimit: proto.WebFeatures.Flag;

        /**
         * Crea una nueva instancia WebFeatures utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns WebFeatures instance
         */
        public static create(properties?: proto.IWebFeatures): proto.WebFeatures;

        /**
         * Codifica el mensaje WebFeatures. No implícitamente mensajes {@link proto.WebFeatures.verify|verify}.
         * @param message WebFeatures mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IWebFeatures, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje WebFeatures message, delimitado por longitud. No implícitamente mensajes {@link proto.WebFeatures.verify|verify}.
         * @param message WebFeatures mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IWebFeatures, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a WebFeatures message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns WebFeatures
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.WebFeatures;

        /**
         * Decodes a WebFeatures message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns WebFeatures
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.WebFeatures;

        /**
         * Verifies a WebFeatures message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a WebFeatures message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns WebFeatures
         */
        public static fromObject(object: { [k: string]: any }): proto.WebFeatures;

        /**
         * Crea un objeto simple desde WebFeatures. También convierte valores a otros tipos si se especifica.
         * @param message WebFeatures
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.WebFeatures, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  WebFeatures a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace WebFeatures {

        /** Flag enum. */
        enum Flag {
            NOT_STARTED = 0,
            FORCE_UPGRADE = 1,
            DEVELOPMENT = 2,
            PRODUCTION = 3
        }
    }

    /** Propiedades de un WebMessageInfo. */
    interface IWebMessageInfo {

        /** WebMessageInfo key */
        key: proto.IMessageKey;

        /** WebMessageInfo message */
        message?: (proto.IMessage|null);

        /** WebMessageInfo messageTimestamp */
        messageTimestamp?: (number|Long|null);

        /** WebMessageInfo status */
        status?: (proto.WebMessageInfo.Status|null);

        /** WebMessageInfo participant */
        participant?: (string|null);

        /** WebMessageInfo messageC2STimestamp */
        messageC2STimestamp?: (number|Long|null);

        /** WebMessageInfo ignore */
        ignore?: (boolean|null);

        /** WebMessageInfo starred */
        starred?: (boolean|null);

        /** WebMessageInfo broadcast */
        broadcast?: (boolean|null);

        /** WebMessageInfo pushName */
        pushName?: (string|null);

        /** WebMessageInfo mediaCiphertextSha256 */
        mediaCiphertextSha256?: (Uint8Array|null);

        /** WebMessageInfo multicast */
        multicast?: (boolean|null);

        /** WebMessageInfo urlText */
        urlText?: (boolean|null);

        /** WebMessageInfo urlNumber */
        urlNumber?: (boolean|null);

        /** WebMessageInfo messageStubType */
        messageStubType?: (proto.WebMessageInfo.StubType|null);

        /** WebMessageInfo clearMedia */
        clearMedia?: (boolean|null);

        /** WebMessageInfo messageStubParameters */
        messageStubParameters?: (string[]|null);

        /** WebMessageInfo duration */
        duration?: (number|null);

        /** WebMessageInfo labels */
        labels?: (string[]|null);

        /** WebMessageInfo paymentInfo */
        paymentInfo?: (proto.IPaymentInfo|null);

        /** WebMessageInfo finalLiveLocation */
        finalLiveLocation?: (proto.Message.ILiveLocationMessage|null);

        /** WebMessageInfo quotedPaymentInfo */
        quotedPaymentInfo?: (proto.IPaymentInfo|null);

        /** WebMessageInfo ephemeralStartTimestamp */
        ephemeralStartTimestamp?: (number|Long|null);

        /** WebMessageInfo ephemeralDuration */
        ephemeralDuration?: (number|null);

        /** WebMessageInfo ephemeralOffToOn */
        ephemeralOffToOn?: (boolean|null);

        /** WebMessageInfo ephemeralOutOfSync */
        ephemeralOutOfSync?: (boolean|null);

        /** WebMessageInfo bizPrivacyStatus */
        bizPrivacyStatus?: (proto.WebMessageInfo.BizPrivacyStatus|null);

        /** WebMessageInfo verifiedBizName */
        verifiedBizName?: (string|null);

        /** WebMessageInfo mediaData */
        mediaData?: (proto.IMediaData|null);

        /** WebMessageInfo photoChange */
        photoChange?: (proto.IPhotoChange|null);

        /** WebMessageInfo userReceipt */
        userReceipt?: (proto.IUserReceipt[]|null);

        /** WebMessageInfo reactions */
        reactions?: (proto.IReaction[]|null);

        /** WebMessageInfo quotedStickerData */
        quotedStickerData?: (proto.IMediaData|null);

        /** WebMessageInfo futureproofData */
        futureproofData?: (Uint8Array|null);

        /** WebMessageInfo statusPsa */
        statusPsa?: (proto.IStatusPSA|null);

        /** WebMessageInfo pollUpdates */
        pollUpdates?: (proto.IPollUpdate[]|null);

        /** WebMessageInfo pollAdditionalMetadata */
        pollAdditionalMetadata?: (proto.IPollAdditionalMetadata|null);

        /** WebMessageInfo agentId */
        agentId?: (string|null);

        /** WebMessageInfo statusAlreadyViewed */
        statusAlreadyViewed?: (boolean|null);

        /** WebMessageInfo messageSecret */
        messageSecret?: (Uint8Array|null);

        /** WebMessageInfo keepInChat */
        keepInChat?: (proto.IKeepInChat|null);

        /** WebMessageInfo originalSelfAuthorUserJidString */
        originalSelfAuthorUserJidString?: (string|null);

        /** WebMessageInfo revokeMessageTimestamp */
        revokeMessageTimestamp?: (number|Long|null);
    }

    /** Representa un WebMessageInfo. */
    class WebMessageInfo implements IWebMessageInfo {

        /**
         * Construya un nuevo WebMessageInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IWebMessageInfo);

        /** WebMessageInfo key. */
        public key: proto.IMessageKey;

        /** WebMessageInfo message. */
        public message?: (proto.IMessage|null);

        /** WebMessageInfo messageTimestamp. */
        public messageTimestamp: (number|Long);

        /** WebMessageInfo status. */
        public status: proto.WebMessageInfo.Status;

        /** WebMessageInfo participant. */
        public participant: string;

        /** WebMessageInfo messageC2STimestamp. */
        public messageC2STimestamp: (number|Long);

        /** WebMessageInfo ignore. */
        public ignore: boolean;

        /** WebMessageInfo starred. */
        public starred: boolean;

        /** WebMessageInfo broadcast. */
        public broadcast: boolean;

        /** WebMessageInfo pushName. */
        public pushName: string;

        /** WebMessageInfo mediaCiphertextSha256. */
        public mediaCiphertextSha256: Uint8Array;

        /** WebMessageInfo multicast. */
        public multicast: boolean;

        /** WebMessageInfo urlText. */
        public urlText: boolean;

        /** WebMessageInfo urlNumber. */
        public urlNumber: boolean;

        /** WebMessageInfo messageStubType. */
        public messageStubType: proto.WebMessageInfo.StubType;

        /** WebMessageInfo clearMedia. */
        public clearMedia: boolean;

        /** WebMessageInfo messageStubParameters. */
        public messageStubParameters: string[];

        /** WebMessageInfo duration. */
        public duration: number;

        /** WebMessageInfo labels. */
        public labels: string[];

        /** WebMessageInfo paymentInfo. */
        public paymentInfo?: (proto.IPaymentInfo|null);

        /** WebMessageInfo finalLiveLocation. */
        public finalLiveLocation?: (proto.Message.ILiveLocationMessage|null);

        /** WebMessageInfo quotedPaymentInfo. */
        public quotedPaymentInfo?: (proto.IPaymentInfo|null);

        /** WebMessageInfo ephemeralStartTimestamp. */
        public ephemeralStartTimestamp: (number|Long);

        /** WebMessageInfo ephemeralDuration. */
        public ephemeralDuration: number;

        /** WebMessageInfo ephemeralOffToOn. */
        public ephemeralOffToOn: boolean;

        /** WebMessageInfo ephemeralOutOfSync. */
        public ephemeralOutOfSync: boolean;

        /** WebMessageInfo bizPrivacyStatus. */
        public bizPrivacyStatus: proto.WebMessageInfo.BizPrivacyStatus;

        /** WebMessageInfo verifiedBizName. */
        public verifiedBizName: string;

        /** WebMessageInfo mediaData. */
        public mediaData?: (proto.IMediaData|null);

        /** WebMessageInfo photoChange. */
        public photoChange?: (proto.IPhotoChange|null);

        /** WebMessageInfo userReceipt. */
        public userReceipt: proto.IUserReceipt[];

        /** WebMessageInfo reactions. */
        public reactions: proto.IReaction[];

        /** WebMessageInfo quotedStickerData. */
        public quotedStickerData?: (proto.IMediaData|null);

        /** WebMessageInfo futureproofData. */
        public futureproofData: Uint8Array;

        /** WebMessageInfo statusPsa. */
        public statusPsa?: (proto.IStatusPSA|null);

        /** WebMessageInfo pollUpdates. */
        public pollUpdates: proto.IPollUpdate[];

        /** WebMessageInfo pollAdditionalMetadata. */
        public pollAdditionalMetadata?: (proto.IPollAdditionalMetadata|null);

        /** WebMessageInfo agentId. */
        public agentId: string;

        /** WebMessageInfo statusAlreadyViewed. */
        public statusAlreadyViewed: boolean;

        /** WebMessageInfo messageSecret. */
        public messageSecret: Uint8Array;

        /** WebMessageInfo keepInChat. */
        public keepInChat?: (proto.IKeepInChat|null);

        /** WebMessageInfo originalSelfAuthorUserJidString. */
        public originalSelfAuthorUserJidString: string;

        /** WebMessageInfo revokeMessageTimestamp. */
        public revokeMessageTimestamp: (number|Long);

        /**
         * Crea una nueva instancia WebMessageInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns WebMessageInfo instance
         */
        public static create(properties?: proto.IWebMessageInfo): proto.WebMessageInfo;

        /**
         * Codifica el mensaje WebMessageInfo. No implícitamente mensajes {@link proto.WebMessageInfo.verify|verify}.
         * @param message WebMessageInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IWebMessageInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje WebMessageInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.WebMessageInfo.verify|verify}.
         * @param message WebMessageInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IWebMessageInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a WebMessageInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns WebMessageInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.WebMessageInfo;

        /**
         * Decodes a WebMessageInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns WebMessageInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.WebMessageInfo;

        /**
         * Verifies a WebMessageInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a WebMessageInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns WebMessageInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.WebMessageInfo;

        /**
         * Crea un objeto simple desde WebMessageInfo. También convierte valores a otros tipos si se especifica.
         * @param message WebMessageInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.WebMessageInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  WebMessageInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace WebMessageInfo {

        /** BizPrivacyStatus enum. */
        enum BizPrivacyStatus {
            E2EE = 0,
            FB = 2,
            BSP = 1,
            BSP_AND_FB = 3
        }

        /** Status enum. */
        enum Status {
            ERROR = 0,
            PENDING = 1,
            SERVER_ACK = 2,
            DELIVERY_ACK = 3,
            READ = 4,
            PLAYED = 5
        }

        /** StubType enum. */
        enum StubType {
            UNKNOWN = 0,
            REVOKE = 1,
            CIPHERTEXT = 2,
            FUTUREPROOF = 3,
            NON_VERIFIED_TRANSITION = 4,
            UNVERIFIED_TRANSITION = 5,
            VERIFIED_TRANSITION = 6,
            VERIFIED_LOW_UNKNOWN = 7,
            VERIFIED_HIGH = 8,
            VERIFIED_INITIAL_UNKNOWN = 9,
            VERIFIED_INITIAL_LOW = 10,
            VERIFIED_INITIAL_HIGH = 11,
            VERIFIED_TRANSITION_ANY_TO_NONE = 12,
            VERIFIED_TRANSITION_ANY_TO_HIGH = 13,
            VERIFIED_TRANSITION_HIGH_TO_LOW = 14,
            VERIFIED_TRANSITION_HIGH_TO_UNKNOWN = 15,
            VERIFIED_TRANSITION_UNKNOWN_TO_LOW = 16,
            VERIFIED_TRANSITION_LOW_TO_UNKNOWN = 17,
            VERIFIED_TRANSITION_NONE_TO_LOW = 18,
            VERIFIED_TRANSITION_NONE_TO_UNKNOWN = 19,
            GROUP_CREATE = 20,
            GROUP_CHANGE_SUBJECT = 21,
            GROUP_CHANGE_ICON = 22,
            GROUP_CHANGE_INVITE_LINK = 23,
            GROUP_CHANGE_DESCRIPTION = 24,
            GROUP_CHANGE_RESTRICT = 25,
            GROUP_CHANGE_ANNOUNCE = 26,
            GROUP_PARTICIPANT_ADD = 27,
            GROUP_PARTICIPANT_REMOVE = 28,
            GROUP_PARTICIPANT_PROMOTE = 29,
            GROUP_PARTICIPANT_DEMOTE = 30,
            GROUP_PARTICIPANT_INVITE = 31,
            GROUP_PARTICIPANT_LEAVE = 32,
            GROUP_PARTICIPANT_CHANGE_NUMBER = 33,
            BROADCAST_CREATE = 34,
            BROADCAST_ADD = 35,
            BROADCAST_REMOVE = 36,
            GENERIC_NOTIFICATION = 37,
            E2E_IDENTITY_CHANGED = 38,
            E2E_ENCRYPTED = 39,
            CALL_MISSED_VOICE = 40,
            CALL_MISSED_VIDEO = 41,
            INDIVIDUAL_CHANGE_NUMBER = 42,
            GROUP_DELETE = 43,
            GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE = 44,
            CALL_MISSED_GROUP_VOICE = 45,
            CALL_MISSED_GROUP_VIDEO = 46,
            PAYMENT_CIPHERTEXT = 47,
            PAYMENT_FUTUREPROOF = 48,
            PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED = 49,
            PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED = 50,
            PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED = 51,
            PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP = 52,
            PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP = 53,
            PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER = 54,
            PAYMENT_ACTION_SEND_PAYMENT_REMINDER = 55,
            PAYMENT_ACTION_SEND_PAYMENT_INVITATION = 56,
            PAYMENT_ACTION_REQUEST_DECLINED = 57,
            PAYMENT_ACTION_REQUEST_EXPIRED = 58,
            PAYMENT_ACTION_REQUEST_CANCELLED = 59,
            BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM = 60,
            BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP = 61,
            BIZ_INTRO_TOP = 62,
            BIZ_INTRO_BOTTOM = 63,
            BIZ_NAME_CHANGE = 64,
            BIZ_MOVE_TO_CONSUMER_APP = 65,
            BIZ_TWO_TIER_MIGRATION_TOP = 66,
            BIZ_TWO_TIER_MIGRATION_BOTTOM = 67,
            OVERSIZED = 68,
            GROUP_CHANGE_NO_FREQUENTLY_FORWARDED = 69,
            GROUP_V4_ADD_INVITE_SENT = 70,
            GROUP_PARTICIPANT_ADD_REQUEST_JOIN = 71,
            CHANGE_EPHEMERAL_SETTING = 72,
            E2E_DEVICE_CHANGED = 73,
            VIEWED_ONCE = 74,
            E2E_ENCRYPTED_NOW = 75,
            BLUE_MSG_BSP_FB_TO_BSP_PREMISE = 76,
            BLUE_MSG_BSP_FB_TO_SELF_FB = 77,
            BLUE_MSG_BSP_FB_TO_SELF_PREMISE = 78,
            BLUE_MSG_BSP_FB_UNVERIFIED = 79,
            BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 80,
            BLUE_MSG_BSP_FB_VERIFIED = 81,
            BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 82,
            BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE = 83,
            BLUE_MSG_BSP_PREMISE_UNVERIFIED = 84,
            BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 85,
            BLUE_MSG_BSP_PREMISE_VERIFIED = 86,
            BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 87,
            BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED = 88,
            BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED = 89,
            BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED = 90,
            BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED = 91,
            BLUE_MSG_SELF_FB_TO_BSP_PREMISE = 92,
            BLUE_MSG_SELF_FB_TO_SELF_PREMISE = 93,
            BLUE_MSG_SELF_FB_UNVERIFIED = 94,
            BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 95,
            BLUE_MSG_SELF_FB_VERIFIED = 96,
            BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 97,
            BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE = 98,
            BLUE_MSG_SELF_PREMISE_UNVERIFIED = 99,
            BLUE_MSG_SELF_PREMISE_VERIFIED = 100,
            BLUE_MSG_TO_BSP_FB = 101,
            BLUE_MSG_TO_CONSUMER = 102,
            BLUE_MSG_TO_SELF_FB = 103,
            BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED = 104,
            BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 105,
            BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED = 106,
            BLUE_MSG_UNVERIFIED_TO_VERIFIED = 107,
            BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED = 108,
            BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 109,
            BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED = 110,
            BLUE_MSG_VERIFIED_TO_UNVERIFIED = 111,
            BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 112,
            BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED = 113,
            BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 114,
            BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED = 115,
            BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 116,
            BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 117,
            E2E_IDENTITY_UNAVAILABLE = 118,
            GROUP_CREATING = 119,
            GROUP_CREATE_FAILED = 120,
            GROUP_BOUNCED = 121,
            BLOCK_CONTACT = 122,
            EPHEMERAL_SETTING_NOT_APPLIED = 123,
            SYNC_FAILED = 124,
            SYNCING = 125,
            BIZ_PRIVACY_MODE_INIT_FB = 126,
            BIZ_PRIVACY_MODE_INIT_BSP = 127,
            BIZ_PRIVACY_MODE_TO_FB = 128,
            BIZ_PRIVACY_MODE_TO_BSP = 129,
            DISAPPEARING_MODE = 130,
            E2E_DEVICE_FETCH_FAILED = 131,
            ADMIN_REVOKE = 132,
            GROUP_INVITE_LINK_GROWTH_LOCKED = 133,
            COMMUNITY_LINK_PARENT_GROUP = 134,
            COMMUNITY_LINK_SIBLING_GROUP = 135,
            COMMUNITY_LINK_SUB_GROUP = 136,
            COMMUNITY_UNLINK_PARENT_GROUP = 137,
            COMMUNITY_UNLINK_SIBLING_GROUP = 138,
            COMMUNITY_UNLINK_SUB_GROUP = 139,
            GROUP_PARTICIPANT_ACCEPT = 140,
            GROUP_PARTICIPANT_LINKED_GROUP_JOIN = 141,
            COMMUNITY_CREATE = 142,
            EPHEMERAL_KEEP_IN_CHAT = 143,
            GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST = 144,
            GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE = 145,
            INTEGRITY_UNLINK_PARENT_GROUP = 146,
            COMMUNITY_PARTICIPANT_PROMOTE = 147,
            COMMUNITY_PARTICIPANT_DEMOTE = 148,
            COMMUNITY_PARENT_GROUP_DELETED = 149,
            COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL = 150,
            GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP = 151,
            MASKED_THREAD_CREATED = 152,
            MASKED_THREAD_UNMASKED = 153,
            BIZ_CHAT_ASSIGNMENT = 154,
            CHAT_PSA = 155,
            CHAT_POLL_CREATION_MESSAGE = 156,
            CAG_MASKED_THREAD_CREATED = 157,
            COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED = 158,
            CAG_INVITE_AUTO_ADD = 159,
            BIZ_CHAT_ASSIGNMENT_UNASSIGN = 160,
            CAG_INVITE_AUTO_JOINED = 161
        }
    }

    /** Propiedades de un WebNotificationsInfo. */
    interface IWebNotificationsInfo {

        /** WebNotificationsInfo timestamp */
        timestamp?: (number|Long|null);

        /** WebNotificationsInfo unreadChats */
        unreadChats?: (number|null);

        /** WebNotificationsInfo notifyMessageCount */
        notifyMessageCount?: (number|null);

        /** WebNotificationsInfo notifyMessages */
        notifyMessages?: (proto.IWebMessageInfo[]|null);
    }

    /** Representa un WebNotificationsInfo. */
    class WebNotificationsInfo implements IWebNotificationsInfo {

        /**
         * Construya un nuevo WebNotificationsInfo.
         * @param [properties] para establecer propiedades
         */
        constructor(properties?: proto.IWebNotificationsInfo);

        /** WebNotificationsInfo timestamp. */
        public timestamp: (number|Long);

        /** WebNotificationsInfo unreadChats. */
        public unreadChats: number;

        /** WebNotificationsInfo notifyMessageCount. */
        public notifyMessageCount: number;

        /** WebNotificationsInfo notifyMessages. */
        public notifyMessages: proto.IWebMessageInfo[];

        /**
         * Crea una nueva instancia WebNotificationsInfo utilizando las propiedades especificadas.
         * @param [properties] para establecer propiedades
         * @returns WebNotificationsInfo instance
         */
        public static create(properties?: proto.IWebNotificationsInfo): proto.WebNotificationsInfo;

        /**
         * Codifica el mensaje WebNotificationsInfo. No implícitamente mensajes {@link proto.WebNotificationsInfo.verify|verify}.
         * @param message WebNotificationsInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encode(message: proto.IWebNotificationsInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Codifica el mensaje WebNotificationsInfo message, delimitado por longitud. No implícitamente mensajes {@link proto.WebNotificationsInfo.verify|verify}.
         * @param message WebNotificationsInfo mensaje o objeto simple para codificar
         * @param [writer] Writer para codificar a
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IWebNotificationsInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a WebNotificationsInfo message from the specified reader or buffer.
         * @param reader Reader o búfer para decodificar desde
         * @param [length] Longitud del mensaje si se conoce de antemano
         * @returns WebNotificationsInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.WebNotificationsInfo;

        /**
         * Decodes a WebNotificationsInfo message desde el especifico lector o búfer, longitud delimitada.
         * @param reader Reader o búfer para decodificar desde
         * @returns WebNotificationsInfo
         * @throws {Error} Si la carga útil no es un lector o un búfer válido
         * @throws {$protobuf.util.ProtocolError} Si faltan campos requeridos
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.WebNotificationsInfo;

        /**
         * Verifies a WebNotificationsInfo message.
         * @param message Objeto simple para verificar
         * @returns `null` Si es válido, de lo contrario la razón por la que no es
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a WebNotificationsInfo message desde un objeto simple. También convierte valores a sus respectivos tipos internos.
         * @param object Objeto simple
         * @returns WebNotificationsInfo
         */
        public static fromObject(object: { [k: string]: any }): proto.WebNotificationsInfo;

        /**
         * Crea un objeto simple desde WebNotificationsInfo. También convierte valores a otros tipos si se especifica.
         * @param message WebNotificationsInfo
         * @param [options] Opciones de conversión
         * @returns Objeto simple
         */
        public static toObject(message: proto.WebNotificationsInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Convierte este  WebNotificationsInfo a JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }
}
